/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./libs/shepherd/shepherd.js":
/*!***********************************!*\
  !*** ./libs/shepherd/shepherd.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Shepherd\": function() { return /* reexport default from dynamic */ shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shepherd.js/dist/js/shepherd */ \"./node_modules/shepherd.js/dist/js/shepherd.js\");\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9saWJzL3NoZXBoZXJkL3NoZXBoZXJkLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvRCIsInNvdXJjZXMiOlsid2VicGFjazovL01hdGVyaWFsaXplLy4vbGlicy9zaGVwaGVyZC9zaGVwaGVyZC5qcz83YTgzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTaGVwaGVyZCBmcm9tICdzaGVwaGVyZC5qcy9kaXN0L2pzL3NoZXBoZXJkJztcblxuZXhwb3J0IHsgU2hlcGhlcmQgfTtcbiJdLCJuYW1lcyI6WyJTaGVwaGVyZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./libs/shepherd/shepherd.js\n");

/***/ }),

/***/ "./node_modules/shepherd.js/dist/js/shepherd.js":
/*!******************************************************!*\
  !*** ./node_modules/shepherd.js/dist/js/shepherd.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*! shepherd.js 10.0.1 */\n\n(function (global, factory) {\n  ( false ? 0 : _typeof(exports)) === 'object' && \"object\" !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(this, function () {\n  'use strict';\n\n  var isMergeableObject = function isMergeableObject(value) {\n    return isNonNullObject(value) && !isSpecial(value);\n  };\n  function isNonNullObject(value) {\n    return !!value && _typeof(value) === 'object';\n  }\n  function isSpecial(value) {\n    var stringValue = Object.prototype.toString.call(value);\n    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);\n  } // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\n\n  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;\n  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n  function isReactElement(value) {\n    return value.$$typeof === REACT_ELEMENT_TYPE;\n  }\n  function emptyTarget(val) {\n    return Array.isArray(val) ? [] : {};\n  }\n  function cloneUnlessOtherwiseSpecified(value, options) {\n    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;\n  }\n  function defaultArrayMerge(target, source, options) {\n    return target.concat(source).map(function (element) {\n      return cloneUnlessOtherwiseSpecified(element, options);\n    });\n  }\n  function getMergeFunction(key, options) {\n    if (!options.customMerge) {\n      return deepmerge;\n    }\n    var customMerge = options.customMerge(key);\n    return typeof customMerge === 'function' ? customMerge : deepmerge;\n  }\n  function getEnumerableOwnPropertySymbols(target) {\n    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {\n      return target.propertyIsEnumerable(symbol);\n    }) : [];\n  }\n  function getKeys(target) {\n    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));\n  }\n  function propertyIsOnObject(object, property) {\n    try {\n      return property in object;\n    } catch (_) {\n      return false;\n    }\n  } // Protects from prototype poisoning and unexpected merging up the prototype chain.\n\n  function propertyIsUnsafe(target, key) {\n    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n    && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n    && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.\n  }\n\n  function mergeObject(target, source, options) {\n    var destination = {};\n    if (options.isMergeableObject(target)) {\n      getKeys(target).forEach(function (key) {\n        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n      });\n    }\n    getKeys(source).forEach(function (key) {\n      if (propertyIsUnsafe(target, key)) {\n        return;\n      }\n      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n      } else {\n        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n      }\n    });\n    return destination;\n  }\n  function deepmerge(target, source, options) {\n    options = options || {};\n    options.arrayMerge = options.arrayMerge || defaultArrayMerge;\n    options.isMergeableObject = options.isMergeableObject || isMergeableObject; // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n    // implementations can use it. The caller may not replace it.\n\n    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n    var sourceIsArray = Array.isArray(source);\n    var targetIsArray = Array.isArray(target);\n    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n    if (!sourceAndTargetTypesMatch) {\n      return cloneUnlessOtherwiseSpecified(source, options);\n    } else if (sourceIsArray) {\n      return options.arrayMerge(target, source, options);\n    } else {\n      return mergeObject(target, source, options);\n    }\n  }\n  deepmerge.all = function deepmergeAll(array, options) {\n    if (!Array.isArray(array)) {\n      throw new Error('first argument should be an array');\n    }\n    return array.reduce(function (prev, next) {\n      return deepmerge(prev, next, options);\n    }, {});\n  };\n  var deepmerge_1 = deepmerge;\n  var cjs = deepmerge_1;\n\n  /**\n   * Checks if `value` is classified as an `Element`.\n   * @param {*} value The param to check if it is an Element\n   */\n  function isElement$1(value) {\n    return value instanceof Element;\n  }\n  /**\n   * Checks if `value` is classified as an `HTMLElement`.\n   * @param {*} value The param to check if it is an HTMLElement\n   */\n\n  function isHTMLElement$1(value) {\n    return value instanceof HTMLElement;\n  }\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   * @param {*} value The param to check if it is a function\n   */\n\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n  /**\n   * Checks if `value` is classified as a `String` object.\n   * @param {*} value The param to check if it is a string\n   */\n\n  function isString(value) {\n    return typeof value === 'string';\n  }\n  /**\n   * Checks if `value` is undefined.\n   * @param {*} value The param to check if it is undefined\n   */\n\n  function isUndefined(value) {\n    return value === undefined;\n  }\n  var Evented = /*#__PURE__*/function () {\n    function Evented() {\n      _classCallCheck(this, Evented);\n    }\n    _createClass(Evented, [{\n      key: \"on\",\n      value: function on(event, handler, ctx, once) {\n        if (once === void 0) {\n          once = false;\n        }\n        if (isUndefined(this.bindings)) {\n          this.bindings = {};\n        }\n        if (isUndefined(this.bindings[event])) {\n          this.bindings[event] = [];\n        }\n        this.bindings[event].push({\n          handler: handler,\n          ctx: ctx,\n          once: once\n        });\n        return this;\n      }\n    }, {\n      key: \"once\",\n      value: function once(event, handler, ctx) {\n        return this.on(event, handler, ctx, true);\n      }\n    }, {\n      key: \"off\",\n      value: function off(event, handler) {\n        var _this = this;\n        if (isUndefined(this.bindings) || isUndefined(this.bindings[event])) {\n          return this;\n        }\n        if (isUndefined(handler)) {\n          delete this.bindings[event];\n        } else {\n          this.bindings[event].forEach(function (binding, index) {\n            if (binding.handler === handler) {\n              _this.bindings[event].splice(index, 1);\n            }\n          });\n        }\n        return this;\n      }\n    }, {\n      key: \"trigger\",\n      value: function trigger(event) {\n        var _this2 = this;\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        if (!isUndefined(this.bindings) && this.bindings[event]) {\n          this.bindings[event].forEach(function (binding, index) {\n            var ctx = binding.ctx,\n              handler = binding.handler,\n              once = binding.once;\n            var context = ctx || _this2;\n            handler.apply(context, args);\n            if (once) {\n              _this2.bindings[event].splice(index, 1);\n            }\n          });\n        }\n        return this;\n      }\n    }]);\n    return Evented;\n  }();\n  /**\n   * Binds all the methods on a JS Class to the `this` context of the class.\n   * Adapted from https://github.com/sindresorhus/auto-bind\n   * @param {object} self The `this` context of the class\n   * @return {object} The `this` context of the class\n   */\n  function autoBind(self) {\n    var keys = Object.getOwnPropertyNames(self.constructor.prototype);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var val = self[key];\n      if (key !== 'constructor' && typeof val === 'function') {\n        self[key] = val.bind(self);\n      }\n    }\n    return self;\n  }\n\n  /**\n   * Sets up the handler to determine if we should advance the tour\n   * @param {string} selector\n   * @param {Step} step The step instance\n   * @return {Function}\n   * @private\n   */\n\n  function _setupAdvanceOnHandler(selector, step) {\n    return function (event) {\n      if (step.isOpen()) {\n        var targetIsEl = step.el && event.currentTarget === step.el;\n        var targetIsSelector = !isUndefined(selector) && event.currentTarget.matches(selector);\n        if (targetIsSelector || targetIsEl) {\n          step.tour.next();\n        }\n      }\n    };\n  }\n  /**\n   * Bind the event handler for advanceOn\n   * @param {Step} step The step instance\n   */\n\n  function bindAdvance(step) {\n    // An empty selector matches the step element\n    var _ref6 = step.options.advanceOn || {},\n      event = _ref6.event,\n      selector = _ref6.selector;\n    if (event) {\n      var handler = _setupAdvanceOnHandler(selector, step); // TODO: this should also bind/unbind on show/hide\n\n      var el;\n      try {\n        el = document.querySelector(selector);\n      } catch (e) {// TODO\n      }\n      if (!isUndefined(selector) && !el) {\n        return console.error(\"No element was found for the selector supplied to advanceOn: \".concat(selector));\n      } else if (el) {\n        el.addEventListener(event, handler);\n        step.on('destroy', function () {\n          return el.removeEventListener(event, handler);\n        });\n      } else {\n        document.body.addEventListener(event, handler, true);\n        step.on('destroy', function () {\n          return document.body.removeEventListener(event, handler, true);\n        });\n      }\n    } else {\n      return console.error('advanceOn was defined, but no event name was passed.');\n    }\n  }\n  var top = 'top';\n  var bottom = 'bottom';\n  var right = 'right';\n  var left = 'left';\n  var auto = 'auto';\n  var basePlacements = [top, bottom, right, left];\n  var start = 'start';\n  var end = 'end';\n  var clippingParents = 'clippingParents';\n  var viewport = 'viewport';\n  var popper = 'popper';\n  var reference = 'reference';\n  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n    return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n  }, []);\n  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n    return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n  }, []); // modifiers that need to read the DOM\n\n  var beforeRead = 'beforeRead';\n  var read = 'read';\n  var afterRead = 'afterRead'; // pure-logic modifiers\n\n  var beforeMain = 'beforeMain';\n  var main = 'main';\n  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\n  var beforeWrite = 'beforeWrite';\n  var write = 'write';\n  var afterWrite = 'afterWrite';\n  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n  function getNodeName(element) {\n    return element ? (element.nodeName || '').toLowerCase() : null;\n  }\n  function getWindow(node) {\n    if (node == null) {\n      return window;\n    }\n    if (node.toString() !== '[object Window]') {\n      var ownerDocument = node.ownerDocument;\n      return ownerDocument ? ownerDocument.defaultView || window : window;\n    }\n    return node;\n  }\n  function isElement(node) {\n    var OwnElement = getWindow(node).Element;\n    return node instanceof OwnElement || node instanceof Element;\n  }\n  function isHTMLElement(node) {\n    var OwnElement = getWindow(node).HTMLElement;\n    return node instanceof OwnElement || node instanceof HTMLElement;\n  }\n  function isShadowRoot(node) {\n    // IE 11 has no ShadowRoot\n    if (typeof ShadowRoot === 'undefined') {\n      return false;\n    }\n    var OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n  }\n\n  // and applies them to the HTMLElements such as popper and arrow\n\n  function applyStyles(_ref) {\n    var state = _ref.state;\n    Object.keys(state.elements).forEach(function (name) {\n      var style = state.styles[name] || {};\n      var attributes = state.attributes[name] || {};\n      var element = state.elements[name]; // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      } // Flow doesn't support to extend this property, but it's the most\n      // effective way to apply styles to an HTMLElement\n      // $FlowFixMe[cannot-write]\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (name) {\n        var value = attributes[name];\n        if (value === false) {\n          element.removeAttribute(name);\n        } else {\n          element.setAttribute(name, value === true ? '' : value);\n        }\n      });\n    });\n  }\n  function effect$2(_ref2) {\n    var state = _ref2.state;\n    var initialStyles = {\n      popper: {\n        position: state.options.strategy,\n        left: '0',\n        top: '0',\n        margin: '0'\n      },\n      arrow: {\n        position: 'absolute'\n      },\n      reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n    if (state.elements.arrow) {\n      Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    }\n    return function () {\n      Object.keys(state.elements).forEach(function (name) {\n        var element = state.elements[name];\n        var attributes = state.attributes[name] || {};\n        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n        var style = styleProperties.reduce(function (style, property) {\n          style[property] = '';\n          return style;\n        }, {}); // arrow is optional + virtual elements\n\n        if (!isHTMLElement(element) || !getNodeName(element)) {\n          return;\n        }\n        Object.assign(element.style, style);\n        Object.keys(attributes).forEach(function (attribute) {\n          element.removeAttribute(attribute);\n        });\n      });\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var applyStyles$1 = {\n    name: 'applyStyles',\n    enabled: true,\n    phase: 'write',\n    fn: applyStyles,\n    effect: effect$2,\n    requires: ['computeStyles']\n  };\n  function getBasePlacement(placement) {\n    return placement.split('-')[0];\n  }\n  var max = Math.max;\n  var min = Math.min;\n  var round = Math.round;\n  function getBoundingClientRect(element, includeScale) {\n    if (includeScale === void 0) {\n      includeScale = false;\n    }\n    var rect = element.getBoundingClientRect();\n    var scaleX = 1;\n    var scaleY = 1;\n    if (isHTMLElement(element) && includeScale) {\n      var offsetHeight = element.offsetHeight;\n      var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale\n      // Fallback to 1 in case both values are `0`\n\n      if (offsetWidth > 0) {\n        scaleX = round(rect.width) / offsetWidth || 1;\n      }\n      if (offsetHeight > 0) {\n        scaleY = round(rect.height) / offsetHeight || 1;\n      }\n    }\n    return {\n      width: rect.width / scaleX,\n      height: rect.height / scaleY,\n      top: rect.top / scaleY,\n      right: rect.right / scaleX,\n      bottom: rect.bottom / scaleY,\n      left: rect.left / scaleX,\n      x: rect.left / scaleX,\n      y: rect.top / scaleY\n    };\n  }\n\n  // means it doesn't take into account transforms.\n\n  function getLayoutRect(element) {\n    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n    // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n    var width = element.offsetWidth;\n    var height = element.offsetHeight;\n    if (Math.abs(clientRect.width - width) <= 1) {\n      width = clientRect.width;\n    }\n    if (Math.abs(clientRect.height - height) <= 1) {\n      height = clientRect.height;\n    }\n    return {\n      x: element.offsetLeft,\n      y: element.offsetTop,\n      width: width,\n      height: height\n    };\n  }\n  function contains(parent, child) {\n    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n    if (parent.contains(child)) {\n      return true;\n    } // then fallback to custom implementation with Shadow DOM support\n    else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n    return false;\n  }\n  function getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n  }\n  function isTableElement(element) {\n    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n  }\n  function getDocumentElement(element) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return ((isElement(element) ? element.ownerDocument :\n    // $FlowFixMe[prop-missing]\n    element.document) || window.document).documentElement;\n  }\n  function getParentNode(element) {\n    if (getNodeName(element) === 'html') {\n      return element;\n    }\n    return (\n      // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n      // $FlowFixMe[incompatible-return]\n      // $FlowFixMe[prop-missing]\n      element.assignedSlot ||\n      // step into the shadow DOM of the parent of a slotted node\n      element.parentNode || (\n      // DOM Element detected\n      isShadowRoot(element) ? element.host : null) ||\n      // ShadowRoot detected\n      // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n      getDocumentElement(element) // fallback\n    );\n  }\n\n  function getTrueOffsetParent(element) {\n    if (!isHTMLElement(element) ||\n    // https://github.com/popperjs/popper-core/issues/837\n    getComputedStyle(element).position === 'fixed') {\n      return null;\n    }\n    return element.offsetParent;\n  } // `.offsetParent` reports `null` for fixed elements, while absolute elements\n  // return the containing block\n\n  function getContainingBlock(element) {\n    var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;\n    var isIE = navigator.userAgent.indexOf('Trident') !== -1;\n    if (isIE && isHTMLElement(element)) {\n      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n      var elementCss = getComputedStyle(element);\n      if (elementCss.position === 'fixed') {\n        return null;\n      }\n    }\n    var currentNode = getParentNode(element);\n    if (isShadowRoot(currentNode)) {\n      currentNode = currentNode.host;\n    }\n    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n      var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n      // create a containing block.\n      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n        return currentNode;\n      } else {\n        currentNode = currentNode.parentNode;\n      }\n    }\n    return null;\n  } // Gets the closest ancestor positioned element. Handles some edge cases,\n  // such as table ancestors and cross browser bugs.\n\n  function getOffsetParent(element) {\n    var window = getWindow(element);\n    var offsetParent = getTrueOffsetParent(element);\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n      offsetParent = getTrueOffsetParent(offsetParent);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {\n      return window;\n    }\n    return offsetParent || getContainingBlock(element) || window;\n  }\n  function getMainAxisFromPlacement(placement) {\n    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n  }\n  function within(min$1, value, max$1) {\n    return max(min$1, min(value, max$1));\n  }\n  function withinMaxClamp(min, value, max) {\n    var v = within(min, value, max);\n    return v > max ? max : v;\n  }\n  function getFreshSideObject() {\n    return {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n  }\n  function mergePaddingObject(paddingObject) {\n    return Object.assign({}, getFreshSideObject(), paddingObject);\n  }\n  function expandToHashMap(value, keys) {\n    return keys.reduce(function (hashMap, key) {\n      hashMap[key] = value;\n      return hashMap;\n    }, {});\n  }\n  var toPaddingObject = function toPaddingObject(padding, state) {\n    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : padding;\n    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  };\n  function arrow(_ref) {\n    var _state$modifiersData$;\n    var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n    var arrowElement = state.elements.arrow;\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var basePlacement = getBasePlacement(state.placement);\n    var axis = getMainAxisFromPlacement(basePlacement);\n    var isVertical = [left, right].indexOf(basePlacement) >= 0;\n    var len = isVertical ? 'height' : 'width';\n    if (!arrowElement || !popperOffsets) {\n      return;\n    }\n    var paddingObject = toPaddingObject(options.padding, state);\n    var arrowRect = getLayoutRect(arrowElement);\n    var minProp = axis === 'y' ? top : left;\n    var maxProp = axis === 'y' ? bottom : right;\n    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n    var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n    var arrowOffsetParent = getOffsetParent(arrowElement);\n    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n    // outside of the popper bounds\n\n    var min = paddingObject[minProp];\n    var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n    var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n    var axisProp = axis;\n    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n  }\n  function effect$1(_ref2) {\n    var state = _ref2.state,\n      options = _ref2.options;\n    var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n    if (arrowElement == null) {\n      return;\n    } // CSS selector\n\n    if (typeof arrowElement === 'string') {\n      arrowElement = state.elements.popper.querySelector(arrowElement);\n      if (!arrowElement) {\n        return;\n      }\n    }\n    if (!contains(state.elements.popper, arrowElement)) {\n      return;\n    }\n    state.elements.arrow = arrowElement;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var arrow$1 = {\n    name: 'arrow',\n    enabled: true,\n    phase: 'main',\n    fn: arrow,\n    effect: effect$1,\n    requires: ['popperOffsets'],\n    requiresIfExists: ['preventOverflow']\n  };\n  function getVariation(placement) {\n    return placement.split('-')[1];\n  }\n  var unsetSides = {\n    top: 'auto',\n    right: 'auto',\n    bottom: 'auto',\n    left: 'auto'\n  }; // Round the offsets to the nearest suitable subpixel based on the DPR.\n  // Zooming can change the DPR, but it seems to report a value that will\n  // cleanly divide the values into the appropriate subpixels.\n\n  function roundOffsetsByDPR(_ref) {\n    var x = _ref.x,\n      y = _ref.y;\n    var win = window;\n    var dpr = win.devicePixelRatio || 1;\n    return {\n      x: round(x * dpr) / dpr || 0,\n      y: round(y * dpr) / dpr || 0\n    };\n  }\n  function mapToStyles(_ref2) {\n    var _Object$assign2;\n    var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      variation = _ref2.variation,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets,\n      isFixed = _ref2.isFixed;\n    var _offsets$x = offsets.x,\n      x = _offsets$x === void 0 ? 0 : _offsets$x,\n      _offsets$y = offsets.y,\n      y = _offsets$y === void 0 ? 0 : _offsets$y;\n    var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\n      x: x,\n      y: y\n    }) : {\n      x: x,\n      y: y\n    };\n    x = _ref3.x;\n    y = _ref3.y;\n    var hasX = offsets.hasOwnProperty('x');\n    var hasY = offsets.hasOwnProperty('y');\n    var sideX = left;\n    var sideY = top;\n    var win = window;\n    if (adaptive) {\n      var offsetParent = getOffsetParent(popper);\n      var heightProp = 'clientHeight';\n      var widthProp = 'clientWidth';\n      if (offsetParent === getWindow(popper)) {\n        offsetParent = getDocumentElement(popper);\n        if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {\n          heightProp = 'scrollHeight';\n          widthProp = 'scrollWidth';\n        }\n      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n      offsetParent = offsetParent;\n      if (placement === top || (placement === left || placement === right) && variation === end) {\n        sideY = bottom;\n        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height :\n        // $FlowFixMe[prop-missing]\n        offsetParent[heightProp];\n        y -= offsetY - popperRect.height;\n        y *= gpuAcceleration ? 1 : -1;\n      }\n      if (placement === left || (placement === top || placement === bottom) && variation === end) {\n        sideX = right;\n        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width :\n        // $FlowFixMe[prop-missing]\n        offsetParent[widthProp];\n        x -= offsetX - popperRect.width;\n        x *= gpuAcceleration ? 1 : -1;\n      }\n    }\n    var commonStyles = Object.assign({\n      position: position\n    }, adaptive && unsetSides);\n    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n      x: x,\n      y: y\n    }) : {\n      x: x,\n      y: y\n    };\n    x = _ref4.x;\n    y = _ref4.y;\n    if (gpuAcceleration) {\n      var _Object$assign;\n      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n    }\n    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n  }\n  function computeStyles(_ref5) {\n    var state = _ref5.state,\n      options = _ref5.options;\n    var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n    var commonStyles = {\n      placement: getBasePlacement(state.placement),\n      variation: getVariation(state.placement),\n      popper: state.elements.popper,\n      popperRect: state.rects.popper,\n      gpuAcceleration: gpuAcceleration,\n      isFixed: state.options.strategy === 'fixed'\n    };\n    if (state.modifiersData.popperOffsets != null) {\n      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.popperOffsets,\n        position: state.options.strategy,\n        adaptive: adaptive,\n        roundOffsets: roundOffsets\n      })));\n    }\n    if (state.modifiersData.arrow != null) {\n      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.arrow,\n        position: 'absolute',\n        adaptive: false,\n        roundOffsets: roundOffsets\n      })));\n    }\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-placement': state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var computeStyles$1 = {\n    name: 'computeStyles',\n    enabled: true,\n    phase: 'beforeWrite',\n    fn: computeStyles,\n    data: {}\n  };\n  var passive = {\n    passive: true\n  };\n  function effect(_ref) {\n    var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n    var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n    var window = getWindow(state.elements.popper);\n    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.addEventListener('scroll', instance.update, passive);\n      });\n    }\n    if (resize) {\n      window.addEventListener('resize', instance.update, passive);\n    }\n    return function () {\n      if (scroll) {\n        scrollParents.forEach(function (scrollParent) {\n          scrollParent.removeEventListener('scroll', instance.update, passive);\n        });\n      }\n      if (resize) {\n        window.removeEventListener('resize', instance.update, passive);\n      }\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var eventListeners = {\n    name: 'eventListeners',\n    enabled: true,\n    phase: 'write',\n    fn: function fn() {},\n    effect: effect,\n    data: {}\n  };\n  var hash$1 = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  function getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, function (matched) {\n      return hash$1[matched];\n    });\n  }\n  var hash = {\n    start: 'end',\n    end: 'start'\n  };\n  function getOppositeVariationPlacement(placement) {\n    return placement.replace(/start|end/g, function (matched) {\n      return hash[matched];\n    });\n  }\n  function getWindowScroll(node) {\n    var win = getWindow(node);\n    var scrollLeft = win.pageXOffset;\n    var scrollTop = win.pageYOffset;\n    return {\n      scrollLeft: scrollLeft,\n      scrollTop: scrollTop\n    };\n  }\n  function getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    // Popper 1 is broken in this case and never had a bug report so let's assume\n    // it's not an issue. I don't think anyone ever specifies width on <html>\n    // anyway.\n    // Browsers where the left scrollbar doesn't cause an issue report `0` for\n    // this (e.g. Edge 2019, IE11, Safari)\n    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n  }\n  function getViewportRect(element) {\n    var win = getWindow(element);\n    var html = getDocumentElement(element);\n    var visualViewport = win.visualViewport;\n    var width = html.clientWidth;\n    var height = html.clientHeight;\n    var x = 0;\n    var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper\n    // can be obscured underneath it.\n    // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even\n    // if it isn't open, so if this isn't available, the popper will be detected\n    // to overflow the bottom of the screen too early.\n\n    if (visualViewport) {\n      width = visualViewport.width;\n      height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n      // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n      // errors due to floating point numbers, so we need to check precision.\n      // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n      // Feature detection fails in mobile emulation mode in Chrome.\n      // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <\n      // 0.001\n      // Fallback here: \"Not Safari\" userAgent\n\n      if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n        x = visualViewport.offsetLeft;\n        y = visualViewport.offsetTop;\n      }\n    }\n    return {\n      width: width,\n      height: height,\n      x: x + getWindowScrollBarX(element),\n      y: y\n    };\n  }\n\n  // of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\n  function getDocumentRect(element) {\n    var _element$ownerDocumen;\n    var html = getDocumentElement(element);\n    var winScroll = getWindowScroll(element);\n    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n    var y = -winScroll.scrollTop;\n    if (getComputedStyle(body || html).direction === 'rtl') {\n      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n    }\n    return {\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    };\n  }\n  function isScrollParent(element) {\n    // Firefox wants us to check `-x` and `-y` variations as well\n    var _getComputedStyle = getComputedStyle(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n  }\n  function getScrollParent(node) {\n    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n      // $FlowFixMe[incompatible-return]: assume body is always available\n      return node.ownerDocument.body;\n    }\n    if (isHTMLElement(node) && isScrollParent(node)) {\n      return node;\n    }\n    return getScrollParent(getParentNode(node));\n  }\n\n  /*\n  given a DOM element, return the list of all scroll parents, up the list of ancesors\n  until we get to the top window object. This list is what we attach scroll listeners\n  to, because if any of these parent elements scroll, we'll need to re-calculate the\n  reference element's position.\n  */\n\n  function listScrollParents(element, list) {\n    var _element$ownerDocumen;\n    if (list === void 0) {\n      list = [];\n    }\n    var scrollParent = getScrollParent(element);\n    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n    var win = getWindow(scrollParent);\n    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n    var updatedList = list.concat(target);\n    return isBody ? updatedList :\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    updatedList.concat(listScrollParents(getParentNode(target)));\n  }\n  function rectToClientRect(rect) {\n    return Object.assign({}, rect, {\n      left: rect.x,\n      top: rect.y,\n      right: rect.x + rect.width,\n      bottom: rect.y + rect.height\n    });\n  }\n  function getInnerBoundingClientRect(element) {\n    var rect = getBoundingClientRect(element);\n    rect.top = rect.top + element.clientTop;\n    rect.left = rect.left + element.clientLeft;\n    rect.bottom = rect.top + element.clientHeight;\n    rect.right = rect.left + element.clientWidth;\n    rect.width = element.clientWidth;\n    rect.height = element.clientHeight;\n    rect.x = rect.left;\n    rect.y = rect.top;\n    return rect;\n  }\n  function getClientRectFromMixedType(element, clippingParent) {\n    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n  } // A \"clipping parent\" is an overflowable container with the characteristic of\n  // clipping (or hiding) overflowing elements with a position different from\n  // `initial`\n\n  function getClippingParents(element) {\n    var clippingParents = listScrollParents(getParentNode(element));\n    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n    if (!isElement(clipperElement)) {\n      return [];\n    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n    return clippingParents.filter(function (clippingParent) {\n      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n    });\n  } // Gets the maximum area that the element is visible in due to any number of\n  // clipping parents\n\n  function getClippingRect(element, boundary, rootBoundary) {\n    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n    var firstClippingParent = clippingParents[0];\n    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n      var rect = getClientRectFromMixedType(element, clippingParent);\n      accRect.top = max(rect.top, accRect.top);\n      accRect.right = min(rect.right, accRect.right);\n      accRect.bottom = min(rect.bottom, accRect.bottom);\n      accRect.left = max(rect.left, accRect.left);\n      return accRect;\n    }, getClientRectFromMixedType(element, firstClippingParent));\n    clippingRect.width = clippingRect.right - clippingRect.left;\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\n    clippingRect.x = clippingRect.left;\n    clippingRect.y = clippingRect.top;\n    return clippingRect;\n  }\n  function computeOffsets(_ref) {\n    var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n    var basePlacement = placement ? getBasePlacement(placement) : null;\n    var variation = placement ? getVariation(placement) : null;\n    var commonX = reference.x + reference.width / 2 - element.width / 2;\n    var commonY = reference.y + reference.height / 2 - element.height / 2;\n    var offsets;\n    switch (basePlacement) {\n      case top:\n        offsets = {\n          x: commonX,\n          y: reference.y - element.height\n        };\n        break;\n      case bottom:\n        offsets = {\n          x: commonX,\n          y: reference.y + reference.height\n        };\n        break;\n      case right:\n        offsets = {\n          x: reference.x + reference.width,\n          y: commonY\n        };\n        break;\n      case left:\n        offsets = {\n          x: reference.x - element.width,\n          y: commonY\n        };\n        break;\n      default:\n        offsets = {\n          x: reference.x,\n          y: reference.y\n        };\n    }\n    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n    if (mainAxis != null) {\n      var len = mainAxis === 'y' ? 'height' : 'width';\n      switch (variation) {\n        case start:\n          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n          break;\n        case end:\n          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n          break;\n      }\n    }\n    return offsets;\n  }\n  function detectOverflow(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n    var altContext = elementContext === popper ? reference : popper;\n    var popperRect = state.rects.popper;\n    var element = state.elements[altBoundary ? altContext : elementContext];\n    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n    var referenceClientRect = getBoundingClientRect(state.elements.reference);\n    var popperOffsets = computeOffsets({\n      reference: referenceClientRect,\n      element: popperRect,\n      strategy: 'absolute',\n      placement: placement\n    });\n    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n    // 0 or negative = within the clipping rect\n\n    var overflowOffsets = {\n      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n      right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n    if (elementContext === popper && offsetData) {\n      var offset = offsetData[placement];\n      Object.keys(overflowOffsets).forEach(function (key) {\n        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n        overflowOffsets[key] += offset[axis] * multiply;\n      });\n    }\n    return overflowOffsets;\n  }\n  function computeAutoPlacement(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n    var variation = getVariation(placement);\n    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n      return getVariation(placement) === variation;\n    }) : basePlacements;\n    var allowedPlacements = placements$1.filter(function (placement) {\n      return allowedAutoPlacements.indexOf(placement) >= 0;\n    });\n    if (allowedPlacements.length === 0) {\n      allowedPlacements = placements$1;\n    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n    var overflows = allowedPlacements.reduce(function (acc, placement) {\n      acc[placement] = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding\n      })[getBasePlacement(placement)];\n      return acc;\n    }, {});\n    return Object.keys(overflows).sort(function (a, b) {\n      return overflows[a] - overflows[b];\n    });\n  }\n  function getExpandedFallbackPlacements(placement) {\n    if (getBasePlacement(placement) === auto) {\n      return [];\n    }\n    var oppositePlacement = getOppositePlacement(placement);\n    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n  }\n  function flip(_ref) {\n    var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n    if (state.modifiersData[name]._skip) {\n      return;\n    }\n    var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n    var preferredPlacement = state.options.placement;\n    var basePlacement = getBasePlacement(preferredPlacement);\n    var isBasePlacement = basePlacement === preferredPlacement;\n    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n      return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding,\n        flipVariations: flipVariations,\n        allowedAutoPlacements: allowedAutoPlacements\n      }) : placement);\n    }, []);\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var checksMap = new Map();\n    var makeFallbackChecks = true;\n    var firstFittingPlacement = placements[0];\n    for (var i = 0; i < placements.length; i++) {\n      var placement = placements[i];\n      var _basePlacement = getBasePlacement(placement);\n      var isStartVariation = getVariation(placement) === start;\n      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n      var len = isVertical ? 'width' : 'height';\n      var overflow = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        altBoundary: altBoundary,\n        padding: padding\n      });\n      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n      if (referenceRect[len] > popperRect[len]) {\n        mainVariationSide = getOppositePlacement(mainVariationSide);\n      }\n      var altVariationSide = getOppositePlacement(mainVariationSide);\n      var checks = [];\n      if (checkMainAxis) {\n        checks.push(overflow[_basePlacement] <= 0);\n      }\n      if (checkAltAxis) {\n        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n      }\n      if (checks.every(function (check) {\n        return check;\n      })) {\n        firstFittingPlacement = placement;\n        makeFallbackChecks = false;\n        break;\n      }\n      checksMap.set(placement, checks);\n    }\n    if (makeFallbackChecks) {\n      // `2` may be desired in some cases – research later\n      var numberOfChecks = flipVariations ? 3 : 1;\n      var _loop = function _loop(_i) {\n        var fittingPlacement = placements.find(function (placement) {\n          var checks = checksMap.get(placement);\n          if (checks) {\n            return checks.slice(0, _i).every(function (check) {\n              return check;\n            });\n          }\n        });\n        if (fittingPlacement) {\n          firstFittingPlacement = fittingPlacement;\n          return \"break\";\n        }\n      };\n      for (var _i = numberOfChecks; _i > 0; _i--) {\n        var _ret = _loop(_i);\n        if (_ret === \"break\") break;\n      }\n    }\n    if (state.placement !== firstFittingPlacement) {\n      state.modifiersData[name]._skip = true;\n      state.placement = firstFittingPlacement;\n      state.reset = true;\n    }\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var flip$1 = {\n    name: 'flip',\n    enabled: true,\n    phase: 'main',\n    fn: flip,\n    requiresIfExists: ['offset'],\n    data: {\n      _skip: false\n    }\n  };\n  function getSideOffsets(overflow, rect, preventedOffsets) {\n    if (preventedOffsets === void 0) {\n      preventedOffsets = {\n        x: 0,\n        y: 0\n      };\n    }\n    return {\n      top: overflow.top - rect.height - preventedOffsets.y,\n      right: overflow.right - rect.width + preventedOffsets.x,\n      bottom: overflow.bottom - rect.height + preventedOffsets.y,\n      left: overflow.left - rect.width - preventedOffsets.x\n    };\n  }\n  function isAnySideFullyClipped(overflow) {\n    return [top, right, bottom, left].some(function (side) {\n      return overflow[side] >= 0;\n    });\n  }\n  function hide(_ref) {\n    var state = _ref.state,\n      name = _ref.name;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var preventedOffsets = state.modifiersData.preventOverflow;\n    var referenceOverflow = detectOverflow(state, {\n      elementContext: 'reference'\n    });\n    var popperAltOverflow = detectOverflow(state, {\n      altBoundary: true\n    });\n    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n    state.modifiersData[name] = {\n      referenceClippingOffsets: referenceClippingOffsets,\n      popperEscapeOffsets: popperEscapeOffsets,\n      isReferenceHidden: isReferenceHidden,\n      hasPopperEscaped: hasPopperEscaped\n    };\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-reference-hidden': isReferenceHidden,\n      'data-popper-escaped': hasPopperEscaped\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var hide$1 = {\n    name: 'hide',\n    enabled: true,\n    phase: 'main',\n    requiresIfExists: ['preventOverflow'],\n    fn: hide\n  };\n  function distanceAndSkiddingToXY(placement, rects, offset) {\n    var basePlacement = getBasePlacement(placement);\n    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n        placement: placement\n      })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n    skidding = skidding || 0;\n    distance = (distance || 0) * invertDistance;\n    return [left, right].indexOf(basePlacement) >= 0 ? {\n      x: distance,\n      y: skidding\n    } : {\n      x: skidding,\n      y: distance\n    };\n  }\n  function offset(_ref2) {\n    var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n    var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n    var data = placements.reduce(function (acc, placement) {\n      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n      return acc;\n    }, {});\n    var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n    if (state.modifiersData.popperOffsets != null) {\n      state.modifiersData.popperOffsets.x += x;\n      state.modifiersData.popperOffsets.y += y;\n    }\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var offset$1 = {\n    name: 'offset',\n    enabled: true,\n    phase: 'main',\n    requires: ['popperOffsets'],\n    fn: offset\n  };\n  function popperOffsets(_ref) {\n    var state = _ref.state,\n      name = _ref.name; // Offsets are the actual position the popper needs to have to be\n    // properly positioned near its reference element\n    // This is the most basic placement, and will be adjusted by\n    // the modifiers in the next step\n\n    state.modifiersData[name] = computeOffsets({\n      reference: state.rects.reference,\n      element: state.rects.popper,\n      strategy: 'absolute',\n      placement: state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var popperOffsets$1 = {\n    name: 'popperOffsets',\n    enabled: true,\n    phase: 'read',\n    fn: popperOffsets,\n    data: {}\n  };\n  function getAltAxis(axis) {\n    return axis === 'x' ? 'y' : 'x';\n  }\n  function preventOverflow(_ref) {\n    var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n    var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n    var overflow = detectOverflow(state, {\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      altBoundary: altBoundary\n    });\n    var basePlacement = getBasePlacement(state.placement);\n    var variation = getVariation(state.placement);\n    var isBasePlacement = !variation;\n    var mainAxis = getMainAxisFromPlacement(basePlacement);\n    var altAxis = getAltAxis(mainAxis);\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : tetherOffset;\n    var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n      mainAxis: tetherOffsetValue,\n      altAxis: tetherOffsetValue\n    } : Object.assign({\n      mainAxis: 0,\n      altAxis: 0\n    }, tetherOffsetValue);\n    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n    var data = {\n      x: 0,\n      y: 0\n    };\n    if (!popperOffsets) {\n      return;\n    }\n    if (checkMainAxis) {\n      var _offsetModifierState$;\n      var mainSide = mainAxis === 'y' ? top : left;\n      var altSide = mainAxis === 'y' ? bottom : right;\n      var len = mainAxis === 'y' ? 'height' : 'width';\n      var offset = popperOffsets[mainAxis];\n      var min$1 = offset + overflow[mainSide];\n      var max$1 = offset - overflow[altSide];\n      var additive = tether ? -popperRect[len] / 2 : 0;\n      var minLen = variation === start ? referenceRect[len] : popperRect[len];\n      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n      // outside the reference bounds\n\n      var arrowElement = state.elements.arrow;\n      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n        width: 0,\n        height: 0\n      };\n      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n      var arrowPaddingMin = arrowPaddingObject[mainSide];\n      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n      // to include its full size in the calculation. If the reference is small\n      // and near the edge of a boundary, the popper can overflow even if the\n      // reference is not overflowing as well (e.g. virtual elements with no\n      // width or height)\n\n      var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n      var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n      var tetherMax = offset + maxOffset - offsetModifierValue;\n      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\n      popperOffsets[mainAxis] = preventedOffset;\n      data[mainAxis] = preventedOffset - offset;\n    }\n    if (checkAltAxis) {\n      var _offsetModifierState$2;\n      var _mainSide = mainAxis === 'x' ? top : left;\n      var _altSide = mainAxis === 'x' ? bottom : right;\n      var _offset = popperOffsets[altAxis];\n      var _len = altAxis === 'y' ? 'height' : 'width';\n      var _min = _offset + overflow[_mainSide];\n      var _max = _offset - overflow[_altSide];\n      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n      popperOffsets[altAxis] = _preventedOffset;\n      data[altAxis] = _preventedOffset - _offset;\n    }\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var preventOverflow$1 = {\n    name: 'preventOverflow',\n    enabled: true,\n    phase: 'main',\n    fn: preventOverflow,\n    requiresIfExists: ['offset']\n  };\n  function getHTMLElementScroll(element) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  function getNodeScroll(node) {\n    if (node === getWindow(node) || !isHTMLElement(node)) {\n      return getWindowScroll(node);\n    } else {\n      return getHTMLElementScroll(node);\n    }\n  }\n  function isElementScaled(element) {\n    var rect = element.getBoundingClientRect();\n    var scaleX = round(rect.width) / element.offsetWidth || 1;\n    var scaleY = round(rect.height) / element.offsetHeight || 1;\n    return scaleX !== 1 || scaleY !== 1;\n  } // Returns the composite rect of an element relative to its offsetParent.\n  // Composite means it takes into account transforms as well as layout.\n\n  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n    if (isFixed === void 0) {\n      isFixed = false;\n    }\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n    var documentElement = getDocumentElement(offsetParent);\n    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);\n    var scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    var offsets = {\n      x: 0,\n      y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n      if (getNodeName(offsetParent) !== 'body' ||\n      // https://github.com/popperjs/popper-core/issues/1078\n      isScrollParent(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isHTMLElement(offsetParent)) {\n        offsets = getBoundingClientRect(offsetParent, true);\n        offsets.x += offsetParent.clientLeft;\n        offsets.y += offsetParent.clientTop;\n      } else if (documentElement) {\n        offsets.x = getWindowScrollBarX(documentElement);\n      }\n    }\n    return {\n      x: rect.left + scroll.scrollLeft - offsets.x,\n      y: rect.top + scroll.scrollTop - offsets.y,\n      width: rect.width,\n      height: rect.height\n    };\n  }\n  function order(modifiers) {\n    var map = new Map();\n    var visited = new Set();\n    var result = [];\n    modifiers.forEach(function (modifier) {\n      map.set(modifier.name, modifier);\n    }); // On visiting object, check for its dependencies and visit them recursively\n\n    function sort(modifier) {\n      visited.add(modifier.name);\n      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n      requires.forEach(function (dep) {\n        if (!visited.has(dep)) {\n          var depModifier = map.get(dep);\n          if (depModifier) {\n            sort(depModifier);\n          }\n        }\n      });\n      result.push(modifier);\n    }\n    modifiers.forEach(function (modifier) {\n      if (!visited.has(modifier.name)) {\n        // check for visited object\n        sort(modifier);\n      }\n    });\n    return result;\n  }\n  function orderModifiers(modifiers) {\n    // order based on dependencies\n    var orderedModifiers = order(modifiers); // order based on phase\n\n    return modifierPhases.reduce(function (acc, phase) {\n      return acc.concat(orderedModifiers.filter(function (modifier) {\n        return modifier.phase === phase;\n      }));\n    }, []);\n  }\n  function debounce(fn) {\n    var pending;\n    return function () {\n      if (!pending) {\n        pending = new Promise(function (resolve) {\n          Promise.resolve().then(function () {\n            pending = undefined;\n            resolve(fn());\n          });\n        });\n      }\n      return pending;\n    };\n  }\n  function mergeByName(modifiers) {\n    var merged = modifiers.reduce(function (merged, current) {\n      var existing = merged[current.name];\n      merged[current.name] = existing ? Object.assign({}, existing, current, {\n        options: Object.assign({}, existing.options, current.options),\n        data: Object.assign({}, existing.data, current.data)\n      }) : current;\n      return merged;\n    }, {}); // IE11 does not support Object.values\n\n    return Object.keys(merged).map(function (key) {\n      return merged[key];\n    });\n  }\n  var DEFAULT_OPTIONS = {\n    placement: 'bottom',\n    modifiers: [],\n    strategy: 'absolute'\n  };\n  function areValidElements() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return !args.some(function (element) {\n      return !(element && typeof element.getBoundingClientRect === 'function');\n    });\n  }\n  function popperGenerator(generatorOptions) {\n    if (generatorOptions === void 0) {\n      generatorOptions = {};\n    }\n    var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n    return function createPopper(reference, popper, options) {\n      if (options === void 0) {\n        options = defaultOptions;\n      }\n      var state = {\n        placement: 'bottom',\n        orderedModifiers: [],\n        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n        modifiersData: {},\n        elements: {\n          reference: reference,\n          popper: popper\n        },\n        attributes: {},\n        styles: {}\n      };\n      var effectCleanupFns = [];\n      var isDestroyed = false;\n      var instance = {\n        state: state,\n        setOptions: function setOptions(setOptionsAction) {\n          var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n          cleanupModifierEffects();\n          state.options = Object.assign({}, defaultOptions, state.options, options);\n          state.scrollParents = {\n            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n            popper: listScrollParents(popper)\n          }; // Orders the modifiers based on their dependencies and `phase`\n          // properties\n\n          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n          state.orderedModifiers = orderedModifiers.filter(function (m) {\n            return m.enabled;\n          }); // Validate the provided modifiers so that the consumer will get warned\n\n          runModifierEffects();\n          return instance.update();\n        },\n        // Sync update – it will always be executed, even if not necessary. This\n        // is useful for low frequency updates where sync behavior simplifies the\n        // logic.\n        // For high frequency updates (e.g. `resize` and `scroll` events), always\n        // prefer the async Popper#update method\n        forceUpdate: function forceUpdate() {\n          if (isDestroyed) {\n            return;\n          }\n          var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n          // anymore\n\n          if (!areValidElements(reference, popper)) {\n            return;\n          } // Store the reference and popper rects to be read by modifiers\n\n          state.rects = {\n            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n            popper: getLayoutRect(popper)\n          }; // Modifiers have the ability to reset the current update cycle. The\n          // most common use case for this is the `flip` modifier changing the\n          // placement, which then needs to re-run all the modifiers, because the\n          // logic was previously ran for the previous placement and is therefore\n          // stale/incorrect\n\n          state.reset = false;\n          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n          // is filled with the initial data specified by the modifier. This means\n          // it doesn't persist and is fresh on each update.\n          // To ensure persistent data, use `${name}#persistent`\n\n          state.orderedModifiers.forEach(function (modifier) {\n            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n          });\n          for (var index = 0; index < state.orderedModifiers.length; index++) {\n            if (state.reset === true) {\n              state.reset = false;\n              index = -1;\n              continue;\n            }\n            var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n            if (typeof fn === 'function') {\n              state = fn({\n                state: state,\n                options: _options,\n                name: name,\n                instance: instance\n              }) || state;\n            }\n          }\n        },\n        // Async and optimistically optimized update – it will not be executed if\n        // not necessary (debounced to run at most once-per-tick)\n        update: debounce(function () {\n          return new Promise(function (resolve) {\n            instance.forceUpdate();\n            resolve(state);\n          });\n        }),\n        destroy: function destroy() {\n          cleanupModifierEffects();\n          isDestroyed = true;\n        }\n      };\n      if (!areValidElements(reference, popper)) {\n        return instance;\n      }\n      instance.setOptions(options).then(function (state) {\n        if (!isDestroyed && options.onFirstUpdate) {\n          options.onFirstUpdate(state);\n        }\n      }); // Modifiers have the ability to execute arbitrary code before the first\n      // update cycle runs. They will be executed in the same order as the update\n      // cycle. This is useful when a modifier adds some persistent data that\n      // other modifiers need to use, but the modifier is run after the dependent\n      // one.\n\n      function runModifierEffects() {\n        state.orderedModifiers.forEach(function (_ref3) {\n          var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n          if (typeof effect === 'function') {\n            var cleanupFn = effect({\n              state: state,\n              name: name,\n              instance: instance,\n              options: options\n            });\n            var noopFn = function noopFn() {};\n            effectCleanupFns.push(cleanupFn || noopFn);\n          }\n        });\n      }\n      function cleanupModifierEffects() {\n        effectCleanupFns.forEach(function (fn) {\n          return fn();\n        });\n        effectCleanupFns = [];\n      }\n      return instance;\n    };\n  }\n  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\n  var createPopper = /*#__PURE__*/popperGenerator({\n    defaultModifiers: defaultModifiers\n  }); // eslint-disable-next-line import/no-unused-modules\n\n  function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n  function _getCenteredStylePopperModifier() {\n    return [{\n      name: 'applyStyles',\n      fn: function fn(_ref) {\n        var state = _ref.state;\n        Object.keys(state.elements).forEach(function (name) {\n          if (name !== 'popper') {\n            return;\n          }\n          var style = {\n            position: 'fixed',\n            left: '50%',\n            top: '50%',\n            transform: 'translate(-50%, -50%)'\n          };\n          var attributes = state.attributes[name] || {};\n          var element = state.elements[name];\n          Object.assign(element.style, style);\n          Object.keys(attributes).forEach(function (name) {\n            var value = attributes[name];\n            if (value === false) {\n              element.removeAttribute(name);\n            } else {\n              element.setAttribute(name, value === true ? '' : value);\n            }\n          });\n        });\n      }\n    }, {\n      name: 'computeStyles',\n      options: {\n        adaptive: false\n      }\n    }];\n  }\n  /**\n   * Generates a modifier for popper that will help focus the element after it has\n   * been rendered\n   *\n   * @param {Step} step The step instance\n   * @return {Object} The focus after render modifier configuration object\n   */\n\n  function generateFocusAfterRenderModifier(step) {\n    return {\n      name: 'focusAfterRender',\n      enabled: true,\n      phase: 'afterWrite',\n      fn: function fn() {\n        setTimeout(function () {\n          if (step.el) {\n            var focusOptions = {\n              preventScroll: true\n            };\n            step.el.focus(focusOptions);\n          }\n        }, 300);\n      }\n    };\n  }\n  /**\n   * Generates the array of options for a tooltip that doesn't have a\n   * target element in the DOM -- and thus is positioned in the center\n   * of the view\n   *\n   * @param {Step} step The step instance\n   * @return {Object} The final Popper options object\n   */\n\n  function makeCenteredPopper(step) {\n    var centeredStylePopperModifier = _getCenteredStylePopperModifier();\n    var popperOptions = {\n      placement: 'top',\n      strategy: 'fixed',\n      modifiers: [generateFocusAfterRenderModifier(step)]\n    };\n    popperOptions = _extends({}, popperOptions, {\n      modifiers: Array.from(new Set([].concat(_toConsumableArray(popperOptions.modifiers), _toConsumableArray(centeredStylePopperModifier))))\n    });\n    return popperOptions;\n  }\n\n  /**\n   * Ensure class prefix ends in `-`\n   * @param {string} prefix The prefix to prepend to the class names generated by nano-css\n   * @return {string} The prefix ending in `-`\n   */\n\n  function normalizePrefix(prefix) {\n    if (!isString(prefix) || prefix === '') {\n      return '';\n    }\n    return prefix.charAt(prefix.length - 1) !== '-' ? \"\".concat(prefix, \"-\") : prefix;\n  }\n  /**\n   * Resolves attachTo options, converting element option value to a qualified HTMLElement.\n   * @param {Step} step The step instance\n   * @returns {{}|{element, on}}\n   * `element` is a qualified HTML Element\n   * `on` is a string position value\n   */\n\n  function parseAttachTo(step) {\n    var options = step.options.attachTo || {};\n    var returnOpts = Object.assign({}, options);\n    if (isFunction(returnOpts.element)) {\n      // Bind the callback to step so that it has access to the object, to enable running additional logic\n      returnOpts.element = returnOpts.element.call(step);\n    }\n    if (isString(returnOpts.element)) {\n      // Can't override the element in user opts reference because we can't\n      // guarantee that the element will exist in the future.\n      try {\n        returnOpts.element = document.querySelector(returnOpts.element);\n      } catch (e) {// TODO\n      }\n      if (!returnOpts.element) {\n        console.error(\"The element for this Shepherd step was not found \".concat(options.element));\n      }\n    }\n    return returnOpts;\n  }\n  /**\n   * Checks if the step should be centered or not. Does not trigger attachTo.element evaluation, making it a pure\n   * alternative for the deprecated step.isCentered() method.\n   * @param resolvedAttachToOptions\n   * @returns {boolean}\n   */\n\n  function shouldCenterStep(resolvedAttachToOptions) {\n    if (resolvedAttachToOptions === undefined || resolvedAttachToOptions === null) {\n      return true;\n    }\n    return !resolvedAttachToOptions.element || !resolvedAttachToOptions.on;\n  }\n  /**\n   * Determines options for the tooltip and initializes\n   * `step.tooltip` as a Popper instance.\n   * @param {Step} step The step instance\n   */\n\n  function setupTooltip(step) {\n    if (step.tooltip) {\n      step.tooltip.destroy();\n    }\n    var attachToOptions = step._getResolvedAttachToOptions();\n    var target = attachToOptions.element;\n    var popperOptions = getPopperOptions(attachToOptions, step);\n    if (shouldCenterStep(attachToOptions)) {\n      target = document.body;\n      var content = step.shepherdElementComponent.getElement();\n      content.classList.add('shepherd-centered');\n    }\n    step.tooltip = createPopper(target, step.el, popperOptions);\n    step.target = attachToOptions.element;\n    return popperOptions;\n  }\n  /**\n   * Create a unique id for steps, tours, modals, etc\n   * @return {string}\n   */\n\n  function uuid() {\n    var d = Date.now();\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = (d + Math.random() * 16) % 16 | 0;\n      d = Math.floor(d / 16);\n      return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n  }\n  /**\n   * Gets the `Popper` options from a set of base `attachTo` options\n   * @param attachToOptions\n   * @param {Step} step The step instance\n   * @return {Object}\n   * @private\n   */\n\n  function getPopperOptions(attachToOptions, step) {\n    var popperOptions = {\n      modifiers: [{\n        name: 'preventOverflow',\n        options: {\n          altAxis: true,\n          tether: false\n        }\n      }, generateFocusAfterRenderModifier(step)],\n      strategy: 'absolute'\n    };\n    if (shouldCenterStep(attachToOptions)) {\n      popperOptions = makeCenteredPopper(step);\n    } else {\n      popperOptions.placement = attachToOptions.on;\n    }\n    var defaultStepOptions = step.tour && step.tour.options && step.tour.options.defaultStepOptions;\n    if (defaultStepOptions) {\n      popperOptions = _mergeModifiers(defaultStepOptions, popperOptions);\n    }\n    popperOptions = _mergeModifiers(step.options, popperOptions);\n    return popperOptions;\n  }\n  function _mergeModifiers(stepOptions, popperOptions) {\n    if (stepOptions.popperOptions) {\n      var mergedPopperOptions = Object.assign({}, popperOptions, stepOptions.popperOptions);\n      if (stepOptions.popperOptions.modifiers && stepOptions.popperOptions.modifiers.length > 0) {\n        var names = stepOptions.popperOptions.modifiers.map(function (mod) {\n          return mod.name;\n        });\n        var filteredModifiers = popperOptions.modifiers.filter(function (mod) {\n          return !names.includes(mod.name);\n        });\n        mergedPopperOptions.modifiers = Array.from(new Set([].concat(_toConsumableArray(filteredModifiers), _toConsumableArray(stepOptions.popperOptions.modifiers))));\n      }\n      return mergedPopperOptions;\n    }\n    return popperOptions;\n  }\n  function noop() {}\n  function assign(tar, src) {\n    // @ts-ignore\n    for (var k in src) tar[k] = src[k];\n    return tar;\n  }\n  function run(fn) {\n    return fn();\n  }\n  function blank_object() {\n    return Object.create(null);\n  }\n  function run_all(fns) {\n    fns.forEach(run);\n  }\n  function is_function(thing) {\n    return typeof thing === 'function';\n  }\n  function safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || a && _typeof(a) === 'object' || typeof a === 'function';\n  }\n  function is_empty(obj) {\n    return Object.keys(obj).length === 0;\n  }\n  function append(target, node) {\n    target.appendChild(node);\n  }\n  function insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n  }\n  function detach(node) {\n    node.parentNode.removeChild(node);\n  }\n  function destroy_each(iterations, detaching) {\n    for (var i = 0; i < iterations.length; i += 1) {\n      if (iterations[i]) iterations[i].d(detaching);\n    }\n  }\n  function element(name) {\n    return document.createElement(name);\n  }\n  function svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  }\n  function text(data) {\n    return document.createTextNode(data);\n  }\n  function space() {\n    return text(' ');\n  }\n  function empty() {\n    return text('');\n  }\n  function listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return function () {\n      return node.removeEventListener(event, handler, options);\n    };\n  }\n  function attr(node, attribute, value) {\n    if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n  }\n  function set_attributes(node, attributes) {\n    // @ts-ignore\n    var descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (var key in attributes) {\n      if (attributes[key] == null) {\n        node.removeAttribute(key);\n      } else if (key === 'style') {\n        node.style.cssText = attributes[key];\n      } else if (key === '__value') {\n        node.value = node[key] = attributes[key];\n      } else if (descriptors[key] && descriptors[key].set) {\n        node[key] = attributes[key];\n      } else {\n        attr(node, key, attributes[key]);\n      }\n    }\n  }\n  function children(element) {\n    return Array.from(element.childNodes);\n  }\n  function toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n  }\n  var current_component;\n  function set_current_component(component) {\n    current_component = component;\n  }\n  function get_current_component() {\n    if (!current_component) throw new Error('Function called outside component initialization');\n    return current_component;\n  }\n  function onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n  }\n  function afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n  }\n  var dirty_components = [];\n  var binding_callbacks = [];\n  var render_callbacks = [];\n  var flush_callbacks = [];\n  var resolved_promise = Promise.resolve();\n  var update_scheduled = false;\n  function schedule_update() {\n    if (!update_scheduled) {\n      update_scheduled = true;\n      resolved_promise.then(flush);\n    }\n  }\n  function add_render_callback(fn) {\n    render_callbacks.push(fn);\n  }\n  // 1. All beforeUpdate callbacks, in order: parents before children\n  // 2. All bind:this callbacks, in reverse order: children before parents.\n  // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n  //    for afterUpdates called during the initial onMount, which are called in\n  //    reverse order: children before parents.\n  // Since callbacks might update component values, which could trigger another\n  // call to flush(), the following steps guard against this:\n  // 1. During beforeUpdate, any updated components will be added to the\n  //    dirty_components array and will cause a reentrant call to flush(). Because\n  //    the flush index is kept outside the function, the reentrant call will pick\n  //    up where the earlier call left off and go through all dirty components. The\n  //    current_component value is saved and restored so that the reentrant call will\n  //    not interfere with the \"parent\" flush() call.\n  // 2. bind:this callbacks cannot trigger new flush() calls.\n  // 3. During afterUpdate, any updated components will NOT have their afterUpdate\n  //    callback called a second time; the seen_callbacks set, outside the flush()\n  //    function, guarantees this behavior.\n\n  var seen_callbacks = new Set();\n  var flushidx = 0; // Do *not* move this inside the flush() function\n\n  function flush() {\n    var saved_component = current_component;\n    do {\n      // first, call beforeUpdate functions\n      // and update components\n      while (flushidx < dirty_components.length) {\n        var component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n      set_current_component(null);\n      dirty_components.length = 0;\n      flushidx = 0;\n      while (binding_callbacks.length) binding_callbacks.pop()(); // then, once components are updated, call\n      // afterUpdate functions. This may cause\n      // subsequent updates...\n\n      for (var i = 0; i < render_callbacks.length; i += 1) {\n        var callback = render_callbacks[i];\n        if (!seen_callbacks.has(callback)) {\n          // ...so guard against infinite loops\n          seen_callbacks.add(callback);\n          callback();\n        }\n      }\n      render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n      flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n  }\n  function update($$) {\n    if ($$.fragment !== null) {\n      $$.update();\n      run_all($$.before_update);\n      var dirty = $$.dirty;\n      $$.dirty = [-1];\n      $$.fragment && $$.fragment.p($$.ctx, dirty);\n      $$.after_update.forEach(add_render_callback);\n    }\n  }\n  var outroing = new Set();\n  var outros;\n  function group_outros() {\n    outros = {\n      r: 0,\n      c: [],\n      p: outros // parent group\n    };\n  }\n\n  function check_outros() {\n    if (!outros.r) {\n      run_all(outros.c);\n    }\n    outros = outros.p;\n  }\n  function transition_in(block, local) {\n    if (block && block.i) {\n      outroing.delete(block);\n      block.i(local);\n    }\n  }\n  function transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n      if (outroing.has(block)) return;\n      outroing.add(block);\n      outros.c.push(function () {\n        outroing.delete(block);\n        if (callback) {\n          if (detach) block.d(1);\n          callback();\n        }\n      });\n      block.o(local);\n    } else if (callback) {\n      callback();\n    }\n  }\n  function get_spread_update(levels, updates) {\n    var update = {};\n    var to_null_out = {};\n    var accounted_for = {\n      $$scope: 1\n    };\n    var i = levels.length;\n    while (i--) {\n      var o = levels[i];\n      var n = updates[i];\n      if (n) {\n        for (var key in o) {\n          if (!(key in n)) to_null_out[key] = 1;\n        }\n        for (var _key2 in n) {\n          if (!accounted_for[_key2]) {\n            update[_key2] = n[_key2];\n            accounted_for[_key2] = 1;\n          }\n        }\n        levels[i] = n;\n      } else {\n        for (var _key3 in o) {\n          accounted_for[_key3] = 1;\n        }\n      }\n    }\n    for (var _key4 in to_null_out) {\n      if (!(_key4 in update)) update[_key4] = undefined;\n    }\n    return update;\n  }\n  function create_component(block) {\n    block && block.c();\n  }\n  function mount_component(component, target, anchor, customElement) {\n    var _component$$$ = component.$$,\n      fragment = _component$$$.fragment,\n      on_mount = _component$$$.on_mount,\n      on_destroy = _component$$$.on_destroy,\n      after_update = _component$$$.after_update;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n      // onMount happens before the initial afterUpdate\n      add_render_callback(function () {\n        var new_on_destroy = on_mount.map(run).filter(is_function);\n        if (on_destroy) {\n          on_destroy.push.apply(on_destroy, _toConsumableArray(new_on_destroy));\n        } else {\n          // Edge case - component was destroyed immediately,\n          // most likely as a result of a binding initialising\n          run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n      });\n    }\n    after_update.forEach(add_render_callback);\n  }\n  function destroy_component(component, detaching) {\n    var $$ = component.$$;\n    if ($$.fragment !== null) {\n      run_all($$.on_destroy);\n      $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to\n      // preserve final state?)\n\n      $$.on_destroy = $$.fragment = null;\n      $$.ctx = [];\n    }\n  }\n  function make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n      dirty_components.push(component);\n      schedule_update();\n      component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n  }\n  function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty) {\n    if (dirty === void 0) {\n      dirty = [-1];\n    }\n    var parent_component = current_component;\n    set_current_component(component);\n    var $$ = component.$$ = {\n      fragment: null,\n      ctx: null,\n      // state\n      props: props,\n      update: noop,\n      not_equal: not_equal,\n      bound: blank_object(),\n      // lifecycle\n      on_mount: [],\n      on_destroy: [],\n      on_disconnect: [],\n      before_update: [],\n      after_update: [],\n      context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n      // everything else\n      callbacks: blank_object(),\n      dirty: dirty,\n      skip_bound: false,\n      root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    var ready = false;\n    $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {\n      var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;\n      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n        if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n        if (ready) make_dirty(component, i);\n      }\n      return ret;\n    }) : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update); // `false` as a special case of no DOM component\n\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n      if (options.hydrate) {\n        var nodes = children(options.target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        $$.fragment && $$.fragment.l(nodes);\n        nodes.forEach(detach);\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        $$.fragment && $$.fragment.c();\n      }\n      if (options.intro) transition_in(component.$$.fragment);\n      mount_component(component, options.target, options.anchor, options.customElement);\n      flush();\n    }\n    set_current_component(parent_component);\n  }\n  /**\n   * Base class for Svelte components. Used when dev=false.\n   */\n  var SvelteComponent = /*#__PURE__*/function () {\n    function SvelteComponent() {\n      _classCallCheck(this, SvelteComponent);\n    }\n    _createClass(SvelteComponent, [{\n      key: \"$destroy\",\n      value: function $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n      }\n    }, {\n      key: \"$on\",\n      value: function $on(type, callback) {\n        var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n        callbacks.push(callback);\n        return function () {\n          var index = callbacks.indexOf(callback);\n          if (index !== -1) callbacks.splice(index, 1);\n        };\n      }\n    }, {\n      key: \"$set\",\n      value: function $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n          this.$$.skip_bound = true;\n          this.$$set($$props);\n          this.$$.skip_bound = false;\n        }\n      }\n    }]);\n    return SvelteComponent;\n  }();\n  /* src/js/components/shepherd-button.svelte generated by Svelte v3.49.0 */\n  function create_fragment$8(ctx) {\n    var button;\n    var button_aria_label_value;\n    var button_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        attr(button, \"aria-label\", button_aria_label_value = /*label*/\n        ctx[3] ? /*label*/\n        ctx[3] : null);\n        attr(button, \"class\", button_class_value = \"\".concat( /*classes*/\n        ctx[1] || '', \" shepherd-button \").concat( /*secondary*/\n        ctx[4] ? 'shepherd-button-secondary' : ''));\n        button.disabled = /*disabled*/\n        ctx[2];\n        attr(button, \"tabindex\", \"0\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        button.innerHTML = /*text*/\n        ctx[5];\n        if (!mounted) {\n          dispose = listen(button, \"click\", function () {\n            if (is_function( /*action*/\n            ctx[0])) /*action*/\n              ctx[0].apply(this, arguments);\n          });\n          mounted = true;\n        }\n      },\n      p: function p(new_ctx, _ref) {\n        var _ref7 = _slicedToArray(_ref, 1),\n          dirty = _ref7[0];\n        ctx = new_ctx;\n        if (dirty & /*text*/\n        32) button.innerHTML = /*text*/\n        ctx[5];\n        if (dirty & /*label*/\n        8 && button_aria_label_value !== (button_aria_label_value = /*label*/\n        ctx[3] ? /*label*/\n        ctx[3] : null)) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n        if (dirty & /*classes, secondary*/\n        18 && button_class_value !== (button_class_value = \"\".concat( /*classes*/\n        ctx[1] || '', \" shepherd-button \").concat( /*secondary*/\n        ctx[4] ? 'shepherd-button-secondary' : ''))) {\n          attr(button, \"class\", button_class_value);\n        }\n        if (dirty & /*disabled*/\n        4) {\n          button.disabled = /*disabled*/\n          ctx[2];\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function instance$8($$self, $$props, $$invalidate) {\n    var config = $$props.config,\n      step = $$props.step;\n    var action, classes, disabled, label, secondary, text;\n    function getConfigOption(option) {\n      if (isFunction(option)) {\n        return option = option.call(step);\n      }\n      return option;\n    }\n    $$self.$$set = function ($$props) {\n      if ('config' in $$props) $$invalidate(6, config = $$props.config);\n      if ('step' in $$props) $$invalidate(7, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*config, step*/\n      192) {\n        {\n          $$invalidate(0, action = config.action ? config.action.bind(step.tour) : null);\n          $$invalidate(1, classes = config.classes);\n          $$invalidate(2, disabled = config.disabled ? getConfigOption(config.disabled) : false);\n          $$invalidate(3, label = config.label ? getConfigOption(config.label) : null);\n          $$invalidate(4, secondary = config.secondary);\n          $$invalidate(5, text = config.text ? getConfigOption(config.text) : null);\n        }\n      }\n    };\n    return [action, classes, disabled, label, secondary, text, config, step];\n  }\n  var Shepherd_button = /*#__PURE__*/function (_SvelteComponent) {\n    _inherits(Shepherd_button, _SvelteComponent);\n    var _super = _createSuper(Shepherd_button);\n    function Shepherd_button(options) {\n      var _this3;\n      _classCallCheck(this, Shepherd_button);\n      _this3 = _super.call(this);\n      init(_assertThisInitialized(_this3), options, instance$8, create_fragment$8, safe_not_equal, {\n        config: 6,\n        step: 7\n      });\n      return _this3;\n    }\n    return _createClass(Shepherd_button);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-footer.svelte generated by Svelte v3.49.0 */\n  function get_each_context(ctx, list, i) {\n    var child_ctx = ctx.slice();\n    child_ctx[2] = list[i];\n    return child_ctx;\n  } // (24:4) {#if buttons}\n\n  function create_if_block$3(ctx) {\n    var each_1_anchor;\n    var current;\n    var each_value = /*buttons*/\n    ctx[1];\n    var each_blocks = [];\n    for (var i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n    }\n    var out = function out(i) {\n      return transition_out(each_blocks[i], 1, 1, function () {\n        each_blocks[i] = null;\n      });\n    };\n    return {\n      c: function c() {\n        for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {\n          each_blocks[_i2].c();\n        }\n        each_1_anchor = empty();\n      },\n      m: function m(target, anchor) {\n        for (var _i3 = 0; _i3 < each_blocks.length; _i3 += 1) {\n          each_blocks[_i3].m(target, anchor);\n        }\n        insert(target, each_1_anchor, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        if (dirty & /*buttons, step*/\n        3) {\n          each_value = /*buttons*/\n          ctx[1];\n          var _i4;\n          for (_i4 = 0; _i4 < each_value.length; _i4 += 1) {\n            var child_ctx = get_each_context(ctx, each_value, _i4);\n            if (each_blocks[_i4]) {\n              each_blocks[_i4].p(child_ctx, dirty);\n              transition_in(each_blocks[_i4], 1);\n            } else {\n              each_blocks[_i4] = create_each_block(child_ctx);\n              each_blocks[_i4].c();\n              transition_in(each_blocks[_i4], 1);\n              each_blocks[_i4].m(each_1_anchor.parentNode, each_1_anchor);\n            }\n          }\n          group_outros();\n          for (_i4 = each_value.length; _i4 < each_blocks.length; _i4 += 1) {\n            out(_i4);\n          }\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        for (var _i5 = 0; _i5 < each_value.length; _i5 += 1) {\n          transition_in(each_blocks[_i5]);\n        }\n        current = true;\n      },\n      o: function o(local) {\n        each_blocks = each_blocks.filter(Boolean);\n        for (var _i6 = 0; _i6 < each_blocks.length; _i6 += 1) {\n          transition_out(each_blocks[_i6]);\n        }\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_each(each_blocks, detaching);\n        if (detaching) detach(each_1_anchor);\n      }\n    };\n  } // (25:8) {#each buttons as config}\n\n  function create_each_block(ctx) {\n    var shepherdbutton;\n    var current;\n    shepherdbutton = new Shepherd_button({\n      props: {\n        config: /*config*/\n        ctx[2],\n        step: /*step*/\n        ctx[0]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdbutton.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdbutton, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdbutton_changes = {};\n        if (dirty & /*buttons*/\n        2) shepherdbutton_changes.config = /*config*/\n        ctx[2];\n        if (dirty & /*step*/\n        1) shepherdbutton_changes.step = /*step*/\n        ctx[0];\n        shepherdbutton.$set(shepherdbutton_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdbutton.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdbutton.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdbutton, detaching);\n      }\n    };\n  }\n  function create_fragment$7(ctx) {\n    var footer;\n    var current;\n    var if_block = /*buttons*/\n    ctx[1] && create_if_block$3(ctx);\n    return {\n      c: function c() {\n        footer = element(\"footer\");\n        if (if_block) if_block.c();\n        attr(footer, \"class\", \"shepherd-footer\");\n      },\n      m: function m(target, anchor) {\n        insert(target, footer, anchor);\n        if (if_block) if_block.m(footer, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref8 = _slicedToArray(_ref, 1),\n          dirty = _ref8[0];\n        if ( /*buttons*/\n        ctx[1]) {\n          if (if_block) {\n            if_block.p(ctx, dirty);\n            if (dirty & /*buttons*/\n            2) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block$3(ctx);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(footer, null);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, function () {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(footer);\n        if (if_block) if_block.d();\n      }\n    };\n  }\n  function instance$7($$self, $$props, $$invalidate) {\n    var buttons;\n    var step = $$props.step;\n    $$self.$$set = function ($$props) {\n      if ('step' in $$props) $$invalidate(0, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/\n      1) {\n        $$invalidate(1, buttons = step.options.buttons);\n      }\n    };\n    return [step, buttons];\n  }\n  var Shepherd_footer = /*#__PURE__*/function (_SvelteComponent2) {\n    _inherits(Shepherd_footer, _SvelteComponent2);\n    var _super2 = _createSuper(Shepherd_footer);\n    function Shepherd_footer(options) {\n      var _this4;\n      _classCallCheck(this, Shepherd_footer);\n      _this4 = _super2.call(this);\n      init(_assertThisInitialized(_this4), options, instance$7, create_fragment$7, safe_not_equal, {\n        step: 0\n      });\n      return _this4;\n    }\n    return _createClass(Shepherd_footer);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-cancel-icon.svelte generated by Svelte v3.49.0 */\n  function create_fragment$6(ctx) {\n    var button;\n    var span;\n    var button_aria_label_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        span = element(\"span\");\n        span.textContent = \"×\";\n        attr(span, \"aria-hidden\", \"true\");\n        attr(button, \"aria-label\", button_aria_label_value = /*cancelIcon*/\n        ctx[0].label ? /*cancelIcon*/\n        ctx[0].label : 'Close Tour');\n        attr(button, \"class\", \"shepherd-cancel-icon\");\n        attr(button, \"type\", \"button\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        append(button, span);\n        if (!mounted) {\n          dispose = listen(button, \"click\", /*handleCancelClick*/\n          ctx[1]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref9 = _slicedToArray(_ref, 1),\n          dirty = _ref9[0];\n        if (dirty & /*cancelIcon*/\n        1 && button_aria_label_value !== (button_aria_label_value = /*cancelIcon*/\n        ctx[0].label ? /*cancelIcon*/\n        ctx[0].label : 'Close Tour')) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function instance$6($$self, $$props, $$invalidate) {\n    var cancelIcon = $$props.cancelIcon,\n      step = $$props.step;\n    /**\n    * Add a click listener to the cancel link that cancels the tour\n    */\n\n    var handleCancelClick = function handleCancelClick(e) {\n      e.preventDefault();\n      step.cancel();\n    };\n    $$self.$$set = function ($$props) {\n      if ('cancelIcon' in $$props) $$invalidate(0, cancelIcon = $$props.cancelIcon);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [cancelIcon, handleCancelClick, step];\n  }\n  var Shepherd_cancel_icon = /*#__PURE__*/function (_SvelteComponent3) {\n    _inherits(Shepherd_cancel_icon, _SvelteComponent3);\n    var _super3 = _createSuper(Shepherd_cancel_icon);\n    function Shepherd_cancel_icon(options) {\n      var _this5;\n      _classCallCheck(this, Shepherd_cancel_icon);\n      _this5 = _super3.call(this);\n      init(_assertThisInitialized(_this5), options, instance$6, create_fragment$6, safe_not_equal, {\n        cancelIcon: 0,\n        step: 2\n      });\n      return _this5;\n    }\n    return _createClass(Shepherd_cancel_icon);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-title.svelte generated by Svelte v3.49.0 */\n  function create_fragment$5(ctx) {\n    var h3;\n    return {\n      c: function c() {\n        h3 = element(\"h3\");\n        attr(h3, \"id\", /*labelId*/\n        ctx[1]);\n        attr(h3, \"class\", \"shepherd-title\");\n      },\n      m: function m(target, anchor) {\n        insert(target, h3, anchor);\n        /*h3_binding*/\n\n        ctx[3](h3);\n      },\n      p: function p(ctx, _ref) {\n        var _ref10 = _slicedToArray(_ref, 1),\n          dirty = _ref10[0];\n        if (dirty & /*labelId*/\n        2) {\n          attr(h3, \"id\", /*labelId*/\n          ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(h3);\n        /*h3_binding*/\n\n        ctx[3](null);\n      }\n    };\n  }\n  function instance$5($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n      element = $$props.element,\n      title = $$props.title;\n    afterUpdate(function () {\n      if (isFunction(title)) {\n        $$invalidate(2, title = title());\n      }\n      $$invalidate(0, element.innerHTML = title, element);\n    });\n    function h3_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('labelId' in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('title' in $$props) $$invalidate(2, title = $$props.title);\n    };\n    return [element, labelId, title, h3_binding];\n  }\n  var Shepherd_title = /*#__PURE__*/function (_SvelteComponent4) {\n    _inherits(Shepherd_title, _SvelteComponent4);\n    var _super4 = _createSuper(Shepherd_title);\n    function Shepherd_title(options) {\n      var _this6;\n      _classCallCheck(this, Shepherd_title);\n      _this6 = _super4.call(this);\n      init(_assertThisInitialized(_this6), options, instance$5, create_fragment$5, safe_not_equal, {\n        labelId: 1,\n        element: 0,\n        title: 2\n      });\n      return _this6;\n    }\n    return _createClass(Shepherd_title);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-header.svelte generated by Svelte v3.49.0 */\n  function create_if_block_1$1(ctx) {\n    var shepherdtitle;\n    var current;\n    shepherdtitle = new Shepherd_title({\n      props: {\n        labelId: /*labelId*/\n        ctx[0],\n        title: /*title*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtitle.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtitle, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtitle_changes = {};\n        if (dirty & /*labelId*/\n        1) shepherdtitle_changes.labelId = /*labelId*/\n        ctx[0];\n        if (dirty & /*title*/\n        4) shepherdtitle_changes.title = /*title*/\n        ctx[2];\n        shepherdtitle.$set(shepherdtitle_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtitle.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtitle.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtitle, detaching);\n      }\n    };\n  } // (39:4) {#if cancelIcon && cancelIcon.enabled}\n\n  function create_if_block$2(ctx) {\n    var shepherdcancelicon;\n    var current;\n    shepherdcancelicon = new Shepherd_cancel_icon({\n      props: {\n        cancelIcon: /*cancelIcon*/\n        ctx[3],\n        step: /*step*/\n        ctx[1]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdcancelicon.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdcancelicon, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdcancelicon_changes = {};\n        if (dirty & /*cancelIcon*/\n        8) shepherdcancelicon_changes.cancelIcon = /*cancelIcon*/\n        ctx[3];\n        if (dirty & /*step*/\n        2) shepherdcancelicon_changes.step = /*step*/\n        ctx[1];\n        shepherdcancelicon.$set(shepherdcancelicon_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcancelicon.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcancelicon.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdcancelicon, detaching);\n      }\n    };\n  }\n  function create_fragment$4(ctx) {\n    var header;\n    var t;\n    var current;\n    var if_block0 = /*title*/\n    ctx[2] && create_if_block_1$1(ctx);\n    var if_block1 = /*cancelIcon*/\n    ctx[3] && /*cancelIcon*/\n    ctx[3].enabled && create_if_block$2(ctx);\n    return {\n      c: function c() {\n        header = element(\"header\");\n        if (if_block0) if_block0.c();\n        t = space();\n        if (if_block1) if_block1.c();\n        attr(header, \"class\", \"shepherd-header\");\n      },\n      m: function m(target, anchor) {\n        insert(target, header, anchor);\n        if (if_block0) if_block0.m(header, null);\n        append(header, t);\n        if (if_block1) if_block1.m(header, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref11 = _slicedToArray(_ref, 1),\n          dirty = _ref11[0];\n        if ( /*title*/\n        ctx[2]) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n            if (dirty & /*title*/\n            4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_1$1(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(header, t);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n        if ( /*cancelIcon*/\n        ctx[3] && /*cancelIcon*/\n        ctx[3].enabled) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n            if (dirty & /*cancelIcon*/\n            8) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block$2(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(header, null);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(header);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n      }\n    };\n  }\n  function instance$4($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n      step = $$props.step;\n    var title, cancelIcon;\n    $$self.$$set = function ($$props) {\n      if ('labelId' in $$props) $$invalidate(0, labelId = $$props.labelId);\n      if ('step' in $$props) $$invalidate(1, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/\n      2) {\n        {\n          $$invalidate(2, title = step.options.title);\n          $$invalidate(3, cancelIcon = step.options.cancelIcon);\n        }\n      }\n    };\n    return [labelId, step, title, cancelIcon];\n  }\n  var Shepherd_header = /*#__PURE__*/function (_SvelteComponent5) {\n    _inherits(Shepherd_header, _SvelteComponent5);\n    var _super5 = _createSuper(Shepherd_header);\n    function Shepherd_header(options) {\n      var _this7;\n      _classCallCheck(this, Shepherd_header);\n      _this7 = _super5.call(this);\n      init(_assertThisInitialized(_this7), options, instance$4, create_fragment$4, safe_not_equal, {\n        labelId: 0,\n        step: 1\n      });\n      return _this7;\n    }\n    return _createClass(Shepherd_header);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-text.svelte generated by Svelte v3.49.0 */\n  function create_fragment$3(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-text\");\n        attr(div, \"id\", /*descriptionId*/\n        ctx[1]);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        /*div_binding*/\n\n        ctx[3](div);\n      },\n      p: function p(ctx, _ref) {\n        var _ref12 = _slicedToArray(_ref, 1),\n          dirty = _ref12[0];\n        if (dirty & /*descriptionId*/\n        2) {\n          attr(div, \"id\", /*descriptionId*/\n          ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        /*div_binding*/\n\n        ctx[3](null);\n      }\n    };\n  }\n  function instance$3($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n      element = $$props.element,\n      step = $$props.step;\n    afterUpdate(function () {\n      var text = step.options.text;\n      if (isFunction(text)) {\n        text = text.call(step);\n      }\n      if (isHTMLElement$1(text)) {\n        element.appendChild(text);\n      } else {\n        $$invalidate(0, element.innerHTML = text, element);\n      }\n    });\n    function div_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('descriptionId' in $$props) $$invalidate(1, descriptionId = $$props.descriptionId);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [element, descriptionId, step, div_binding];\n  }\n  var Shepherd_text = /*#__PURE__*/function (_SvelteComponent6) {\n    _inherits(Shepherd_text, _SvelteComponent6);\n    var _super6 = _createSuper(Shepherd_text);\n    function Shepherd_text(options) {\n      var _this8;\n      _classCallCheck(this, Shepherd_text);\n      _this8 = _super6.call(this);\n      init(_assertThisInitialized(_this8), options, instance$3, create_fragment$3, safe_not_equal, {\n        descriptionId: 1,\n        element: 0,\n        step: 2\n      });\n      return _this8;\n    }\n    return _createClass(Shepherd_text);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-content.svelte generated by Svelte v3.49.0 */\n  function create_if_block_2(ctx) {\n    var shepherdheader;\n    var current;\n    shepherdheader = new Shepherd_header({\n      props: {\n        labelId: /*labelId*/\n        ctx[1],\n        step: /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdheader.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdheader, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdheader_changes = {};\n        if (dirty & /*labelId*/\n        2) shepherdheader_changes.labelId = /*labelId*/\n        ctx[1];\n        if (dirty & /*step*/\n        4) shepherdheader_changes.step = /*step*/\n        ctx[2];\n        shepherdheader.$set(shepherdheader_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdheader.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdheader.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdheader, detaching);\n      }\n    };\n  } // (28:2) {#if !isUndefined(step.options.text)}\n\n  function create_if_block_1(ctx) {\n    var shepherdtext;\n    var current;\n    shepherdtext = new Shepherd_text({\n      props: {\n        descriptionId: /*descriptionId*/\n        ctx[0],\n        step: /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtext.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtext, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtext_changes = {};\n        if (dirty & /*descriptionId*/\n        1) shepherdtext_changes.descriptionId = /*descriptionId*/\n        ctx[0];\n        if (dirty & /*step*/\n        4) shepherdtext_changes.step = /*step*/\n        ctx[2];\n        shepherdtext.$set(shepherdtext_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtext.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtext.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtext, detaching);\n      }\n    };\n  } // (35:2) {#if Array.isArray(step.options.buttons) && step.options.buttons.length}\n\n  function create_if_block$1(ctx) {\n    var shepherdfooter;\n    var current;\n    shepherdfooter = new Shepherd_footer({\n      props: {\n        step: /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdfooter.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdfooter, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdfooter_changes = {};\n        if (dirty & /*step*/\n        4) shepherdfooter_changes.step = /*step*/\n        ctx[2];\n        shepherdfooter.$set(shepherdfooter_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdfooter.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdfooter.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdfooter, detaching);\n      }\n    };\n  }\n  function create_fragment$2(ctx) {\n    var div;\n    var show_if_2 = !isUndefined( /*step*/\n    ctx[2].options.title) || /*step*/\n    ctx[2].options.cancelIcon && /*step*/\n    ctx[2].options.cancelIcon.enabled;\n    var t0;\n    var show_if_1 = !isUndefined( /*step*/\n    ctx[2].options.text);\n    var t1;\n    var show_if = Array.isArray( /*step*/\n    ctx[2].options.buttons) && /*step*/\n    ctx[2].options.buttons.length;\n    var current;\n    var if_block0 = show_if_2 && create_if_block_2(ctx);\n    var if_block1 = show_if_1 && create_if_block_1(ctx);\n    var if_block2 = show_if && create_if_block$1(ctx);\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block0) if_block0.c();\n        t0 = space();\n        if (if_block1) if_block1.c();\n        t1 = space();\n        if (if_block2) if_block2.c();\n        attr(div, \"class\", \"shepherd-content\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block0) if_block0.m(div, null);\n        append(div, t0);\n        if (if_block1) if_block1.m(div, null);\n        append(div, t1);\n        if (if_block2) if_block2.m(div, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref13 = _slicedToArray(_ref, 1),\n          dirty = _ref13[0];\n        if (dirty & /*step*/\n        4) show_if_2 = !isUndefined( /*step*/\n        ctx[2].options.title) || /*step*/\n        ctx[2].options.cancelIcon && /*step*/\n        ctx[2].options.cancelIcon.enabled;\n        if (show_if_2) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n            if (dirty & /*step*/\n            4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_2(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(div, t0);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n        if (dirty & /*step*/\n        4) show_if_1 = !isUndefined( /*step*/\n        ctx[2].options.text);\n        if (show_if_1) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n            if (dirty & /*step*/\n            4) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block_1(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(div, t1);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n        if (dirty & /*step*/\n        4) show_if = Array.isArray( /*step*/\n        ctx[2].options.buttons) && /*step*/\n        ctx[2].options.buttons.length;\n        if (show_if) {\n          if (if_block2) {\n            if_block2.p(ctx, dirty);\n            if (dirty & /*step*/\n            4) {\n              transition_in(if_block2, 1);\n            }\n          } else {\n            if_block2 = create_if_block$1(ctx);\n            if_block2.c();\n            transition_in(if_block2, 1);\n            if_block2.m(div, null);\n          }\n        } else if (if_block2) {\n          group_outros();\n          transition_out(if_block2, 1, 1, function () {\n            if_block2 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        transition_in(if_block2);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        transition_out(if_block2);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n        if (if_block2) if_block2.d();\n      }\n    };\n  }\n  function instance$2($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n      labelId = $$props.labelId,\n      step = $$props.step;\n    $$self.$$set = function ($$props) {\n      if ('descriptionId' in $$props) $$invalidate(0, descriptionId = $$props.descriptionId);\n      if ('labelId' in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [descriptionId, labelId, step];\n  }\n  var Shepherd_content = /*#__PURE__*/function (_SvelteComponent7) {\n    _inherits(Shepherd_content, _SvelteComponent7);\n    var _super7 = _createSuper(Shepherd_content);\n    function Shepherd_content(options) {\n      var _this9;\n      _classCallCheck(this, Shepherd_content);\n      _this9 = _super7.call(this);\n      init(_assertThisInitialized(_this9), options, instance$2, create_fragment$2, safe_not_equal, {\n        descriptionId: 0,\n        labelId: 1,\n        step: 2\n      });\n      return _this9;\n    }\n    return _createClass(Shepherd_content);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-element.svelte generated by Svelte v3.49.0 */\n  function create_if_block(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-arrow\");\n        attr(div, \"data-popper-arrow\", \"\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n      }\n    };\n  }\n  function create_fragment$1(ctx) {\n    var div;\n    var t;\n    var shepherdcontent;\n    var div_aria_describedby_value;\n    var div_aria_labelledby_value;\n    var current;\n    var mounted;\n    var dispose;\n    var if_block = /*step*/\n    ctx[4].options.arrow && /*step*/\n    ctx[4].options.attachTo && /*step*/\n    ctx[4].options.attachTo.element && /*step*/\n    ctx[4].options.attachTo.on && create_if_block();\n    shepherdcontent = new Shepherd_content({\n      props: {\n        descriptionId: /*descriptionId*/\n        ctx[2],\n        labelId: /*labelId*/\n        ctx[3],\n        step: /*step*/\n        ctx[4]\n      }\n    });\n    var div_levels = [{\n      \"aria-describedby\": div_aria_describedby_value = !isUndefined( /*step*/\n      ctx[4].options.text) ? /*descriptionId*/\n      ctx[2] : null\n    }, {\n      \"aria-labelledby\": div_aria_labelledby_value = /*step*/\n      ctx[4].options.title ? /*labelId*/\n      ctx[3] : null\n    }, /*dataStepId*/\n    ctx[1], {\n      role: \"dialog\"\n    }, {\n      tabindex: \"0\"\n    }];\n    var div_data = {};\n    for (var i = 0; i < div_levels.length; i += 1) {\n      div_data = assign(div_data, div_levels[i]);\n    }\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block) if_block.c();\n        t = space();\n        create_component(shepherdcontent.$$.fragment);\n        set_attributes(div, div_data);\n        toggle_class(div, \"shepherd-has-cancel-icon\", /*hasCancelIcon*/\n        ctx[5]);\n        toggle_class(div, \"shepherd-has-title\", /*hasTitle*/\n        ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block) if_block.m(div, null);\n        append(div, t);\n        mount_component(shepherdcontent, div, null);\n        /*div_binding*/\n\n        ctx[13](div);\n        current = true;\n        if (!mounted) {\n          dispose = listen(div, \"keydown\", /*handleKeyDown*/\n          ctx[7]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref14 = _slicedToArray(_ref, 1),\n          dirty = _ref14[0];\n        if ( /*step*/\n        ctx[4].options.arrow && /*step*/\n        ctx[4].options.attachTo && /*step*/\n        ctx[4].options.attachTo.element && /*step*/\n        ctx[4].options.attachTo.on) {\n          if (if_block) ;else {\n            if_block = create_if_block();\n            if_block.c();\n            if_block.m(div, t);\n          }\n        } else if (if_block) {\n          if_block.d(1);\n          if_block = null;\n        }\n        var shepherdcontent_changes = {};\n        if (dirty & /*descriptionId*/\n        4) shepherdcontent_changes.descriptionId = /*descriptionId*/\n        ctx[2];\n        if (dirty & /*labelId*/\n        8) shepherdcontent_changes.labelId = /*labelId*/\n        ctx[3];\n        if (dirty & /*step*/\n        16) shepherdcontent_changes.step = /*step*/\n        ctx[4];\n        shepherdcontent.$set(shepherdcontent_changes);\n        set_attributes(div, div_data = get_spread_update(div_levels, [(!current || dirty & /*step, descriptionId*/\n        20 && div_aria_describedby_value !== (div_aria_describedby_value = !isUndefined( /*step*/\n        ctx[4].options.text) ? /*descriptionId*/\n        ctx[2] : null)) && {\n          \"aria-describedby\": div_aria_describedby_value\n        }, (!current || dirty & /*step, labelId*/\n        24 && div_aria_labelledby_value !== (div_aria_labelledby_value = /*step*/\n        ctx[4].options.title ? /*labelId*/\n        ctx[3] : null)) && {\n          \"aria-labelledby\": div_aria_labelledby_value\n        }, dirty & /*dataStepId*/\n        2 && /*dataStepId*/\n        ctx[1], {\n          role: \"dialog\"\n        }, {\n          tabindex: \"0\"\n        }]));\n        toggle_class(div, \"shepherd-has-cancel-icon\", /*hasCancelIcon*/\n        ctx[5]);\n        toggle_class(div, \"shepherd-has-title\", /*hasTitle*/\n        ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcontent.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcontent.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block) if_block.d();\n        destroy_component(shepherdcontent);\n        /*div_binding*/\n\n        ctx[13](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  var KEY_TAB = 9;\n  var KEY_ESC = 27;\n  var LEFT_ARROW = 37;\n  var RIGHT_ARROW = 39;\n  function getClassesArray(classes) {\n    return classes.split(' ').filter(function (className) {\n      return !!className.length;\n    });\n  }\n  function instance$1($$self, $$props, $$invalidate) {\n    var classPrefix = $$props.classPrefix,\n      element = $$props.element,\n      descriptionId = $$props.descriptionId,\n      firstFocusableElement = $$props.firstFocusableElement,\n      focusableElements = $$props.focusableElements,\n      labelId = $$props.labelId,\n      lastFocusableElement = $$props.lastFocusableElement,\n      step = $$props.step,\n      dataStepId = $$props.dataStepId;\n    var hasCancelIcon, hasTitle, classes;\n    var getElement = function getElement() {\n      return element;\n    };\n    onMount(function () {\n      // Get all elements that are focusable\n      $$invalidate(1, dataStepId = _defineProperty({}, \"data-\".concat(classPrefix, \"shepherd-step-id\"), step.id));\n      $$invalidate(9, focusableElements = element.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex=\"0\"]'));\n      $$invalidate(8, firstFocusableElement = focusableElements[0]);\n      $$invalidate(10, lastFocusableElement = focusableElements[focusableElements.length - 1]);\n    });\n    afterUpdate(function () {\n      if (classes !== step.options.classes) {\n        updateDynamicClasses();\n      }\n    });\n    function updateDynamicClasses() {\n      removeClasses(classes);\n      classes = step.options.classes;\n      addClasses(classes);\n    }\n    function removeClasses(classes) {\n      if (isString(classes)) {\n        var oldClasses = getClassesArray(classes);\n        if (oldClasses.length) {\n          var _element$classList;\n          (_element$classList = element.classList).remove.apply(_element$classList, _toConsumableArray(oldClasses));\n        }\n      }\n    }\n    function addClasses(classes) {\n      if (isString(classes)) {\n        var newClasses = getClassesArray(classes);\n        if (newClasses.length) {\n          var _element$classList2;\n          (_element$classList2 = element.classList).add.apply(_element$classList2, _toConsumableArray(newClasses));\n        }\n      }\n    }\n    /**\n    * Setup keydown events to allow closing the modal with ESC\n    *\n    * Borrowed from this great post! https://bitsofco.de/accessible-modal-dialog/\n    *\n    * @private\n    */\n\n    var handleKeyDown = function handleKeyDown(e) {\n      var _step = step,\n        tour = _step.tour;\n      switch (e.keyCode) {\n        case KEY_TAB:\n          if (focusableElements.length === 0) {\n            e.preventDefault();\n            break;\n          } // Backward tab\n\n          if (e.shiftKey) {\n            if (document.activeElement === firstFocusableElement || document.activeElement.classList.contains('shepherd-element')) {\n              e.preventDefault();\n              lastFocusableElement.focus();\n            }\n          } else {\n            if (document.activeElement === lastFocusableElement) {\n              e.preventDefault();\n              firstFocusableElement.focus();\n            }\n          }\n          break;\n        case KEY_ESC:\n          if (tour.options.exitOnEsc) {\n            step.cancel();\n          }\n          break;\n        case LEFT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.back();\n          }\n          break;\n        case RIGHT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.next();\n          }\n          break;\n      }\n    };\n    function div_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('classPrefix' in $$props) $$invalidate(11, classPrefix = $$props.classPrefix);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('descriptionId' in $$props) $$invalidate(2, descriptionId = $$props.descriptionId);\n      if ('firstFocusableElement' in $$props) $$invalidate(8, firstFocusableElement = $$props.firstFocusableElement);\n      if ('focusableElements' in $$props) $$invalidate(9, focusableElements = $$props.focusableElements);\n      if ('labelId' in $$props) $$invalidate(3, labelId = $$props.labelId);\n      if ('lastFocusableElement' in $$props) $$invalidate(10, lastFocusableElement = $$props.lastFocusableElement);\n      if ('step' in $$props) $$invalidate(4, step = $$props.step);\n      if ('dataStepId' in $$props) $$invalidate(1, dataStepId = $$props.dataStepId);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/\n      16) {\n        {\n          $$invalidate(5, hasCancelIcon = step.options && step.options.cancelIcon && step.options.cancelIcon.enabled);\n          $$invalidate(6, hasTitle = step.options && step.options.title);\n        }\n      }\n    };\n    return [element, dataStepId, descriptionId, labelId, step, hasCancelIcon, hasTitle, handleKeyDown, firstFocusableElement, focusableElements, lastFocusableElement, classPrefix, getElement, div_binding];\n  }\n  var Shepherd_element = /*#__PURE__*/function (_SvelteComponent8) {\n    _inherits(Shepherd_element, _SvelteComponent8);\n    var _super8 = _createSuper(Shepherd_element);\n    function Shepherd_element(options) {\n      var _this10;\n      _classCallCheck(this, Shepherd_element);\n      _this10 = _super8.call(this);\n      init(_assertThisInitialized(_this10), options, instance$1, create_fragment$1, safe_not_equal, {\n        classPrefix: 11,\n        element: 0,\n        descriptionId: 2,\n        firstFocusableElement: 8,\n        focusableElements: 9,\n        labelId: 3,\n        lastFocusableElement: 10,\n        step: 4,\n        dataStepId: 1,\n        getElement: 12\n      });\n      return _this10;\n    }\n    _createClass(Shepherd_element, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[12];\n      }\n    }]);\n    return Shepherd_element;\n  }(SvelteComponent);\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n  var smoothscroll = createCommonjsModule(function (module, exports) {\n    /* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */\n    (function () {\n      function polyfill() {\n        // aliases\n        var w = window;\n        var d = document; // return if scroll behavior is supported and polyfill is not forced\n\n        if ('scrollBehavior' in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {\n          return;\n        } // globals\n\n        var Element = w.HTMLElement || w.Element;\n        var SCROLL_TIME = 468; // object gathering original scroll methods\n\n        var original = {\n          scroll: w.scroll || w.scrollTo,\n          scrollBy: w.scrollBy,\n          elementScroll: Element.prototype.scroll || scrollElement,\n          scrollIntoView: Element.prototype.scrollIntoView\n        }; // define timing method\n\n        var now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;\n        /**\n         * indicates if a the current browser is made by Microsoft\n         * @method isMicrosoftBrowser\n         * @param {String} userAgent\n         * @returns {Boolean}\n         */\n\n        function isMicrosoftBrowser(userAgent) {\n          var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n          return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n        }\n        /*\n         * IE has rounding bug rounding down clientHeight and clientWidth and\n         * rounding up scrollHeight and scrollWidth causing false positives\n         * on hasScrollableSpace\n         */\n\n        var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n        /**\n         * changes scroll position inside an element\n         * @method scrollElement\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {undefined}\n         */\n\n        function scrollElement(x, y) {\n          this.scrollLeft = x;\n          this.scrollTop = y;\n        }\n        /**\n         * returns result of applying ease math function to a number\n         * @method ease\n         * @param {Number} k\n         * @returns {Number}\n         */\n\n        function ease(k) {\n          return 0.5 * (1 - Math.cos(Math.PI * k));\n        }\n        /**\n         * indicates if a smooth behavior should be applied\n         * @method shouldBailOut\n         * @param {Number|Object} firstArg\n         * @returns {Boolean}\n         */\n\n        function shouldBailOut(firstArg) {\n          if (firstArg === null || _typeof(firstArg) !== 'object' || firstArg.behavior === undefined || firstArg.behavior === 'auto' || firstArg.behavior === 'instant') {\n            // first argument is not an object/null\n            // or behavior is auto, instant or undefined\n            return true;\n          }\n          if (_typeof(firstArg) === 'object' && firstArg.behavior === 'smooth') {\n            // first argument is an object and behavior is smooth\n            return false;\n          } // throw error when behavior is not supported\n\n          throw new TypeError('behavior member of ScrollOptions ' + firstArg.behavior + ' is not a valid value for enumeration ScrollBehavior.');\n        }\n        /**\n         * indicates if an element has scrollable space in the provided axis\n         * @method hasScrollableSpace\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n        function hasScrollableSpace(el, axis) {\n          if (axis === 'Y') {\n            return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n          }\n          if (axis === 'X') {\n            return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n          }\n        }\n        /**\n         * indicates if an element has a scrollable overflow property in the axis\n         * @method canOverflow\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n        function canOverflow(el, axis) {\n          var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n          return overflowValue === 'auto' || overflowValue === 'scroll';\n        }\n        /**\n         * indicates if an element can be scrolled in either axis\n         * @method isScrollable\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n        function isScrollable(el) {\n          var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n          var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n          return isScrollableY || isScrollableX;\n        }\n        /**\n         * finds scrollable parent of an element\n         * @method findScrollableParent\n         * @param {Node} el\n         * @returns {Node} el\n         */\n\n        function findScrollableParent(el) {\n          while (el !== d.body && isScrollable(el) === false) {\n            el = el.parentNode || el.host;\n          }\n          return el;\n        }\n        /**\n         * self invoked function that, given a context, steps through scrolling\n         * @method step\n         * @param {Object} context\n         * @returns {undefined}\n         */\n\n        function step(context) {\n          var time = now();\n          var value;\n          var currentX;\n          var currentY;\n          var elapsed = (time - context.startTime) / SCROLL_TIME; // avoid elapsed times higher than one\n\n          elapsed = elapsed > 1 ? 1 : elapsed; // apply easing to elapsed time\n\n          value = ease(elapsed);\n          currentX = context.startX + (context.x - context.startX) * value;\n          currentY = context.startY + (context.y - context.startY) * value;\n          context.method.call(context.scrollable, currentX, currentY); // scroll more if we have not reached our destination\n\n          if (currentX !== context.x || currentY !== context.y) {\n            w.requestAnimationFrame(step.bind(w, context));\n          }\n        }\n        /**\n         * scrolls window or element with a smooth behavior\n         * @method smoothScroll\n         * @param {Object|Node} el\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {undefined}\n         */\n\n        function smoothScroll(el, x, y) {\n          var scrollable;\n          var startX;\n          var startY;\n          var method;\n          var startTime = now(); // define scroll context\n\n          if (el === d.body) {\n            scrollable = w;\n            startX = w.scrollX || w.pageXOffset;\n            startY = w.scrollY || w.pageYOffset;\n            method = original.scroll;\n          } else {\n            scrollable = el;\n            startX = el.scrollLeft;\n            startY = el.scrollTop;\n            method = scrollElement;\n          } // scroll looping over a frame\n\n          step({\n            scrollable: scrollable,\n            method: method,\n            startTime: startTime,\n            startX: startX,\n            startY: startY,\n            x: x,\n            y: y\n          });\n        } // ORIGINAL METHODS OVERRIDES\n        // w.scroll and w.scrollTo\n\n        w.scroll = w.scrollTo = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n          if (shouldBailOut(arguments[0]) === true) {\n            original.scroll.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof(arguments[0]) !== 'object' ? arguments[0] : w.scrollX || w.pageXOffset,\n            // use top prop, second argument if present or fallback to scrollY\n            arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : w.scrollY || w.pageYOffset);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n          smoothScroll.call(w, d.body, arguments[0].left !== undefined ? ~~arguments[0].left : w.scrollX || w.pageXOffset, arguments[0].top !== undefined ? ~~arguments[0].top : w.scrollY || w.pageYOffset);\n        }; // w.scrollBy\n\n        w.scrollBy = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n          if (shouldBailOut(arguments[0])) {\n            original.scrollBy.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof(arguments[0]) !== 'object' ? arguments[0] : 0, arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : 0);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n          smoothScroll.call(w, d.body, ~~arguments[0].left + (w.scrollX || w.pageXOffset), ~~arguments[0].top + (w.scrollY || w.pageYOffset));\n        }; // Element.prototype.scroll and Element.prototype.scrollTo\n\n        Element.prototype.scroll = Element.prototype.scrollTo = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n          if (shouldBailOut(arguments[0]) === true) {\n            // if one number is passed, throw error to match Firefox implementation\n            if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n              throw new SyntaxError('Value could not be converted');\n            }\n            original.elementScroll.call(this,\n            // use left prop, first number argument or fallback to scrollLeft\n            arguments[0].left !== undefined ? ~~arguments[0].left : _typeof(arguments[0]) !== 'object' ? ~~arguments[0] : this.scrollLeft,\n            // use top prop, second argument or fallback to scrollTop\n            arguments[0].top !== undefined ? ~~arguments[0].top : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop);\n            return;\n          }\n          var left = arguments[0].left;\n          var top = arguments[0].top; // LET THE SMOOTHNESS BEGIN!\n\n          smoothScroll.call(this, this, typeof left === 'undefined' ? this.scrollLeft : ~~left, typeof top === 'undefined' ? this.scrollTop : ~~top);\n        }; // Element.prototype.scrollBy\n\n        Element.prototype.scrollBy = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n          if (shouldBailOut(arguments[0]) === true) {\n            original.elementScroll.call(this, arguments[0].left !== undefined ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, arguments[0].top !== undefined ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop);\n            return;\n          }\n          this.scroll({\n            left: ~~arguments[0].left + this.scrollLeft,\n            top: ~~arguments[0].top + this.scrollTop,\n            behavior: arguments[0].behavior\n          });\n        }; // Element.prototype.scrollIntoView\n\n        Element.prototype.scrollIntoView = function () {\n          // avoid smooth behavior if not required\n          if (shouldBailOut(arguments[0]) === true) {\n            original.scrollIntoView.call(this, arguments[0] === undefined ? true : arguments[0]);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n          var scrollableParent = findScrollableParent(this);\n          var parentRects = scrollableParent.getBoundingClientRect();\n          var clientRects = this.getBoundingClientRect();\n          if (scrollableParent !== d.body) {\n            // reveal element inside parent\n            smoothScroll.call(this, scrollableParent, scrollableParent.scrollLeft + clientRects.left - parentRects.left, scrollableParent.scrollTop + clientRects.top - parentRects.top); // reveal parent in viewport unless is fixed\n\n            if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n              w.scrollBy({\n                left: parentRects.left,\n                top: parentRects.top,\n                behavior: 'smooth'\n              });\n            }\n          } else {\n            // reveal element in viewport\n            w.scrollBy({\n              left: clientRects.left,\n              top: clientRects.top,\n              behavior: 'smooth'\n            });\n          }\n        };\n      }\n      {\n        // commonjs\n        module.exports = {\n          polyfill: polyfill\n        };\n      }\n    })();\n  });\n  smoothscroll.polyfill;\n  smoothscroll.polyfill();\n  /**\n   * A class representing steps to be added to a tour.\n   * @extends {Evented}\n   */\n  var Step = /*#__PURE__*/function (_Evented) {\n    _inherits(Step, _Evented);\n    var _super9 = _createSuper(Step);\n    /**\n     * Create a step\n     * @param {Tour} tour The tour for the step\n     * @param {object} options The options for the step\n     * @param {boolean} options.arrow Whether to display the arrow for the tooltip or not. Defaults to `true`.\n     * @param {object} options.attachTo The element the step should be attached to on the page.\n     * An object with properties `element` and `on`.\n     *\n     * ```js\n     * const step = new Step(tour, {\n     *   attachTo: { element: '.some .selector-path', on: 'left' },\n     *   ...moreOptions\n     * });\n     * ```\n     *\n     * If you don’t specify an `attachTo` the element will appear in the middle of the screen. The same will happen if your `attachTo.element` callback returns `null`, `undefined`, or a selector that does not exist in the DOM.\n     * If you omit the `on` portion of `attachTo`, the element will still be highlighted, but the tooltip will appear\n     * in the middle of the screen, without an arrow pointing to the target.\n     * If the element to highlight does not yet exist while instantiating tour steps, you may use lazy evaluation by supplying a function to `attachTo.element`. The function will be called in the `before-show` phase.\n     * @param {string|HTMLElement|function} options.attachTo.element An element selector string, DOM element, or a function (returning a selector, a DOM element, `null` or `undefined`).\n     * @param {string} options.attachTo.on The optional direction to place the Popper tooltip relative to the element.\n     *   - Possible string values: 'auto', 'auto-start', 'auto-end', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'right', 'right-start', 'right-end', 'left', 'left-start', 'left-end'\n     * @param {Object} options.advanceOn An action on the page which should advance shepherd to the next step.\n     * It should be an object with a string `selector` and an `event` name\n     * ```js\n     * const step = new Step(tour, {\n     *   advanceOn: { selector: '.some .selector-path', event: 'click' },\n     *   ...moreOptions\n     * });\n     * ```\n     * `event` doesn’t have to be an event inside the tour, it can be any event fired on any element on the page.\n     * You can also always manually advance the Tour by calling `myTour.next()`.\n     * @param {function} options.beforeShowPromise A function that returns a promise.\n     * When the promise resolves, the rest of the `show` code for the step will execute.\n     * @param {Object[]} options.buttons An array of buttons to add to the step. These will be rendered in a\n     * footer below the main body text.\n     * @param {function} options.buttons.button.action A function executed when the button is clicked on.\n     * It is automatically bound to the `tour` the step is associated with, so things like `this.next` will\n     * work inside the action.\n     * You can use action to skip steps or navigate to specific steps, with something like:\n     * ```js\n     * action() {\n     *   return this.show('some_step_name');\n     * }\n     * ```\n     * @param {string} options.buttons.button.classes Extra classes to apply to the `<a>`\n     * @param {boolean} options.buttons.button.disabled Should the button be disabled?\n     * @param {string} options.buttons.button.label The aria-label text of the button\n     * @param {boolean} options.buttons.button.secondary If true, a shepherd-button-secondary class is applied to the button\n     * @param {string} options.buttons.button.text The HTML text of the button\n     * @param {boolean} options.canClickTarget A boolean, that when set to false, will set `pointer-events: none` on the target\n     * @param {object} options.cancelIcon Options for the cancel icon\n     * @param {boolean} options.cancelIcon.enabled Should a cancel “✕” be shown in the header of the step?\n     * @param {string} options.cancelIcon.label The label to add for `aria-label`\n     * @param {string} options.classes A string of extra classes to add to the step's content element.\n     * @param {string} options.highlightClass An extra class to apply to the `attachTo` element when it is\n     * highlighted (that is, when its step is active). You can then target that selector in your CSS.\n     * @param {string} options.id The string to use as the `id` for the step.\n     * @param {number} options.modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening\n     * @param {number} options.modalOverlayOpeningRadius An amount of border radius to add around the modal overlay opening\n     * @param {object} options.popperOptions Extra options to pass to Popper\n     * @param {boolean|Object} options.scrollTo Should the element be scrolled to when this step is shown? If true, uses the default `scrollIntoView`,\n     * if an object, passes that object as the params to `scrollIntoView` i.e. `{behavior: 'smooth', block: 'center'}`\n     * @param {function} options.scrollToHandler A function that lets you override the default scrollTo behavior and\n     * define a custom action to do the scrolling, and possibly other logic.\n     * @param {function} options.showOn A function that, when it returns `true`, will show the step.\n     * If it returns false, the step will be skipped.\n     * @param {string} options.text The text in the body of the step. It can be one of three types:\n     * ```\n     * - HTML string\n     * - `HTMLElement` object\n     * - `Function` to be executed when the step is built. It must return one the two options above.\n     * ```\n     * @param {string} options.title The step's title. It becomes an `h3` at the top of the step. It can be one of two types:\n     * ```\n     * - HTML string\n     * - `Function` to be executed when the step is built. It must return HTML string.\n     * ```\n     * @param {object} options.when You can define `show`, `hide`, etc events inside `when`. For example:\n     * ```js\n     * when: {\n     *   show: function() {\n     *     window.scrollTo(0, 0);\n     *   }\n     * }\n     * ```\n     * @return {Step} The newly created Step instance\n     */\n    function Step(tour, options) {\n      var _this11;\n      _classCallCheck(this, Step);\n      if (options === void 0) {\n        options = {};\n      }\n      _this11 = _super9.call(this, tour, options);\n      _this11.tour = tour;\n      _this11.classPrefix = _this11.tour.options ? normalizePrefix(_this11.tour.options.classPrefix) : '';\n      _this11.styles = tour.styles;\n      /**\n       * Resolved attachTo options. Due to lazy evaluation, we only resolve the options during `before-show` phase.\n       * Do not use this directly, use the _getResolvedAttachToOptions method instead.\n       * @type {null|{}|{element, to}}\n       * @private\n       */\n\n      _this11._resolvedAttachTo = null;\n      autoBind(_assertThisInitialized(_this11));\n      _this11._setOptions(options);\n      return _possibleConstructorReturn(_this11, _assertThisInitialized(_this11));\n    }\n    /**\n     * Cancel the tour\n     * Triggers the `cancel` event\n     */\n    _createClass(Step, [{\n      key: \"cancel\",\n      value: function cancel() {\n        this.tour.cancel();\n        this.trigger('cancel');\n      }\n      /**\n       * Complete the tour\n       * Triggers the `complete` event\n       */\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this.tour.complete();\n        this.trigger('complete');\n      }\n      /**\n       * Remove the step, delete the step's element, and destroy the Popper instance for the step.\n       * Triggers `destroy` event\n       */\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        if (this.tooltip) {\n          this.tooltip.destroy();\n          this.tooltip = null;\n        }\n        if (isHTMLElement$1(this.el) && this.el.parentNode) {\n          this.el.parentNode.removeChild(this.el);\n          this.el = null;\n        }\n        this._updateStepTargetOnHide();\n        this.trigger('destroy');\n      }\n      /**\n       * Returns the tour for the step\n       * @return {Tour} The tour instance\n       */\n    }, {\n      key: \"getTour\",\n      value: function getTour() {\n        return this.tour;\n      }\n      /**\n       * Hide the step\n       */\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        this.tour.modal.hide();\n        this.trigger('before-hide');\n        if (this.el) {\n          this.el.hidden = true;\n        }\n        this._updateStepTargetOnHide();\n        this.trigger('hide');\n      }\n      /**\n       * Resolves attachTo options.\n       * @returns {{}|{element, on}}\n       * @private\n       */\n    }, {\n      key: \"_resolveAttachToOptions\",\n      value: function _resolveAttachToOptions() {\n        this._resolvedAttachTo = parseAttachTo(this);\n        return this._resolvedAttachTo;\n      }\n      /**\n       * A selector for resolved attachTo options.\n       * @returns {{}|{element, on}}\n       * @private\n       */\n    }, {\n      key: \"_getResolvedAttachToOptions\",\n      value: function _getResolvedAttachToOptions() {\n        if (this._resolvedAttachTo === null) {\n          return this._resolveAttachToOptions();\n        }\n        return this._resolvedAttachTo;\n      }\n      /**\n       * Check if the step is open and visible\n       * @return {boolean} True if the step is open and visible\n       */\n    }, {\n      key: \"isOpen\",\n      value: function isOpen() {\n        return Boolean(this.el && !this.el.hidden);\n      }\n      /**\n       * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show\n       * @return {*|Promise}\n       */\n    }, {\n      key: \"show\",\n      value: function show() {\n        var _this12 = this;\n        if (isFunction(this.options.beforeShowPromise)) {\n          var beforeShowPromise = this.options.beforeShowPromise();\n          if (!isUndefined(beforeShowPromise)) {\n            return beforeShowPromise.then(function () {\n              return _this12._show();\n            });\n          }\n        }\n        this._show();\n      }\n      /**\n       * Updates the options of the step.\n       *\n       * @param {Object} options The options for the step\n       */\n    }, {\n      key: \"updateStepOptions\",\n      value: function updateStepOptions(options) {\n        Object.assign(this.options, options);\n        if (this.shepherdElementComponent) {\n          this.shepherdElementComponent.$set({\n            step: this\n          });\n        }\n      }\n      /**\n       * Returns the element for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if it has been destroyed\n       */\n    }, {\n      key: \"getElement\",\n      value: function getElement() {\n        return this.el;\n      }\n      /**\n       * Returns the target for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if query string has not been found\n       */\n    }, {\n      key: \"getTarget\",\n      value: function getTarget() {\n        return this.target;\n      }\n      /**\n       * Creates Shepherd element for step based on options\n       *\n       * @return {Element} The DOM element for the step tooltip\n       * @private\n       */\n    }, {\n      key: \"_createTooltipContent\",\n      value: function _createTooltipContent() {\n        var descriptionId = \"\".concat(this.id, \"-description\");\n        var labelId = \"\".concat(this.id, \"-label\");\n        this.shepherdElementComponent = new Shepherd_element({\n          target: this.tour.options.stepsContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            descriptionId: descriptionId,\n            labelId: labelId,\n            step: this,\n            styles: this.styles\n          }\n        });\n        return this.shepherdElementComponent.getElement();\n      }\n      /**\n       * If a custom scrollToHandler is defined, call that, otherwise do the generic\n       * scrollIntoView call.\n       *\n       * @param {boolean|Object} scrollToOptions If true, uses the default `scrollIntoView`,\n       * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`\n       * @private\n       */\n    }, {\n      key: \"_scrollTo\",\n      value: function _scrollTo(scrollToOptions) {\n        var _this$_getResolvedAtt = this._getResolvedAttachToOptions(),\n          element = _this$_getResolvedAtt.element;\n        if (isFunction(this.options.scrollToHandler)) {\n          this.options.scrollToHandler(element);\n        } else if (isElement$1(element) && typeof element.scrollIntoView === 'function') {\n          element.scrollIntoView(scrollToOptions);\n        }\n      }\n      /**\n       * _getClassOptions gets all possible classes for the step\n       * @param {Object} stepOptions The step specific options\n       * @returns {String} unique string from array of classes\n       * @private\n       */\n    }, {\n      key: \"_getClassOptions\",\n      value: function _getClassOptions(stepOptions) {\n        var defaultStepOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        var stepClasses = stepOptions.classes ? stepOptions.classes : '';\n        var defaultStepOptionsClasses = defaultStepOptions && defaultStepOptions.classes ? defaultStepOptions.classes : '';\n        var allClasses = [].concat(_toConsumableArray(stepClasses.split(' ')), _toConsumableArray(defaultStepOptionsClasses.split(' ')));\n        var uniqClasses = new Set(allClasses);\n        return Array.from(uniqClasses).join(' ').trim();\n      }\n      /**\n       * Sets the options for the step, maps `when` to events, sets up buttons\n       * @param {Object} options The options for the step\n       * @private\n       */\n    }, {\n      key: \"_setOptions\",\n      value: function _setOptions(options) {\n        var _this13 = this;\n        if (options === void 0) {\n          options = {};\n        }\n        var tourOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        tourOptions = cjs({}, tourOptions || {});\n        this.options = Object.assign({\n          arrow: true\n        }, tourOptions, options);\n        var when = this.options.when;\n        this.options.classes = this._getClassOptions(options);\n        this.destroy();\n        this.id = this.options.id || \"step-\".concat(uuid());\n        if (when) {\n          Object.keys(when).forEach(function (event) {\n            _this13.on(event, when[event], _this13);\n          });\n        }\n      }\n      /**\n       * Create the element and set up the Popper instance\n       * @private\n       */\n    }, {\n      key: \"_setupElements\",\n      value: function _setupElements() {\n        if (!isUndefined(this.el)) {\n          this.destroy();\n        }\n        this.el = this._createTooltipContent();\n        if (this.options.advanceOn) {\n          bindAdvance(this);\n        }\n        setupTooltip(this);\n      }\n      /**\n       * Triggers `before-show`, generates the tooltip DOM content,\n       * sets up a Popper instance for the tooltip, then triggers `show`.\n       * @private\n       */\n    }, {\n      key: \"_show\",\n      value: function _show() {\n        var _this14 = this;\n        this.trigger('before-show'); // Force resolve to make sure the options are updated on subsequent shows.\n\n        this._resolveAttachToOptions();\n        this._setupElements();\n        if (!this.tour.modal) {\n          this.tour._setupModal();\n        }\n        this.tour.modal.setupForStep(this);\n        this._styleTargetElementForStep(this);\n        this.el.hidden = false; // start scrolling to target before showing the step\n\n        if (this.options.scrollTo) {\n          setTimeout(function () {\n            _this14._scrollTo(_this14.options.scrollTo);\n          });\n        }\n        this.el.hidden = false;\n        var content = this.shepherdElementComponent.getElement();\n        var target = this.target || document.body;\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-enabled\"));\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-target\"));\n        content.classList.add('shepherd-enabled');\n        this.trigger('show');\n      }\n      /**\n       * Modulates the styles of the passed step's target element, based on the step's options and\n       * the tour's `modal` option, to visually emphasize the element\n       *\n       * @param step The step object that attaches to the element\n       * @private\n       */\n    }, {\n      key: \"_styleTargetElementForStep\",\n      value: function _styleTargetElementForStep(step) {\n        var targetElement = step.target;\n        if (!targetElement) {\n          return;\n        }\n        if (step.options.highlightClass) {\n          targetElement.classList.add(step.options.highlightClass);\n        }\n        targetElement.classList.remove('shepherd-target-click-disabled');\n        if (step.options.canClickTarget === false) {\n          targetElement.classList.add('shepherd-target-click-disabled');\n        }\n      }\n      /**\n       * When a step is hidden, remove the highlightClass and 'shepherd-enabled'\n       * and 'shepherd-target' classes\n       * @private\n       */\n    }, {\n      key: \"_updateStepTargetOnHide\",\n      value: function _updateStepTargetOnHide() {\n        var target = this.target || document.body;\n        if (this.options.highlightClass) {\n          target.classList.remove(this.options.highlightClass);\n        }\n        target.classList.remove('shepherd-target-click-disabled', \"\".concat(this.classPrefix, \"shepherd-enabled\"), \"\".concat(this.classPrefix, \"shepherd-target\"));\n      }\n    }]);\n    return Step;\n  }(Evented);\n  /**\n   * Cleanup the steps and set pointerEvents back to 'auto'\n   * @param tour The tour object\n   */\n  function cleanupSteps(tour) {\n    if (tour) {\n      var steps = tour.steps;\n      steps.forEach(function (step) {\n        if (step.options && step.options.canClickTarget === false && step.options.attachTo) {\n          if (step.target instanceof HTMLElement) {\n            step.target.classList.remove('shepherd-target-click-disabled');\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Generates the svg path data for a rounded rectangle overlay\n   * @param {Object} dimension - Dimensions of rectangle.\n   * @param {number} width - Width.\n   * @param {number} height - Height.\n   * @param {number} [x=0] - Offset from top left corner in x axis. default 0.\n   * @param {number} [y=0] - Offset from top left corner in y axis. default 0.\n   * @param {number} [r=0] - Corner Radius. Keep this smaller than  half of width or height.\n   * @returns {string} - Rounded rectangle overlay path data.\n   */\n  function makeOverlayPath(_ref) {\n    var width = _ref.width,\n      height = _ref.height,\n      _ref$x = _ref.x,\n      x = _ref$x === void 0 ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === void 0 ? 0 : _ref$y,\n      _ref$r = _ref.r,\n      r = _ref$r === void 0 ? 0 : _ref$r;\n    var _window = window,\n      w = _window.innerWidth,\n      h = _window.innerHeight;\n    return \"M\".concat(w, \",\").concat(h, \"H0V0H\").concat(w, \"V\").concat(h, \"ZM\").concat(x + r, \",\").concat(y, \"a\").concat(r, \",\").concat(r, \",0,0,0-\").concat(r, \",\").concat(r, \"V\").concat(height + y - r, \"a\").concat(r, \",\").concat(r, \",0,0,0,\").concat(r, \",\").concat(r, \"H\").concat(width + x - r, \"a\").concat(r, \",\").concat(r, \",0,0,0,\").concat(r, \"-\").concat(r, \"V\").concat(y + r, \"a\").concat(r, \",\").concat(r, \",0,0,0-\").concat(r, \"-\").concat(r, \"Z\");\n  }\n\n  /* src/js/components/shepherd-modal.svelte generated by Svelte v3.49.0 */\n\n  function create_fragment(ctx) {\n    var svg;\n    var path;\n    var svg_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        svg = svg_element(\"svg\");\n        path = svg_element(\"path\");\n        attr(path, \"d\", /*pathDefinition*/\n        ctx[2]);\n        attr(svg, \"class\", svg_class_value = \"\".concat( /*modalIsVisible*/\n        ctx[1] ? 'shepherd-modal-is-visible' : '', \" shepherd-modal-overlay-container\"));\n      },\n      m: function m(target, anchor) {\n        insert(target, svg, anchor);\n        append(svg, path);\n        /*svg_binding*/\n\n        ctx[11](svg);\n        if (!mounted) {\n          dispose = listen(svg, \"touchmove\", /*_preventModalOverlayTouch*/\n          ctx[3]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref15 = _slicedToArray(_ref, 1),\n          dirty = _ref15[0];\n        if (dirty & /*pathDefinition*/\n        4) {\n          attr(path, \"d\", /*pathDefinition*/\n          ctx[2]);\n        }\n        if (dirty & /*modalIsVisible*/\n        2 && svg_class_value !== (svg_class_value = \"\".concat( /*modalIsVisible*/\n        ctx[1] ? 'shepherd-modal-is-visible' : '', \" shepherd-modal-overlay-container\"))) {\n          attr(svg, \"class\", svg_class_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(svg);\n        /*svg_binding*/\n\n        ctx[11](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function _getScrollParent(element) {\n    if (!element) {\n      return null;\n    }\n    var isHtmlElement = element instanceof HTMLElement;\n    var overflowY = isHtmlElement && window.getComputedStyle(element).overflowY;\n    var isScrollable = overflowY !== 'hidden' && overflowY !== 'visible';\n    if (isScrollable && element.scrollHeight >= element.clientHeight) {\n      return element;\n    }\n    return _getScrollParent(element.parentElement);\n  }\n  /**\n   * Get the visible height of the target element relative to its scrollParent.\n   * If there is no scroll parent, the height of the element is returned.\n   *\n   * @param {HTMLElement} element The target element\n   * @param {HTMLElement} [scrollParent] The scrollable parent element\n   * @returns {{y: number, height: number}}\n   * @private\n   */\n\n  function _getVisibleHeight(element, scrollParent) {\n    var elementRect = element.getBoundingClientRect();\n    var top = elementRect.y || elementRect.top;\n    var bottom = elementRect.bottom || top + elementRect.height;\n    if (scrollParent) {\n      var scrollRect = scrollParent.getBoundingClientRect();\n      var scrollTop = scrollRect.y || scrollRect.top;\n      var scrollBottom = scrollRect.bottom || scrollTop + scrollRect.height;\n      top = Math.max(top, scrollTop);\n      bottom = Math.min(bottom, scrollBottom);\n    }\n    var height = Math.max(bottom - top, 0); // Default to 0 if height is negative\n\n    return {\n      y: top,\n      height: height\n    };\n  }\n  function instance($$self, $$props, $$invalidate) {\n    var element = $$props.element,\n      openingProperties = $$props.openingProperties;\n    uuid();\n    var modalIsVisible = false;\n    var rafId = undefined;\n    var pathDefinition;\n    closeModalOpening();\n    var getElement = function getElement() {\n      return element;\n    };\n    function closeModalOpening() {\n      $$invalidate(4, openingProperties = {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0,\n        r: 0\n      });\n    }\n    function hide() {\n      $$invalidate(1, modalIsVisible = false); // Ensure we cleanup all event listeners when we hide the modal\n\n      _cleanupStepEventListeners();\n    }\n    function positionModal(modalOverlayOpeningPadding, modalOverlayOpeningRadius, scrollParent, targetElement) {\n      if (modalOverlayOpeningPadding === void 0) {\n        modalOverlayOpeningPadding = 0;\n      }\n      if (modalOverlayOpeningRadius === void 0) {\n        modalOverlayOpeningRadius = 0;\n      }\n      if (targetElement) {\n        var _getVisibleHeight2 = _getVisibleHeight(targetElement, scrollParent),\n          y = _getVisibleHeight2.y,\n          height = _getVisibleHeight2.height;\n        var _targetElement$getBou = targetElement.getBoundingClientRect(),\n          x = _targetElement$getBou.x,\n          width = _targetElement$getBou.width,\n          _left = _targetElement$getBou.left; // getBoundingClientRect is not consistent. Some browsers use x and y, while others use left and top\n\n        $$invalidate(4, openingProperties = {\n          width: width + modalOverlayOpeningPadding * 2,\n          height: height + modalOverlayOpeningPadding * 2,\n          x: (x || _left) - modalOverlayOpeningPadding,\n          y: y - modalOverlayOpeningPadding,\n          r: modalOverlayOpeningRadius\n        });\n      } else {\n        closeModalOpening();\n      }\n    }\n    function setupForStep(step) {\n      // Ensure we move listeners from the previous step, before we setup new ones\n      _cleanupStepEventListeners();\n      if (step.tour.options.useModalOverlay) {\n        _styleForStep(step);\n        show();\n      } else {\n        hide();\n      }\n    }\n    function show() {\n      $$invalidate(1, modalIsVisible = true);\n    }\n    var _preventModalBodyTouch = function _preventModalBodyTouch(e) {\n      e.preventDefault();\n    };\n    var _preventModalOverlayTouch = function _preventModalOverlayTouch(e) {\n      e.stopPropagation();\n    };\n    /**\n    * Add touchmove event listener\n    * @private\n    */\n\n    function _addStepEventListeners() {\n      // Prevents window from moving on touch.\n      window.addEventListener('touchmove', _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n    /**\n    * Cancel the requestAnimationFrame loop and remove touchmove event listeners\n    * @private\n    */\n\n    function _cleanupStepEventListeners() {\n      if (rafId) {\n        cancelAnimationFrame(rafId);\n        rafId = undefined;\n      }\n      window.removeEventListener('touchmove', _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n    /**\n    * Style the modal for the step\n    * @param {Step} step The step to style the opening for\n    * @private\n    */\n\n    function _styleForStep(step) {\n      var _step$options = step.options,\n        modalOverlayOpeningPadding = _step$options.modalOverlayOpeningPadding,\n        modalOverlayOpeningRadius = _step$options.modalOverlayOpeningRadius;\n      var scrollParent = _getScrollParent(step.target); // Setup recursive function to call requestAnimationFrame to update the modal opening position\n\n      var rafLoop = function rafLoop() {\n        rafId = undefined;\n        positionModal(modalOverlayOpeningPadding, modalOverlayOpeningRadius, scrollParent, step.target);\n        rafId = requestAnimationFrame(rafLoop);\n      };\n      rafLoop();\n      _addStepEventListeners();\n    }\n    function svg_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('openingProperties' in $$props) $$invalidate(4, openingProperties = $$props.openingProperties);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*openingProperties*/\n      16) {\n        $$invalidate(2, pathDefinition = makeOverlayPath(openingProperties));\n      }\n    };\n    return [element, modalIsVisible, pathDefinition, _preventModalOverlayTouch, openingProperties, getElement, closeModalOpening, hide, positionModal, setupForStep, show, svg_binding];\n  }\n  var Shepherd_modal = /*#__PURE__*/function (_SvelteComponent9) {\n    _inherits(Shepherd_modal, _SvelteComponent9);\n    var _super10 = _createSuper(Shepherd_modal);\n    function Shepherd_modal(options) {\n      var _this15;\n      _classCallCheck(this, Shepherd_modal);\n      _this15 = _super10.call(this);\n      init(_assertThisInitialized(_this15), options, instance, create_fragment, safe_not_equal, {\n        element: 0,\n        openingProperties: 4,\n        getElement: 5,\n        closeModalOpening: 6,\n        hide: 7,\n        positionModal: 8,\n        setupForStep: 9,\n        show: 10\n      });\n      return _this15;\n    }\n    _createClass(Shepherd_modal, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[5];\n      }\n    }, {\n      key: \"closeModalOpening\",\n      get: function get() {\n        return this.$$.ctx[6];\n      }\n    }, {\n      key: \"hide\",\n      get: function get() {\n        return this.$$.ctx[7];\n      }\n    }, {\n      key: \"positionModal\",\n      get: function get() {\n        return this.$$.ctx[8];\n      }\n    }, {\n      key: \"setupForStep\",\n      get: function get() {\n        return this.$$.ctx[9];\n      }\n    }, {\n      key: \"show\",\n      get: function get() {\n        return this.$$.ctx[10];\n      }\n    }]);\n    return Shepherd_modal;\n  }(SvelteComponent);\n  var Shepherd = new Evented();\n  /**\n   * Class representing the site tour\n   * @extends {Evented}\n   */\n  var Tour = /*#__PURE__*/function (_Evented2) {\n    _inherits(Tour, _Evented2);\n    var _super11 = _createSuper(Tour);\n    /**\n     * @param {Object} options The options for the tour\n     * @param {boolean} options.confirmCancel If true, will issue a `window.confirm` before cancelling\n     * @param {string} options.confirmCancelMessage The message to display in the confirm dialog\n     * @param {string} options.classPrefix The prefix to add to the `shepherd-enabled` and `shepherd-target` class names as well as the `data-shepherd-step-id`.\n     * @param {Object} options.defaultStepOptions Default options for Steps ({@link Step#constructor}), created through `addStep`\n     * @param {boolean} options.exitOnEsc Exiting the tour with the escape key will be enabled unless this is explicitly\n     * set to false.\n     * @param {boolean} options.keyboardNavigation Navigating the tour via left and right arrow keys will be enabled\n     * unless this is explicitly set to false.\n     * @param {HTMLElement} options.stepsContainer An optional container element for the steps.\n     * If not set, the steps will be appended to `document.body`.\n     * @param {HTMLElement} options.modalContainer An optional container element for the modal.\n     * If not set, the modal will be appended to `document.body`.\n     * @param {object[] | Step[]} options.steps An array of step options objects or Step instances to initialize the tour with\n     * @param {string} options.tourName An optional \"name\" for the tour. This will be appended to the the tour's\n     * dynamically generated `id` property -- which is also set on the `body` element as the `data-shepherd-active-tour` attribute\n     * whenever the tour becomes active.\n     * @param {boolean} options.useModalOverlay Whether or not steps should be placed above a darkened\n     * modal overlay. If true, the overlay will create an opening around the target element so that it\n     * can remain interactive\n     * @returns {Tour}\n     */\n    function Tour(options) {\n      var _this16;\n      _classCallCheck(this, Tour);\n      if (options === void 0) {\n        options = {};\n      }\n      _this16 = _super11.call(this, options);\n      autoBind(_assertThisInitialized(_this16));\n      var defaultTourOptions = {\n        exitOnEsc: true,\n        keyboardNavigation: true\n      };\n      _this16.options = Object.assign({}, defaultTourOptions, options);\n      _this16.classPrefix = normalizePrefix(_this16.options.classPrefix);\n      _this16.steps = [];\n      _this16.addSteps(_this16.options.steps); // Pass these events onto the global Shepherd object\n\n      var events = ['active', 'cancel', 'complete', 'inactive', 'show', 'start'];\n      events.map(function (event) {\n        (function (e) {\n          _this16.on(e, function (opts) {\n            opts = opts || {};\n            opts.tour = _assertThisInitialized(_this16);\n            Shepherd.trigger(e, opts);\n          });\n        })(event);\n      });\n      _this16._setTourID();\n      return _possibleConstructorReturn(_this16, _assertThisInitialized(_this16));\n    }\n    /**\n     * Adds a new step to the tour\n     * @param {Object|Step} options An object containing step options or a Step instance\n     * @param {number} index The optional index to insert the step at. If undefined, the step\n     * is added to the end of the array.\n     * @return {Step} The newly added step\n     */\n    _createClass(Tour, [{\n      key: \"addStep\",\n      value: function addStep(options, index) {\n        var step = options;\n        if (!(step instanceof Step)) {\n          step = new Step(this, step);\n        } else {\n          step.tour = this;\n        }\n        if (!isUndefined(index)) {\n          this.steps.splice(index, 0, step);\n        } else {\n          this.steps.push(step);\n        }\n        return step;\n      }\n      /**\n       * Add multiple steps to the tour\n       * @param {Array<object> | Array<Step>} steps The steps to add to the tour\n       */\n    }, {\n      key: \"addSteps\",\n      value: function addSteps(steps) {\n        var _this17 = this;\n        if (Array.isArray(steps)) {\n          steps.forEach(function (step) {\n            _this17.addStep(step);\n          });\n        }\n        return this;\n      }\n      /**\n       * Go to the previous step in the tour\n       */\n    }, {\n      key: \"back\",\n      value: function back() {\n        var index = this.steps.indexOf(this.currentStep);\n        this.show(index - 1, false);\n      }\n      /**\n       * Calls _done() triggering the 'cancel' event\n       * If `confirmCancel` is true, will show a window.confirm before cancelling\n       */\n    }, {\n      key: \"cancel\",\n      value: function cancel() {\n        if (this.options.confirmCancel) {\n          var cancelMessage = this.options.confirmCancelMessage || 'Are you sure you want to stop the tour?';\n          var stopTour = window.confirm(cancelMessage);\n          if (stopTour) {\n            this._done('cancel');\n          }\n        } else {\n          this._done('cancel');\n        }\n      }\n      /**\n       * Calls _done() triggering the `complete` event\n       */\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this._done('complete');\n      }\n      /**\n       * Gets the step from a given id\n       * @param {Number|String} id The id of the step to retrieve\n       * @return {Step} The step corresponding to the `id`\n       */\n    }, {\n      key: \"getById\",\n      value: function getById(id) {\n        return this.steps.find(function (step) {\n          return step.id === id;\n        });\n      }\n      /**\n       * Gets the current step\n       * @returns {Step|null}\n       */\n    }, {\n      key: \"getCurrentStep\",\n      value: function getCurrentStep() {\n        return this.currentStep;\n      }\n      /**\n       * Hide the current step\n       */\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var currentStep = this.getCurrentStep();\n        if (currentStep) {\n          return currentStep.hide();\n        }\n      }\n      /**\n       * Check if the tour is active\n       * @return {boolean}\n       */\n    }, {\n      key: \"isActive\",\n      value: function isActive() {\n        return Shepherd.activeTour === this;\n      }\n      /**\n       * Go to the next step in the tour\n       * If we are at the end, call `complete`\n       */\n    }, {\n      key: \"next\",\n      value: function next() {\n        var index = this.steps.indexOf(this.currentStep);\n        if (index === this.steps.length - 1) {\n          this.complete();\n        } else {\n          this.show(index + 1, true);\n        }\n      }\n      /**\n       * Removes the step from the tour\n       * @param {String} name The id for the step to remove\n       */\n    }, {\n      key: \"removeStep\",\n      value: function removeStep(name) {\n        var _this18 = this;\n        var current = this.getCurrentStep(); // Find the step, destroy it and remove it from this.steps\n\n        this.steps.some(function (step, i) {\n          if (step.id === name) {\n            if (step.isOpen()) {\n              step.hide();\n            }\n            step.destroy();\n            _this18.steps.splice(i, 1);\n            return true;\n          }\n        });\n        if (current && current.id === name) {\n          this.currentStep = undefined; // If we have steps left, show the first one, otherwise just cancel the tour\n\n          this.steps.length ? this.show(0) : this.cancel();\n        }\n      }\n      /**\n       * Show a specific step in the tour\n       * @param {Number|String} key The key to look up the step by\n       * @param {Boolean} forward True if we are going forward, false if backward\n       */\n    }, {\n      key: \"show\",\n      value: function show(key, forward) {\n        if (key === void 0) {\n          key = 0;\n        }\n        if (forward === void 0) {\n          forward = true;\n        }\n        var step = isString(key) ? this.getById(key) : this.steps[key];\n        if (step) {\n          this._updateStateBeforeShow();\n          var shouldSkipStep = isFunction(step.options.showOn) && !step.options.showOn(); // If `showOn` returns false, we want to skip the step, otherwise, show the step like normal\n\n          if (shouldSkipStep) {\n            this._skipStep(step, forward);\n          } else {\n            this.trigger('show', {\n              step: step,\n              previous: this.currentStep\n            });\n            this.currentStep = step;\n            step.show();\n          }\n        }\n      }\n      /**\n       * Start the tour\n       */\n    }, {\n      key: \"start\",\n      value: function start() {\n        this.trigger('start'); // Save the focused element before the tour opens\n\n        this.focusedElBeforeOpen = document.activeElement;\n        this.currentStep = null;\n        this._setupModal();\n        this._setupActiveTour();\n        this.next();\n      }\n      /**\n       * Called whenever the tour is cancelled or completed, basically anytime we exit the tour\n       * @param {String} event The event name to trigger\n       * @private\n       */\n    }, {\n      key: \"_done\",\n      value: function _done(event) {\n        var index = this.steps.indexOf(this.currentStep);\n        if (Array.isArray(this.steps)) {\n          this.steps.forEach(function (step) {\n            return step.destroy();\n          });\n        }\n        cleanupSteps(this);\n        this.trigger(event, {\n          index: index\n        });\n        Shepherd.activeTour = null;\n        this.trigger('inactive', {\n          tour: this\n        });\n        if (this.modal) {\n          this.modal.hide();\n        }\n        if (event === 'cancel' || event === 'complete') {\n          if (this.modal) {\n            var modalContainer = document.querySelector('.shepherd-modal-overlay-container');\n            if (modalContainer) {\n              modalContainer.remove();\n            }\n          }\n        } // Focus the element that was focused before the tour started\n\n        if (isHTMLElement$1(this.focusedElBeforeOpen)) {\n          this.focusedElBeforeOpen.focus();\n        }\n      }\n      /**\n       * Make this tour \"active\"\n       * @private\n       */\n    }, {\n      key: \"_setupActiveTour\",\n      value: function _setupActiveTour() {\n        this.trigger('active', {\n          tour: this\n        });\n        Shepherd.activeTour = this;\n      }\n      /**\n       * _setupModal create the modal container and instance\n       * @private\n       */\n    }, {\n      key: \"_setupModal\",\n      value: function _setupModal() {\n        this.modal = new Shepherd_modal({\n          target: this.options.modalContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            styles: this.styles\n          }\n        });\n      }\n      /**\n       * Called when `showOn` evaluates to false, to skip the step or complete the tour if it's the last step\n       * @param {Step} step The step to skip\n       * @param {Boolean} forward True if we are going forward, false if backward\n       * @private\n       */\n    }, {\n      key: \"_skipStep\",\n      value: function _skipStep(step, forward) {\n        var index = this.steps.indexOf(step);\n        if (index === this.steps.length - 1) {\n          this.complete();\n        } else {\n          var nextIndex = forward ? index + 1 : index - 1;\n          this.show(nextIndex, forward);\n        }\n      }\n      /**\n       * Before showing, hide the current step and if the tour is not\n       * already active, call `this._setupActiveTour`.\n       * @private\n       */\n    }, {\n      key: \"_updateStateBeforeShow\",\n      value: function _updateStateBeforeShow() {\n        if (this.currentStep) {\n          this.currentStep.hide();\n        }\n        if (!this.isActive()) {\n          this._setupActiveTour();\n        }\n      }\n      /**\n       * Sets this.id to `${tourName}--${uuid}`\n       * @private\n       */\n    }, {\n      key: \"_setTourID\",\n      value: function _setTourID() {\n        var tourName = this.options.tourName || 'tour';\n        this.id = \"\".concat(tourName, \"--\").concat(uuid());\n      }\n    }]);\n    return Tour;\n  }(Evented);\n  Object.assign(Shepherd, {\n    Tour: Tour,\n    Step: Step\n  });\n  return Shepherd;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hlcGhlcmQuanMvZGlzdC9qcy9zaGVwaGVyZC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQUVBLElBQUlBLGlCQUFpQixHQUFHLFNBQVNBLGlCQUFUQSxDQUEyQkMsS0FBM0IsRUFBa0M7SUFDekQsT0FBT0MsZUFBZSxDQUFDRCxLQUFELENBQWYsSUFDSCxDQUFDRSxTQUFTLENBQUNGLEtBQUQsQ0FEZDtFQUVBLENBSEQ7RUFLQSxTQUFTQyxlQUFUQSxDQUF5QkQsS0FBekIsRUFBZ0M7SUFDL0IsT0FBTyxDQUFDLENBQUNBLEtBQUYsSUFBV0csUUFBT0gsS0FBUCxNQUFpQixRQUFuQztFQUNBO0VBRUQsU0FBU0UsU0FBVEEsQ0FBbUJGLEtBQW5CLEVBQTBCO0lBQ3pCLElBQUlJLFdBQVcsR0FBR0MsTUFBTSxDQUFDQyxTQUFQLENBQWlCQyxRQUFqQixDQUEwQkMsSUFBMUIsQ0FBK0JSLEtBQS9CLENBQWxCO0lBRUEsT0FBT0ksV0FBVyxLQUFLLGlCQUFoQixJQUNIQSxXQUFXLEtBQUssZUFEYixJQUVISyxjQUFjLENBQUNULEtBQUQsQ0FGbEI7RUFHQTs7RUFHRCxJQUFJVSxZQUFZLEdBQUcsT0FBT0MsTUFBUCxLQUFrQixVQUFsQixJQUFnQ0EsTUFBTSxDQUFDQyxHQUExRDtFQUNBLElBQUlDLGtCQUFrQixHQUFHSCxZQUFZLEdBQUdDLE1BQU0sQ0FBQ0MsR0FBUCxDQUFXLGVBQVgsQ0FBSCxHQUFpQyxNQUF0RTtFQUVBLFNBQVNILGNBQVRBLENBQXdCVCxLQUF4QixFQUErQjtJQUM5QixPQUFPQSxLQUFLLENBQUNjLFFBQU4sS0FBbUJELGtCQUExQjtFQUNBO0VBRUQsU0FBU0UsV0FBVEEsQ0FBcUJDLEdBQXJCLEVBQTBCO0lBQ3pCLE9BQU9DLEtBQUssQ0FBQ0MsT0FBTixDQUFjRixHQUFkLENBQXFCLEtBQXJCLEdBQTBCLEVBQWpDO0VBQ0E7RUFFRCxTQUFTRyw2QkFBVEEs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QVIsQ0FBeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvZGVlcG1lcmdlL2Rpc3QvY2pzLmpzPzVhZDEiLCJ3ZWJwYWNrOi8vTWF0ZXJpYWxpemUvLi4vLi4vc3JjL2pzL3V0aWxzL3R5cGUtY2hlY2suanM/MWZkMyIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9zcmMvanMvZXZlbnRlZC5qcz85NzNkIiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL3NyYy9qcy91dGlscy9hdXRvLWJpbmQuanM/N2IxNiIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9zcmMvanMvdXRpbHMvYmluZC5qcz9hNTE1Iiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanM/NDY5NyIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlTmFtZS5qcz85MDYwIiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qcz85YTk0Iiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanM/N2NmOCIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcHBseVN0eWxlcy5qcz8xMmViIiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qcz8xNTdkIiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qcz8zYjhjIiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcz9kZDE0Iiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanM/NzgwMyIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcz81ODEwIiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanM/MDkwOCIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1RhYmxlRWxlbWVudC5qcz8zN2Q0Iiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qcz8zODQ4Iiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFBhcmVudE5vZGUuanM/ZTA4OSIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanM/NTgyYSIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qcz81ZDBiIiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvd2l0aGluLmpzP2QwOTMiLCJ3ZWJwYWNrOi8vTWF0ZXJpYWxpemUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanM/ZDA3ZiIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcz84MGY1Iiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzPzU0MTEiLCJ3ZWJwYWNrOi8vTWF0ZXJpYWxpemUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXJyb3cuanM/ZDEzMCIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qcz9jMDFmIiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanM/NjM5MSIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qcz83OTM1Iiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanM/YTAwNiIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzP2Y4MWUiLCJ3ZWJwYWNrOi8vTWF0ZXJpYWxpemUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsLmpzPzhhNzAiLCJ3ZWJwYWNrOi8vTWF0ZXJpYWxpemUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcz82NmQzIiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFZpZXdwb3J0UmVjdC5qcz9kN2ZlIiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50UmVjdC5qcz8zMzFlIiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzPzc4NjMiLCJ3ZWJwYWNrOi8vTWF0ZXJpYWxpemUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0U2Nyb2xsUGFyZW50LmpzP2EzMmEiLCJ3ZWJwYWNrOi8vTWF0ZXJpYWxpemUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanM/NmY1OSIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanM/OWMzOSIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanM/ZDE2ZCIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzPzRlNzUiLCJ3ZWJwYWNrOi8vTWF0ZXJpYWxpemUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcz9iNTM0Iiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanM/MmVhMSIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9mbGlwLmpzP2RiNDgiLCJ3ZWJwYWNrOi8vTWF0ZXJpYWxpemUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qcz9hYjk3Iiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL29mZnNldC5qcz9jMzY5Iiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanM/NTgwMSIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEFsdEF4aXMuanM/ZDhjNyIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanM/Zjk4ZSIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRIVE1MRWxlbWVudFNjcm9sbC5qcz9iN2U2Iiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVTY3JvbGwuanM/NjZjZiIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzP2RkMmEiLCJ3ZWJwYWNrOi8vTWF0ZXJpYWxpemUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9vcmRlck1vZGlmaWVycy5qcz9jZmFiIiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGVib3VuY2UuanM/YjgwYiIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlQnlOYW1lLmpzP2IwNjkiLCJ3ZWJwYWNrOi8vTWF0ZXJpYWxpemUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9jcmVhdGVQb3BwZXIuanM/YTkwMCIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qcz81MTVlIiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL3NyYy9qcy91dGlscy9wb3BwZXItb3B0aW9ucy5qcz9jNjliIiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL3NyYy9qcy91dGlscy9nZW5lcmFsLmpzP2I0MmQiLCJ3ZWJwYWNrOi8vTWF0ZXJpYWxpemUvLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS9pbnRlcm5hbC9pbmRleC5tanM/MDRmNyIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1idXR0b24uc3ZlbHRlPzc4YzUiLCJ3ZWJwYWNrOi8vTWF0ZXJpYWxpemUvLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtZm9vdGVyLnN2ZWx0ZT9hZjQ3Iiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLWNhbmNlbC1pY29uLnN2ZWx0ZT83OWMxIiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLXRpdGxlLnN2ZWx0ZT9jYWMyIiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLWhlYWRlci5zdmVsdGU/MmYyNyIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC10ZXh0LnN2ZWx0ZT9hY2VmIiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLWNvbnRlbnQuc3ZlbHRlP2YwN2UiLCJ3ZWJwYWNrOi8vTWF0ZXJpYWxpemUvLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtZWxlbWVudC5zdmVsdGU/YjU4NiIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9ub2RlX21vZHVsZXMvc21vb3Roc2Nyb2xsLXBvbHlmaWxsL2Rpc3Qvc21vb3Roc2Nyb2xsLmpzP2U2YzgiLCJ3ZWJwYWNrOi8vTWF0ZXJpYWxpemUvLi4vLi4vc3JjL2pzL3N0ZXAuanM/YWQ4ZCIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9zcmMvanMvdXRpbHMvY2xlYW51cC5qcz82ZGNhIiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL3NyYy9qcy91dGlscy9vdmVybGF5LXBhdGguanM/Y2Q1MyIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1tb2RhbC5zdmVsdGU/ZjU0YiIsIndlYnBhY2s6Ly9NYXRlcmlhbGl6ZS8uLi8uLi9zcmMvanMvdG91ci5qcz8zOTUxIiwid2VicGFjazovL01hdGVyaWFsaXplLy4uLy4uL3NyYy9qcy9zaGVwaGVyZC5qcz81MTQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGlzTWVyZ2VhYmxlT2JqZWN0ID0gZnVuY3Rpb24gaXNNZXJnZWFibGVPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSlcblx0XHQmJiAhaXNTcGVjaWFsKHZhbHVlKVxufTtcblxuZnVuY3Rpb24gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbn1cblxuZnVuY3Rpb24gaXNTcGVjaWFsKHZhbHVlKSB7XG5cdHZhciBzdHJpbmdWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cblx0cmV0dXJuIHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBSZWdFeHBdJ1xuXHRcdHx8IHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBEYXRlXSdcblx0XHR8fCBpc1JlYWN0RWxlbWVudCh2YWx1ZSlcbn1cblxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I1YWM5NjNmYjc5MWQxMjk4ZTdmMzk2MjM2MzgzYmM5NTVmOTE2YzEvc3JjL2lzb21vcnBoaWMvY2xhc3NpYy9lbGVtZW50L1JlYWN0RWxlbWVudC5qcyNMMjEtTDI1XG52YXIgY2FuVXNlU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGNhblVzZVN5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcblxuZnVuY3Rpb24gaXNSZWFjdEVsZW1lbnQodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbn1cblxuZnVuY3Rpb24gZW1wdHlUYXJnZXQodmFsKSB7XG5cdHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyBbXSA6IHt9XG59XG5cbmZ1bmN0aW9uIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHZhbHVlLCBvcHRpb25zKSB7XG5cdHJldHVybiAob3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkpXG5cdFx0PyBkZWVwbWVyZ2UoZW1wdHlUYXJnZXQodmFsdWUpLCB2YWx1ZSwgb3B0aW9ucylcblx0XHQ6IHZhbHVlXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRBcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHJldHVybiB0YXJnZXQuY29uY2F0KHNvdXJjZSkubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoZWxlbWVudCwgb3B0aW9ucylcblx0fSlcbn1cblxuZnVuY3Rpb24gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcblx0aWYgKCFvcHRpb25zLmN1c3RvbU1lcmdlKSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZVxuXHR9XG5cdHZhciBjdXN0b21NZXJnZSA9IG9wdGlvbnMuY3VzdG9tTWVyZ2Uoa2V5KTtcblx0cmV0dXJuIHR5cGVvZiBjdXN0b21NZXJnZSA9PT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbU1lcmdlIDogZGVlcG1lcmdlXG59XG5cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzXG5cdFx0PyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkuZmlsdGVyKGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5wcm9wZXJ0eUlzRW51bWVyYWJsZShzeW1ib2wpXG5cdFx0fSlcblx0XHQ6IFtdXG59XG5cbmZ1bmN0aW9uIGdldEtleXModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXQpLmNvbmNhdChnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpXG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5SXNPbk9iamVjdChvYmplY3QsIHByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHByb3BlcnR5IGluIG9iamVjdFxuXHR9IGNhdGNoKF8pIHtcblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxufVxuXG4vLyBQcm90ZWN0cyBmcm9tIHByb3RvdHlwZSBwb2lzb25pbmcgYW5kIHVuZXhwZWN0ZWQgbWVyZ2luZyB1cCB0aGUgcHJvdG90eXBlIGNoYWluLlxuZnVuY3Rpb24gcHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkge1xuXHRyZXR1cm4gcHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAvLyBQcm9wZXJ0aWVzIGFyZSBzYWZlIHRvIG1lcmdlIGlmIHRoZXkgZG9uJ3QgZXhpc3QgaW4gdGhlIHRhcmdldCB5ZXQsXG5cdFx0JiYgIShPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkgLy8gdW5zYWZlIGlmIHRoZXkgZXhpc3QgdXAgdGhlIHByb3RvdHlwZSBjaGFpbixcblx0XHRcdCYmIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldCwga2V5KSkgLy8gYW5kIGFsc28gdW5zYWZlIGlmIHRoZXkncmUgbm9uZW51bWVyYWJsZS5cbn1cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0dmFyIGRlc3RpbmF0aW9uID0ge307XG5cdGlmIChvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHRhcmdldCkpIHtcblx0XHRnZXRLZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh0YXJnZXRba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSk7XG5cdH1cblx0Z2V0S2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0aWYgKHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHRpZiAocHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGdldE1lcmdlRnVuY3Rpb24oa2V5LCBvcHRpb25zKSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBkZXN0aW5hdGlvblxufVxuXG5mdW5jdGlvbiBkZWVwbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdG9wdGlvbnMuYXJyYXlNZXJnZSA9IG9wdGlvbnMuYXJyYXlNZXJnZSB8fCBkZWZhdWx0QXJyYXlNZXJnZTtcblx0b3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCA9IG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgfHwgaXNNZXJnZWFibGVPYmplY3Q7XG5cdC8vIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkIGlzIGFkZGVkIHRvIGBvcHRpb25zYCBzbyB0aGF0IGN1c3RvbSBhcnJheU1lcmdlKClcblx0Ly8gaW1wbGVtZW50YXRpb25zIGNhbiB1c2UgaXQuIFRoZSBjYWxsZXIgbWF5IG5vdCByZXBsYWNlIGl0LlxuXHRvcHRpb25zLmNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQ7XG5cblx0dmFyIHNvdXJjZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHNvdXJjZSk7XG5cdHZhciB0YXJnZXRJc0FycmF5ID0gQXJyYXkuaXNBcnJheSh0YXJnZXQpO1xuXHR2YXIgc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCA9IHNvdXJjZUlzQXJyYXkgPT09IHRhcmdldElzQXJyYXk7XG5cblx0aWYgKCFzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoKSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIGlmIChzb3VyY2VJc0FycmF5KSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMuYXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH1cbn1cblxuZGVlcG1lcmdlLmFsbCA9IGZ1bmN0aW9uIGRlZXBtZXJnZUFsbChhcnJheSwgb3B0aW9ucykge1xuXHRpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYW4gYXJyYXknKVxuXHR9XG5cblx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihwcmV2LCBuZXh0KSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZShwcmV2LCBuZXh0LCBvcHRpb25zKVxuXHR9LCB7fSlcbn07XG5cbnZhciBkZWVwbWVyZ2VfMSA9IGRlZXBtZXJnZTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwbWVyZ2VfMTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgRWxlbWVudGAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyBhbiBFbGVtZW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBIVE1MRWxlbWVudGAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyBhbiBIVE1MRWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIVE1MRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyBhIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBhcmFtIHRvIGNoZWNrIGlmIGl0IGlzIGEgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB1bmRlZmluZWQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuIiwiaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICcuL3V0aWxzL3R5cGUtY2hlY2snO1xuXG5leHBvcnQgY2xhc3MgRXZlbnRlZCB7XG4gIG9uKGV2ZW50LCBoYW5kbGVyLCBjdHgsIG9uY2UgPSBmYWxzZSkge1xuICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLmJpbmRpbmdzKSkge1xuICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgIH1cbiAgICBpZiAoaXNVbmRlZmluZWQodGhpcy5iaW5kaW5nc1tldmVudF0pKSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5wdXNoKHsgaGFuZGxlciwgY3R4LCBvbmNlIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBvbmNlKGV2ZW50LCBoYW5kbGVyLCBjdHgpIHtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudCwgaGFuZGxlciwgY3R4LCB0cnVlKTtcbiAgfVxuXG4gIG9mZihldmVudCwgaGFuZGxlcikge1xuICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLmJpbmRpbmdzKSB8fCBpc1VuZGVmaW5lZCh0aGlzLmJpbmRpbmdzW2V2ZW50XSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSkge1xuICAgICAgZGVsZXRlIHRoaXMuYmluZGluZ3NbZXZlbnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5mb3JFYWNoKChiaW5kaW5nLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoYmluZGluZy5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0cmlnZ2VyKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLmJpbmRpbmdzKSAmJiB0aGlzLmJpbmRpbmdzW2V2ZW50XSkge1xuICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0uZm9yRWFjaCgoYmluZGluZywgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdHgsIGhhbmRsZXIsIG9uY2UgfSA9IGJpbmRpbmc7XG5cbiAgICAgICAgY29uc3QgY29udGV4dCA9IGN0eCB8fCB0aGlzO1xuXG4gICAgICAgIGhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncyk7XG5cbiAgICAgICAgaWYgKG9uY2UpIHtcbiAgICAgICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuIiwiLyoqXG4gKiBCaW5kcyBhbGwgdGhlIG1ldGhvZHMgb24gYSBKUyBDbGFzcyB0byB0aGUgYHRoaXNgIGNvbnRleHQgb2YgdGhlIGNsYXNzLlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvYXV0by1iaW5kXG4gKiBAcGFyYW0ge29iamVjdH0gc2VsZiBUaGUgYHRoaXNgIGNvbnRleHQgb2YgdGhlIGNsYXNzXG4gKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBgdGhpc2AgY29udGV4dCBvZiB0aGUgY2xhc3NcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXV0b0JpbmQoc2VsZikge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc2VsZi5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGNvbnN0IHZhbCA9IHNlbGZba2V5XTtcbiAgICBpZiAoa2V5ICE9PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNlbGZba2V5XSA9IHZhbC5iaW5kKHNlbGYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuIiwiaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICcuL3R5cGUtY2hlY2snO1xuXG4vKipcbiAqIFNldHMgdXAgdGhlIGhhbmRsZXIgdG8gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBhZHZhbmNlIHRoZSB0b3VyXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfc2V0dXBBZHZhbmNlT25IYW5kbGVyKHNlbGVjdG9yLCBzdGVwKSB7XG4gIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICBpZiAoc3RlcC5pc09wZW4oKSkge1xuICAgICAgY29uc3QgdGFyZ2V0SXNFbCA9IHN0ZXAuZWwgJiYgZXZlbnQuY3VycmVudFRhcmdldCA9PT0gc3RlcC5lbDtcbiAgICAgIGNvbnN0IHRhcmdldElzU2VsZWN0b3IgPVxuICAgICAgICAhaXNVbmRlZmluZWQoc2VsZWN0b3IpICYmIGV2ZW50LmN1cnJlbnRUYXJnZXQubWF0Y2hlcyhzZWxlY3Rvcik7XG5cbiAgICAgIGlmICh0YXJnZXRJc1NlbGVjdG9yIHx8IHRhcmdldElzRWwpIHtcbiAgICAgICAgc3RlcC50b3VyLm5leHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQmluZCB0aGUgZXZlbnQgaGFuZGxlciBmb3IgYWR2YW5jZU9uXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmRBZHZhbmNlKHN0ZXApIHtcbiAgLy8gQW4gZW1wdHkgc2VsZWN0b3IgbWF0Y2hlcyB0aGUgc3RlcCBlbGVtZW50XG4gIGNvbnN0IHsgZXZlbnQsIHNlbGVjdG9yIH0gPSBzdGVwLm9wdGlvbnMuYWR2YW5jZU9uIHx8IHt9O1xuICBpZiAoZXZlbnQpIHtcbiAgICBjb25zdCBoYW5kbGVyID0gX3NldHVwQWR2YW5jZU9uSGFuZGxlcihzZWxlY3Rvciwgc3RlcCk7XG5cbiAgICAvLyBUT0RPOiB0aGlzIHNob3VsZCBhbHNvIGJpbmQvdW5iaW5kIG9uIHNob3cvaGlkZVxuICAgIGxldCBlbDtcbiAgICB0cnkge1xuICAgICAgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBUT0RPXG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoc2VsZWN0b3IpICYmICFlbCkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGBObyBlbGVtZW50IHdhcyBmb3VuZCBmb3IgdGhlIHNlbGVjdG9yIHN1cHBsaWVkIHRvIGFkdmFuY2VPbjogJHtzZWxlY3Rvcn1gXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgc3RlcC5vbignZGVzdHJveScsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgdHJ1ZSk7XG4gICAgICBzdGVwLm9uKCdkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29uc29sZS5lcnJvcihcbiAgICAgICdhZHZhbmNlT24gd2FzIGRlZmluZWQsIGJ1dCBubyBldmVudCBuYW1lIHdhcyBwYXNzZWQuJ1xuICAgICk7XG4gIH1cbn1cbiIsImV4cG9ydCB2YXIgdG9wID0gJ3RvcCc7XG5leHBvcnQgdmFyIGJvdHRvbSA9ICdib3R0b20nO1xuZXhwb3J0IHZhciByaWdodCA9ICdyaWdodCc7XG5leHBvcnQgdmFyIGxlZnQgPSAnbGVmdCc7XG5leHBvcnQgdmFyIGF1dG8gPSAnYXV0byc7XG5leHBvcnQgdmFyIGJhc2VQbGFjZW1lbnRzID0gW3RvcCwgYm90dG9tLCByaWdodCwgbGVmdF07XG5leHBvcnQgdmFyIHN0YXJ0ID0gJ3N0YXJ0JztcbmV4cG9ydCB2YXIgZW5kID0gJ2VuZCc7XG5leHBvcnQgdmFyIGNsaXBwaW5nUGFyZW50cyA9ICdjbGlwcGluZ1BhcmVudHMnO1xuZXhwb3J0IHZhciB2aWV3cG9ydCA9ICd2aWV3cG9ydCc7XG5leHBvcnQgdmFyIHBvcHBlciA9ICdwb3BwZXInO1xuZXhwb3J0IHZhciByZWZlcmVuY2UgPSAncmVmZXJlbmNlJztcbmV4cG9ydCB2YXIgdmFyaWF0aW9uUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9iYXNlUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pO1xuZXhwb3J0IHZhciBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL1tdLmNvbmNhdChiYXNlUGxhY2VtZW50cywgW2F1dG9dKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQsIHBsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7IC8vIG1vZGlmaWVycyB0aGF0IG5lZWQgdG8gcmVhZCB0aGUgRE9NXG5cbmV4cG9ydCB2YXIgYmVmb3JlUmVhZCA9ICdiZWZvcmVSZWFkJztcbmV4cG9ydCB2YXIgcmVhZCA9ICdyZWFkJztcbmV4cG9ydCB2YXIgYWZ0ZXJSZWFkID0gJ2FmdGVyUmVhZCc7IC8vIHB1cmUtbG9naWMgbW9kaWZpZXJzXG5cbmV4cG9ydCB2YXIgYmVmb3JlTWFpbiA9ICdiZWZvcmVNYWluJztcbmV4cG9ydCB2YXIgbWFpbiA9ICdtYWluJztcbmV4cG9ydCB2YXIgYWZ0ZXJNYWluID0gJ2FmdGVyTWFpbic7IC8vIG1vZGlmaWVyIHdpdGggdGhlIHB1cnBvc2UgdG8gd3JpdGUgdG8gdGhlIERPTSAob3Igd3JpdGUgaW50byBhIGZyYW1ld29yayBzdGF0ZSlcblxuZXhwb3J0IHZhciBiZWZvcmVXcml0ZSA9ICdiZWZvcmVXcml0ZSc7XG5leHBvcnQgdmFyIHdyaXRlID0gJ3dyaXRlJztcbmV4cG9ydCB2YXIgYWZ0ZXJXcml0ZSA9ICdhZnRlcldyaXRlJztcbmV4cG9ydCB2YXIgbW9kaWZpZXJQaGFzZXMgPSBbYmVmb3JlUmVhZCwgcmVhZCwgYWZ0ZXJSZWFkLCBiZWZvcmVNYWluLCBtYWluLCBhZnRlck1haW4sIGJlZm9yZVdyaXRlLCB3cml0ZSwgYWZ0ZXJXcml0ZV07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudCA/IChlbGVtZW50Lm5vZGVOYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xuICAvLyBJRSAxMSBoYXMgbm8gU2hhZG93Um9vdFxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuU2hhZG93Um9vdDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuXG5leHBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9OyIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7IC8vIFRoaXMgbW9kaWZpZXIgdGFrZXMgdGhlIHN0eWxlcyBwcmVwYXJlZCBieSB0aGUgYGNvbXB1dGVTdHlsZXNgIG1vZGlmaWVyXG4vLyBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSBIVE1MRWxlbWVudHMgc3VjaCBhcyBwb3BwZXIgYW5kIGFycm93XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGVzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcbiAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS5zdHlsZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdG8gZXh0ZW5kIHRoaXMgcHJvcGVydHksIGJ1dCBpdCdzIHRoZSBtb3N0XG4gICAgLy8gZWZmZWN0aXZlIHdheSB0byBhcHBseSBzdHlsZXMgdG8gYW4gSFRNTEVsZW1lbnRcbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cblxuXG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcbiAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXG5cbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBhcHBseVN0eWxlcyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXVxufTsiLCJpbXBvcnQgeyBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59IiwiZXhwb3J0IHZhciBtYXggPSBNYXRoLm1heDtcbmV4cG9ydCB2YXIgbWluID0gTWF0aC5taW47XG5leHBvcnQgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDsiLCJpbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGluY2x1ZGVTY2FsZSkge1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuXG4gIGlmIChpc0hUTUxFbGVtZW50KGVsZW1lbnQpICYmIGluY2x1ZGVTY2FsZSkge1xuICAgIHZhciBvZmZzZXRIZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICB2YXIgb2Zmc2V0V2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoOyAvLyBEbyBub3QgYXR0ZW1wdCB0byBkaXZpZGUgYnkgMCwgb3RoZXJ3aXNlIHdlIGdldCBgSW5maW5pdHlgIGFzIHNjYWxlXG4gICAgLy8gRmFsbGJhY2sgdG8gMSBpbiBjYXNlIGJvdGggdmFsdWVzIGFyZSBgMGBcblxuICAgIGlmIChvZmZzZXRXaWR0aCA+IDApIHtcbiAgICAgIHNjYWxlWCA9IHJvdW5kKHJlY3Qud2lkdGgpIC8gb2Zmc2V0V2lkdGggfHwgMTtcbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0SGVpZ2h0ID4gMCkge1xuICAgICAgc2NhbGVZID0gcm91bmQocmVjdC5oZWlnaHQpIC8gb2Zmc2V0SGVpZ2h0IHx8IDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCAvIHNjYWxlWCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0IC8gc2NhbGVZLFxuICAgIHRvcDogcmVjdC50b3AgLyBzY2FsZVksXG4gICAgcmlnaHQ6IHJlY3QucmlnaHQgLyBzY2FsZVgsXG4gICAgYm90dG9tOiByZWN0LmJvdHRvbSAvIHNjYWxlWSxcbiAgICBsZWZ0OiByZWN0LmxlZnQgLyBzY2FsZVgsXG4gICAgeDogcmVjdC5sZWZ0IC8gc2NhbGVYLFxuICAgIHk6IHJlY3QudG9wIC8gc2NhbGVZXG4gIH07XG59IiwiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjsgLy8gUmV0dXJucyB0aGUgbGF5b3V0IHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LiBMYXlvdXRcbi8vIG1lYW5zIGl0IGRvZXNuJ3QgdGFrZSBpbnRvIGFjY291bnQgdHJhbnNmb3Jtcy5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TGF5b3V0UmVjdChlbGVtZW50KSB7XG4gIHZhciBjbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpOyAvLyBVc2UgdGhlIGNsaWVudFJlY3Qgc2l6ZXMgaWYgaXQncyBub3QgYmVlbiB0cmFuc2Zvcm1lZC5cbiAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMjIzXG5cbiAgdmFyIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LndpZHRoIC0gd2lkdGgpIDw9IDEpIHtcbiAgICB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC5oZWlnaHQgLSBoZWlnaHQpIDw9IDEpIHtcbiAgICBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgIHk6IGVsZW1lbnQub2Zmc2V0VG9wLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufSIsImltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgZWxzZSBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgICAgdmFyIG5leHQgPSBjaGlsZDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cblxuXG4gICAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgICAgfSB3aGlsZSAobmV4dCk7XG4gICAgfSAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG5cblxuICByZXR1cm4gZmFsc2U7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59IiwiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5kZXhPZihnZXROb2RlTmFtZShlbGVtZW50KSkgPj0gMDtcbn0iLCJpbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gIHJldHVybiAoKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICBlbGVtZW50LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn0iLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiAoLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgZWxlbWVudC5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICBlbGVtZW50LnBhcmVudE5vZGUgfHwgKCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIGlzU2hhZG93Um9vdChlbGVtZW50KSA/IGVsZW1lbnQuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIC8vIGZhbGxiYWNrXG5cbiAgKTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgaXNUYWJsZUVsZW1lbnQgZnJvbSBcIi4vaXNUYWJsZUVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59IC8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXG4vLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcblxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICB2YXIgaXNGaXJlZm94ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSAhPT0gLTE7XG4gIHZhciBpc0lFID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdUcmlkZW50JykgIT09IC0xO1xuXG4gIGlmIChpc0lFICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAvLyBJbiBJRSA5LCAxMCBhbmQgMTEgZml4ZWQgZWxlbWVudHMgY29udGFpbmluZyBibG9jayBpcyBhbHdheXMgZXN0YWJsaXNoZWQgYnkgdGhlIHZpZXdwb3J0XG4gICAgdmFyIGVsZW1lbnRDc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgaWYgKGVsZW1lbnRDc3MucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG5cbiAgaWYgKGlzU2hhZG93Um9vdChjdXJyZW50Tm9kZSkpIHtcbiAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLmhvc3Q7XG4gIH1cblxuICB3aGlsZSAoaXNIVE1MRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgWydodG1sJywgJ2JvZHknXS5pbmRleE9mKGdldE5vZGVOYW1lKGN1cnJlbnROb2RlKSkgPCAwKSB7XG4gICAgdmFyIGNzcyA9IGdldENvbXB1dGVkU3R5bGUoY3VycmVudE5vZGUpOyAvLyBUaGlzIGlzIG5vbi1leGhhdXN0aXZlIGJ1dCBjb3ZlcnMgdGhlIG1vc3QgY29tbW9uIENTUyBwcm9wZXJ0aWVzIHRoYXRcbiAgICAvLyBjcmVhdGUgYSBjb250YWluaW5nIGJsb2NrLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG5cbiAgICBpZiAoY3NzLnRyYW5zZm9ybSAhPT0gJ25vbmUnIHx8IGNzcy5wZXJzcGVjdGl2ZSAhPT0gJ25vbmUnIHx8IGNzcy5jb250YWluID09PSAncGFpbnQnIHx8IFsndHJhbnNmb3JtJywgJ3BlcnNwZWN0aXZlJ10uaW5kZXhPZihjc3Mud2lsbENoYW5nZSkgIT09IC0xIHx8IGlzRmlyZWZveCAmJiBjc3Mud2lsbENoYW5nZSA9PT0gJ2ZpbHRlcicgfHwgaXNGaXJlZm94ICYmIGNzcy5maWx0ZXIgJiYgY3NzLmZpbHRlciAhPT0gJ25vbmUnKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn0gLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KTtcblxuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luZG93O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xufSIsImltcG9ydCB7IG1heCBhcyBtYXRoTWF4LCBtaW4gYXMgbWF0aE1pbiB9IGZyb20gXCIuL21hdGguanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KSB7XG4gIHJldHVybiBtYXRoTWF4KG1pbiwgbWF0aE1pbih2YWx1ZSwgbWF4KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2l0aGluTWF4Q2xhbXAobWluLCB2YWx1ZSwgbWF4KSB7XG4gIHZhciB2ID0gd2l0aGluKG1pbiwgdmFsdWUsIG1heCk7XG4gIHJldHVybiB2ID4gbWF4ID8gbWF4IDogdjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRGcmVzaFNpZGVPYmplY3QoKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59IiwiaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChwYWRkaW5nT2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSwgcGFkZGluZ09iamVjdCk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn0iLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgY29udGFpbnMgZnJvbSBcIi4uL2RvbS11dGlscy9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB3aXRoaW4gfSBmcm9tIFwiLi4vdXRpbHMvd2l0aGluLmpzXCI7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gXCIuLi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4uL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qc1wiO1xuaW1wb3J0IHsgbGVmdCwgcmlnaHQsIGJhc2VQbGFjZW1lbnRzLCB0b3AsIGJvdHRvbSB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciB0b1BhZGRpbmdPYmplY3QgPSBmdW5jdGlvbiB0b1BhZGRpbmdPYmplY3QocGFkZGluZywgc3RhdGUpIHtcbiAgcGFkZGluZyA9IHR5cGVvZiBwYWRkaW5nID09PSAnZnVuY3Rpb24nID8gcGFkZGluZyhPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHBhZGRpbmc7XG4gIHJldHVybiBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xufTtcblxuZnVuY3Rpb24gYXJyb3coX3JlZikge1xuICB2YXIgX3N0YXRlJG1vZGlmaWVyc0RhdGEkO1xuXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwO1xuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBpZiAoIWFycm93RWxlbWVudCB8fCAhcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gdG9QYWRkaW5nT2JqZWN0KG9wdGlvbnMucGFkZGluZywgc3RhdGUpO1xuICB2YXIgYXJyb3dSZWN0ID0gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpO1xuICB2YXIgbWluUHJvcCA9IGF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gIHZhciBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gIHZhciBlbmREaWZmID0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2xlbl0gKyBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucG9wcGVyW2xlbl07XG4gIHZhciBzdGFydERpZmYgPSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoYXJyb3dFbGVtZW50KTtcbiAgdmFyIGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMCA6IDA7XG4gIHZhciBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjsgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBwb3BwZXIgaWYgdGhlIGNlbnRlciBwb2ludCBpc1xuICAvLyBvdXRzaWRlIG9mIHRoZSBwb3BwZXIgYm91bmRzXG5cbiAgdmFyIG1pbiA9IHBhZGRpbmdPYmplY3RbbWluUHJvcF07XG4gIHZhciBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dSZWN0W2xlbl0gLSBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICB2YXIgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd1JlY3RbbGVuXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgdmFyIG9mZnNldCA9IHdpdGhpbihtaW4sIGNlbnRlciwgbWF4KTsgLy8gUHJldmVudHMgYnJlYWtpbmcgc3ludGF4IGhpZ2hsaWdodGluZy4uLlxuXG4gIHZhciBheGlzUHJvcCA9IGF4aXM7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSAoX3N0YXRlJG1vZGlmaWVyc0RhdGEkID0ge30sIF9zdGF0ZSRtb2RpZmllcnNEYXRhJFtheGlzUHJvcF0gPSBvZmZzZXQsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJC5jZW50ZXJPZmZzZXQgPSBvZmZzZXQgLSBjZW50ZXIsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJCk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudCxcbiAgICAgIGFycm93RWxlbWVudCA9IF9vcHRpb25zJGVsZW1lbnQgPT09IHZvaWQgMCA/ICdbZGF0YS1wb3BwZXItYXJyb3ddJyA6IF9vcHRpb25zJGVsZW1lbnQ7XG5cbiAgaWYgKGFycm93RWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIENTUyBzZWxlY3RvclxuXG5cbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghaXNIVE1MRWxlbWVudChhcnJvd0VsZW1lbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImFycm93XCIgZWxlbWVudCBtdXN0IGJlIGFuIEhUTUxFbGVtZW50IChub3QgYW4gU1ZHRWxlbWVudCkuJywgJ1RvIHVzZSBhbiBTVkcgYXJyb3csIHdyYXAgaXQgaW4gYW4gSFRNTEVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgYXMnLCAndGhlIGFycm93LiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb250YWlucyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIsIGFycm93RWxlbWVudCkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImFycm93XCIgbW9kaWZpZXJcXCdzIGBlbGVtZW50YCBtdXN0IGJlIGEgY2hpbGQgb2YgdGhlIHBvcHBlcicsICdlbGVtZW50LiddLmpvaW4oJyAnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXVxufTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn0iLCJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIGVuZCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHVuc2V0U2lkZXMgPSB7XG4gIHRvcDogJ2F1dG8nLFxuICByaWdodDogJ2F1dG8nLFxuICBib3R0b206ICdhdXRvJyxcbiAgbGVmdDogJ2F1dG8nXG59OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuXG5mdW5jdGlvbiByb3VuZE9mZnNldHNCeURQUihfcmVmKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcbiAgdmFyIHdpbiA9IHdpbmRvdztcbiAgdmFyIGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiB7XG4gICAgeDogcm91bmQoeCAqIGRwcikgLyBkcHIgfHwgMCxcbiAgICB5OiByb3VuZCh5ICogZHByKSAvIGRwciB8fCAwXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb1N0eWxlcyhfcmVmMikge1xuICB2YXIgX09iamVjdCRhc3NpZ24yO1xuXG4gIHZhciBwb3BwZXIgPSBfcmVmMi5wb3BwZXIsXG4gICAgICBwb3BwZXJSZWN0ID0gX3JlZjIucG9wcGVyUmVjdCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYyLnBsYWNlbWVudCxcbiAgICAgIHZhcmlhdGlvbiA9IF9yZWYyLnZhcmlhdGlvbixcbiAgICAgIG9mZnNldHMgPSBfcmVmMi5vZmZzZXRzLFxuICAgICAgcG9zaXRpb24gPSBfcmVmMi5wb3NpdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9yZWYyLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGFkYXB0aXZlID0gX3JlZjIuYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHMgPSBfcmVmMi5yb3VuZE9mZnNldHMsXG4gICAgICBpc0ZpeGVkID0gX3JlZjIuaXNGaXhlZDtcbiAgdmFyIF9vZmZzZXRzJHggPSBvZmZzZXRzLngsXG4gICAgICB4ID0gX29mZnNldHMkeCA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHgsXG4gICAgICBfb2Zmc2V0cyR5ID0gb2Zmc2V0cy55LFxuICAgICAgeSA9IF9vZmZzZXRzJHkgPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR5O1xuXG4gIHZhciBfcmVmMyA9IHR5cGVvZiByb3VuZE9mZnNldHMgPT09ICdmdW5jdGlvbicgPyByb3VuZE9mZnNldHMoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9KSA6IHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcblxuICB4ID0gX3JlZjMueDtcbiAgeSA9IF9yZWYzLnk7XG4gIHZhciBoYXNYID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneCcpO1xuICB2YXIgaGFzWSA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3knKTtcbiAgdmFyIHNpZGVYID0gbGVmdDtcbiAgdmFyIHNpZGVZID0gdG9wO1xuICB2YXIgd2luID0gd2luZG93O1xuXG4gIGlmIChhZGFwdGl2ZSkge1xuICAgIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKTtcbiAgICB2YXIgaGVpZ2h0UHJvcCA9ICdjbGllbnRIZWlnaHQnO1xuICAgIHZhciB3aWR0aFByb3AgPSAnY2xpZW50V2lkdGgnO1xuXG4gICAgaWYgKG9mZnNldFBhcmVudCA9PT0gZ2V0V2luZG93KHBvcHBlcikpIHtcbiAgICAgIG9mZnNldFBhcmVudCA9IGdldERvY3VtZW50RWxlbWVudChwb3BwZXIpO1xuXG4gICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uICE9PSAnc3RhdGljJyAmJiBwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJykge1xuICAgICAgICBoZWlnaHRQcm9wID0gJ3Njcm9sbEhlaWdodCc7XG4gICAgICAgIHdpZHRoUHJvcCA9ICdzY3JvbGxXaWR0aCc7XG4gICAgICB9XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYXN0XTogZm9yY2UgdHlwZSByZWZpbmVtZW50LCB3ZSBjb21wYXJlIG9mZnNldFBhcmVudCB3aXRoIHdpbmRvdyBhYm92ZSwgYnV0IEZsb3cgZG9lc24ndCBkZXRlY3QgaXRcblxuXG4gICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50O1xuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gdG9wIHx8IChwbGFjZW1lbnQgPT09IGxlZnQgfHwgcGxhY2VtZW50ID09PSByaWdodCkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVZID0gYm90dG9tO1xuICAgICAgdmFyIG9mZnNldFkgPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC5oZWlnaHQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFtoZWlnaHRQcm9wXTtcbiAgICAgIHkgLT0gb2Zmc2V0WSAtIHBvcHBlclJlY3QuaGVpZ2h0O1xuICAgICAgeSAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCAocGxhY2VtZW50ID09PSB0b3AgfHwgcGxhY2VtZW50ID09PSBib3R0b20pICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWCA9IHJpZ2h0O1xuICAgICAgdmFyIG9mZnNldFggPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC53aWR0aCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgb2Zmc2V0UGFyZW50W3dpZHRoUHJvcF07XG4gICAgICB4IC09IG9mZnNldFggLSBwb3BwZXJSZWN0LndpZHRoO1xuICAgICAgeCAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICB9LCBhZGFwdGl2ZSAmJiB1bnNldFNpZGVzKTtcblxuICB2YXIgX3JlZjQgPSByb3VuZE9mZnNldHMgPT09IHRydWUgPyByb3VuZE9mZnNldHNCeURQUih7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0pIDoge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xuXG4gIHggPSBfcmVmNC54O1xuICB5ID0gX3JlZjQueTtcblxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uKSB7XG4gICAgdmFyIF9PYmplY3QkYXNzaWduO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduID0ge30sIF9PYmplY3QkYXNzaWduW3NpZGVZXSA9IGhhc1kgPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ25bc2lkZVhdID0gaGFzWCA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbi50cmFuc2Zvcm0gPSAod2luLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPD0gMSA/IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCIgOiBcInRyYW5zbGF0ZTNkKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgsIDApXCIsIF9PYmplY3QkYXNzaWduKSk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24yID0ge30sIF9PYmplY3QkYXNzaWduMltzaWRlWV0gPSBoYXNZID8geSArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjJbc2lkZVhdID0gaGFzWCA/IHggKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yLnRyYW5zZm9ybSA9ICcnLCBfT2JqZWN0JGFzc2lnbjIpKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVN0eWxlcyhfcmVmNSkge1xuICB2YXIgc3RhdGUgPSBfcmVmNS5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmNS5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID0gb3B0aW9ucy5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRncHVBY2NlbGVyYXQsXG4gICAgICBfb3B0aW9ucyRhZGFwdGl2ZSA9IG9wdGlvbnMuYWRhcHRpdmUsXG4gICAgICBhZGFwdGl2ZSA9IF9vcHRpb25zJGFkYXB0aXZlID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWRhcHRpdmUsXG4gICAgICBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPSBvcHRpb25zLnJvdW5kT2Zmc2V0cyxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJvdW5kT2Zmc2V0cztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIHRyYW5zaXRpb25Qcm9wZXJ0eSA9IGdldENvbXB1dGVkU3R5bGUoc3RhdGUuZWxlbWVudHMucG9wcGVyKS50cmFuc2l0aW9uUHJvcGVydHkgfHwgJyc7XG5cbiAgICBpZiAoYWRhcHRpdmUgJiYgWyd0cmFuc2Zvcm0nLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uc29tZShmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0cmFuc2l0aW9uUHJvcGVydHkuaW5kZXhPZihwcm9wZXJ0eSkgPj0gMDtcbiAgICB9KSkge1xuICAgICAgY29uc29sZS53YXJuKFsnUG9wcGVyOiBEZXRlY3RlZCBDU1MgdHJhbnNpdGlvbnMgb24gYXQgbGVhc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcnLCAnQ1NTIHByb3BlcnRpZXM6IFwidHJhbnNmb3JtXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIuJywgJ1xcblxcbicsICdEaXNhYmxlIHRoZSBcImNvbXB1dGVTdHlsZXNcIiBtb2RpZmllclxcJ3MgYGFkYXB0aXZlYCBvcHRpb24gdG8gYWxsb3cnLCAnZm9yIHNtb290aCB0cmFuc2l0aW9ucywgb3IgcmVtb3ZlIHRoZXNlIHByb3BlcnRpZXMgZnJvbSB0aGUgQ1NTJywgJ3RyYW5zaXRpb24gZGVjbGFyYXRpb24gb24gdGhlIHBvcHBlciBlbGVtZW50IGlmIG9ubHkgdHJhbnNpdGlvbmluZycsICdvcGFjaXR5IG9yIGJhY2tncm91bmQtY29sb3IgZm9yIGV4YW1wbGUuJywgJ1xcblxcbicsICdXZSByZWNvbW1lbmQgdXNpbmcgdGhlIHBvcHBlciBlbGVtZW50IGFzIGEgd3JhcHBlciBhcm91bmQgYW4gaW5uZXInLCAnZWxlbWVudCB0aGF0IGNhbiBoYXZlIGFueSBDU1MgcHJvcGVydHkgdHJhbnNpdGlvbmVkIGZvciBhbmltYXRpb25zLiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IHtcbiAgICBwbGFjZW1lbnQ6IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KSxcbiAgICB2YXJpYXRpb246IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBncHVBY2NlbGVyYXRpb246IGdwdUFjY2VsZXJhdGlvbixcbiAgICBpc0ZpeGVkOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnXG4gIH07XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5wb3BwZXIsIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLFxuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBhZGFwdGl2ZTogYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLmFycm93LCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3csXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGFkYXB0aXZlOiBmYWxzZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcGxhY2VtZW50Jzogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICBmbjogY29tcHV0ZVN0eWxlcyxcbiAgZGF0YToge31cbn07IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciBwYXNzaXZlID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXG4gICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgZGF0YToge31cbn07IiwidmFyIGhhc2ggPSB7XG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCcsXG4gIGJvdHRvbTogJ3RvcCcsXG4gIHRvcDogJ2JvdHRvbSdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59IiwidmFyIGhhc2ggPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gIH07XG59IiwiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSB7XG4gIC8vIElmIDxodG1sPiBoYXMgYSBDU1Mgd2lkdGggZ3JlYXRlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGlzIHdpbGwgYmVcbiAgLy8gaW5jb3JyZWN0IGZvciBSVEwuXG4gIC8vIFBvcHBlciAxIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UgYW5kIG5ldmVyIGhhZCBhIGJ1ZyByZXBvcnQgc28gbGV0J3MgYXNzdW1lXG4gIC8vIGl0J3Mgbm90IGFuIGlzc3VlLiBJIGRvbid0IHRoaW5rIGFueW9uZSBldmVyIHNwZWNpZmllcyB3aWR0aCBvbiA8aHRtbD5cbiAgLy8gYW55d2F5LlxuICAvLyBCcm93c2VycyB3aGVyZSB0aGUgbGVmdCBzY3JvbGxiYXIgZG9lc24ndCBjYXVzZSBhbiBpc3N1ZSByZXBvcnQgYDBgIGZvclxuICAvLyB0aGlzIChlLmcuIEVkZ2UgMjAxOSwgSUUxMSwgU2FmYXJpKVxuICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGdldFdpbmRvd1Njcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgdmFyIHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDsgLy8gTkI6IFRoaXMgaXNuJ3Qgc3VwcG9ydGVkIG9uIGlPUyA8PSAxMi4gSWYgdGhlIGtleWJvYXJkIGlzIG9wZW4sIHRoZSBwb3BwZXJcbiAgLy8gY2FuIGJlIG9ic2N1cmVkIHVuZGVybmVhdGggaXQuXG4gIC8vIEFsc28sIGBodG1sLmNsaWVudEhlaWdodGAgYWRkcyB0aGUgYm90dG9tIGJhciBoZWlnaHQgaW4gU2FmYXJpIGlPUywgZXZlblxuICAvLyBpZiBpdCBpc24ndCBvcGVuLCBzbyBpZiB0aGlzIGlzbid0IGF2YWlsYWJsZSwgdGhlIHBvcHBlciB3aWxsIGJlIGRldGVjdGVkXG4gIC8vIHRvIG92ZXJmbG93IHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbiB0b28gZWFybHkuXG5cbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7IC8vIFVzZXMgTGF5b3V0IFZpZXdwb3J0IChsaWtlIENocm9tZTsgU2FmYXJpIGRvZXMgbm90IGN1cnJlbnRseSlcbiAgICAvLyBJbiBDaHJvbWUsIGl0IHJldHVybnMgYSB2YWx1ZSB2ZXJ5IGNsb3NlIHRvIDAgKCsvLSkgYnV0IGNvbnRhaW5zIHJvdW5kaW5nXG4gICAgLy8gZXJyb3JzIGR1ZSB0byBmbG9hdGluZyBwb2ludCBudW1iZXJzLCBzbyB3ZSBuZWVkIHRvIGNoZWNrIHByZWNpc2lvbi5cbiAgICAvLyBTYWZhcmkgcmV0dXJucyBhIG51bWJlciA8PSAwLCB1c3VhbGx5IDwgLTEgd2hlbiBwaW5jaC16b29tZWRcbiAgICAvLyBGZWF0dXJlIGRldGVjdGlvbiBmYWlscyBpbiBtb2JpbGUgZW11bGF0aW9uIG1vZGUgaW4gQ2hyb21lLlxuICAgIC8vIE1hdGguYWJzKHdpbi5pbm5lcldpZHRoIC8gdmlzdWFsVmlld3BvcnQuc2NhbGUgLSB2aXN1YWxWaWV3cG9ydC53aWR0aCkgPFxuICAgIC8vIDAuMDAxXG4gICAgLy8gRmFsbGJhY2sgaGVyZTogXCJOb3QgU2FmYXJpXCIgdXNlckFnZW50XG5cbiAgICBpZiAoIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xuICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiB4ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSxcbiAgICB5OiB5XG4gIH07XG59IiwiaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5pbXBvcnQgeyBtYXggfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiOyAvLyBHZXRzIHRoZSBlbnRpcmUgc2l6ZSBvZiB0aGUgc2Nyb2xsYWJsZSBkb2N1bWVudCBhcmVhLCBldmVuIGV4dGVuZGluZyBvdXRzaWRlXG4vLyBvZiB0aGUgYDxodG1sPmAgYW5kIGA8Ym9keT5gIHJlY3QgYm91bmRzIGlmIGhvcml6b250YWxseSBzY3JvbGxhYmxlXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB3aW5TY3JvbGwgPSBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCk7XG4gIHZhciBib2R5ID0gKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5O1xuICB2YXIgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApO1xuICB2YXIgaGVpZ2h0ID0gbWF4KGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgYm9keSA/IGJvZHkuc2Nyb2xsSGVpZ2h0IDogMCwgYm9keSA/IGJvZHkuY2xpZW50SGVpZ2h0IDogMCk7XG4gIHZhciB4ID0gLXdpblNjcm9sbC5zY3JvbGxMZWZ0ICsgZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KTtcbiAgdmFyIHkgPSAtd2luU2Nyb2xsLnNjcm9sbFRvcDtcblxuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShib2R5IHx8IGh0bWwpLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApIC0gd2lkdGg7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1Njcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIEZpcmVmb3ggd2FudHMgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcbiAgdmFyIF9nZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3csXG4gICAgICBvdmVyZmxvd1ggPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1gsXG4gICAgICBvdmVyZmxvd1kgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvd1k7XG5cbiAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCk7XG59IiwiaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZSkge1xuICBpZiAoWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5kZXhPZihnZXROb2RlTmFtZShub2RlKSkgPj0gMCkge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBpZiAoaXNIVE1MRWxlbWVudChub2RlKSAmJiBpc1Njcm9sbFBhcmVudChub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKG5vZGUpKTtcbn0iLCJpbXBvcnQgZ2V0U2Nyb2xsUGFyZW50IGZyb20gXCIuL2dldFNjcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuLypcbmdpdmVuIGEgRE9NIGVsZW1lbnQsIHJldHVybiB0aGUgbGlzdCBvZiBhbGwgc2Nyb2xsIHBhcmVudHMsIHVwIHRoZSBsaXN0IG9mIGFuY2Vzb3JzXG51bnRpbCB3ZSBnZXQgdG8gdGhlIHRvcCB3aW5kb3cgb2JqZWN0LiBUaGlzIGxpc3QgaXMgd2hhdCB3ZSBhdHRhY2ggc2Nyb2xsIGxpc3RlbmVyc1xudG8sIGJlY2F1c2UgaWYgYW55IG9mIHRoZXNlIHBhcmVudCBlbGVtZW50cyBzY3JvbGwsIHdlJ2xsIG5lZWQgdG8gcmUtY2FsY3VsYXRlIHRoZVxucmVmZXJlbmNlIGVsZW1lbnQncyBwb3NpdGlvbi5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxpc3RTY3JvbGxQYXJlbnRzKGVsZW1lbnQsIGxpc3QpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgbGlzdCA9IFtdO1xuICB9XG5cbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChlbGVtZW50KTtcbiAgdmFyIGlzQm9keSA9IHNjcm9sbFBhcmVudCA9PT0gKChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keSk7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsUGFyZW50KTtcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IFt3aW5dLmNvbmNhdCh3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzU2Nyb2xsUGFyZW50KHNjcm9sbFBhcmVudCkgPyBzY3JvbGxQYXJlbnQgOiBbXSkgOiBzY3JvbGxQYXJlbnQ7XG4gIHZhciB1cGRhdGVkTGlzdCA9IGxpc3QuY29uY2F0KHRhcmdldCk7XG4gIHJldHVybiBpc0JvZHkgPyB1cGRhdGVkTGlzdCA6IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdOiBpc0JvZHkgdGVsbHMgdXMgdGFyZ2V0IHdpbGwgYmUgYW4gSFRNTEVsZW1lbnQgaGVyZVxuICB1cGRhdGVkTGlzdC5jb25jYXQobGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZSh0YXJnZXQpKSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZWN0LCB7XG4gICAgbGVmdDogcmVjdC54LFxuICAgIHRvcDogcmVjdC55LFxuICAgIHJpZ2h0OiByZWN0LnggKyByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgfSk7XG59IiwiaW1wb3J0IHsgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRWaWV3cG9ydFJlY3QgZnJvbSBcIi4vZ2V0Vmlld3BvcnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRSZWN0IGZyb20gXCIuL2dldERvY3VtZW50UmVjdC5qc1wiO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gXCIuL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5pbXBvcnQgY29udGFpbnMgZnJvbSBcIi4vY29udGFpbnMuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4uL3V0aWxzL3JlY3RUb0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCB7IG1heCwgbWluIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTtcbiAgcmVjdC50b3AgPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICByZWN0LmxlZnQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XG4gIHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3Qud2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LmhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnggPSByZWN0LmxlZnQ7XG4gIHJlY3QueSA9IHJlY3QudG9wO1xuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgcmV0dXJuIGNsaXBwaW5nUGFyZW50ID09PSB2aWV3cG9ydCA/IHJlY3RUb0NsaWVudFJlY3QoZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQpKSA6IGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCkgOiByZWN0VG9DbGllbnRSZWN0KGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpKTtcbn0gLy8gQSBcImNsaXBwaW5nIHBhcmVudFwiIGlzIGFuIG92ZXJmbG93YWJsZSBjb250YWluZXIgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2Zcbi8vIGNsaXBwaW5nIChvciBoaWRpbmcpIG92ZXJmbG93aW5nIGVsZW1lbnRzIHdpdGggYSBwb3NpdGlvbiBkaWZmZXJlbnQgZnJvbVxuLy8gYGluaXRpYWxgXG5cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIHtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xuICB2YXIgY2FuRXNjYXBlQ2xpcHBpbmcgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uKSA+PSAwO1xuICB2YXIgY2xpcHBlckVsZW1lbnQgPSBjYW5Fc2NhcGVDbGlwcGluZyAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIDogZWxlbWVudDtcblxuICBpZiAoIWlzRWxlbWVudChjbGlwcGVyRWxlbWVudCkpIHtcbiAgICByZXR1cm4gW107XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzE0MTRcblxuXG4gIHJldHVybiBjbGlwcGluZ1BhcmVudHMuZmlsdGVyKGZ1bmN0aW9uIChjbGlwcGluZ1BhcmVudCkge1xuICAgIHJldHVybiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpICYmIGNvbnRhaW5zKGNsaXBwaW5nUGFyZW50LCBjbGlwcGVyRWxlbWVudCkgJiYgZ2V0Tm9kZU5hbWUoY2xpcHBpbmdQYXJlbnQpICE9PSAnYm9keSc7XG4gIH0pO1xufSAvLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXG4vLyBjbGlwcGluZyBwYXJlbnRzXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KGVsZW1lbnQsIGJvdW5kYXJ5LCByb290Qm91bmRhcnkpIHtcbiAgdmFyIG1haW5DbGlwcGluZ1BhcmVudHMgPSBib3VuZGFyeSA9PT0gJ2NsaXBwaW5nUGFyZW50cycgPyBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkgOiBbXS5jb25jYXQoYm91bmRhcnkpO1xuICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gW10uY29uY2F0KG1haW5DbGlwcGluZ1BhcmVudHMsIFtyb290Qm91bmRhcnldKTtcbiAgdmFyIGZpcnN0Q2xpcHBpbmdQYXJlbnQgPSBjbGlwcGluZ1BhcmVudHNbMF07XG4gIHZhciBjbGlwcGluZ1JlY3QgPSBjbGlwcGluZ1BhcmVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2NSZWN0LCBjbGlwcGluZ1BhcmVudCkge1xuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQpKTtcbiAgY2xpcHBpbmdSZWN0LndpZHRoID0gY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC5oZWlnaHQgPSBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgY2xpcHBpbmdSZWN0LnggPSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LnkgPSBjbGlwcGluZ1JlY3QudG9wO1xuICByZXR1cm4gY2xpcHBpbmdSZWN0O1xufSIsImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCBzdGFydCwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gIHZhciBvZmZzZXRzO1xuXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBib3R0b206XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBlbmQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufSIsImltcG9ydCBnZXRDbGlwcGluZ1JlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4vcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgY2xpcHBpbmdQYXJlbnRzLCByZWZlcmVuY2UsIHBvcHBlciwgYm90dG9tLCB0b3AsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4vZXhwYW5kVG9IYXNoTWFwLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcbiAgICAgIF9vcHRpb25zJGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zJGJvdW5kYXJ5ID09PSB2b2lkIDAgPyBjbGlwcGluZ1BhcmVudHMgOiBfb3B0aW9ucyRib3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9PT0gdm9pZCAwID8gdmlld3BvcnQgOiBfb3B0aW9ucyRyb290Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRlbGVtZW50Q29udGUgPSBfb3B0aW9ucy5lbGVtZW50Q29udGV4dCxcbiAgICAgIGVsZW1lbnRDb250ZXh0ID0gX29wdGlvbnMkZWxlbWVudENvbnRlID09PSB2b2lkIDAgPyBwb3BwZXIgOiBfb3B0aW9ucyRlbGVtZW50Q29udGUsXG4gICAgICBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9IF9vcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zJHBhZGRpbmcgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRwYWRkaW5nO1xuICB2YXIgcGFkZGluZ09iamVjdCA9IG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG4gIHZhciBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHJlZmVyZW5jZSA6IHBvcHBlcjtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xuICB2YXIgY2xpcHBpbmdDbGllbnRSZWN0ID0gZ2V0Q2xpcHBpbmdSZWN0KGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IGdldERvY3VtZW50RWxlbWVudChzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5KTtcbiAgdmFyIHJlZmVyZW5jZUNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSk7XG4gIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJSZWN0LCBwb3BwZXJPZmZzZXRzKSk7XG4gIHZhciBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDsgLy8gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgcmVjdFxuICAvLyAwIG9yIG5lZ2F0aXZlID0gd2l0aGluIHRoZSBjbGlwcGluZyByZWN0XG5cbiAgdmFyIG92ZXJmbG93T2Zmc2V0cyA9IHtcbiAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcbiAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXG4gICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxuICB9O1xuICB2YXIgb2Zmc2V0RGF0YSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0OyAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG5cbiAgaWYgKGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgJiYgb2Zmc2V0RGF0YSkge1xuICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG4gICAgT2JqZWN0LmtleXMob3ZlcmZsb3dPZmZzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtdWx0aXBseSA9IFtyaWdodCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/IDEgOiAtMTtcbiAgICAgIHZhciBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbn0iLCJpbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IHsgdmFyaWF0aW9uUGxhY2VtZW50cywgYmFzZVBsYWNlbWVudHMsIHBsYWNlbWVudHMgYXMgYWxsUGxhY2VtZW50cyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPSBfb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPT09IHZvaWQgMCA/IGFsbFBsYWNlbWVudHMgOiBfb3B0aW9ucyRhbGxvd2VkQXV0b1A7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KTtcbiAgdmFyIHBsYWNlbWVudHMgPSB2YXJpYXRpb24gPyBmbGlwVmFyaWF0aW9ucyA/IHZhcmlhdGlvblBsYWNlbWVudHMgOiB2YXJpYXRpb25QbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSB2YXJpYXRpb247XG4gIH0pIDogYmFzZVBsYWNlbWVudHM7XG4gIHZhciBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWxsb3dlZEF1dG9QbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KSA+PSAwO1xuICB9KTtcblxuICBpZiAoYWxsb3dlZFBsYWNlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogVGhlIGBhbGxvd2VkQXV0b1BsYWNlbWVudHNgIG9wdGlvbiBkaWQgbm90IGFsbG93IGFueScsICdwbGFjZW1lbnRzLiBFbnN1cmUgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbiBtYXRjaGVzIHRoZSB2YXJpYXRpb24nLCAnb2YgdGhlIGFsbG93ZWQgcGxhY2VtZW50cy4nLCAnRm9yIGV4YW1wbGUsIFwiYXV0b1wiIGNhbm5vdCBiZSB1c2VkIHRvIGFsbG93IFwiYm90dG9tLXN0YXJ0XCIuJywgJ1VzZSBcImF1dG8tc3RhcnRcIiBpbnN0ZWFkLiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdOiBGbG93IHNlZW1zIHRvIGhhdmUgcHJvYmxlbXMgd2l0aCB0d28gYXJyYXkgdW5pb25zLi4uXG5cblxuICB2YXIgb3ZlcmZsb3dzID0gYWxsb3dlZFBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSlbZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpXTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvdmVyZmxvd3MpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dzW2FdIC0gb3ZlcmZsb3dzW2JdO1xuICB9KTtcbn0iLCJpbXBvcnQgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVBdXRvUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9jb21wdXRlQXV0b1BsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgYm90dG9tLCB0b3AsIHN0YXJ0LCByaWdodCwgbGVmdCwgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGlmIChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuXG5mdW5jdGlvbiBmbGlwKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzID0gb3B0aW9ucy5mYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPSBvcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRmbGlwVmFyaWF0aW8sXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBvcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cztcbiAgdmFyIHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9IGJhc2VQbGFjZW1lbnQgPT09IHByZWZlcnJlZFBsYWNlbWVudDtcbiAgdmFyIGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9ucyA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHByZWZlcnJlZFBsYWNlbWVudCkpO1xuICB2YXIgcGxhY2VtZW50cyA9IFtwcmVmZXJyZWRQbGFjZW1lbnRdLmNvbmNhdChmYWxsYmFja1BsYWNlbWVudHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8gPyBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9uczogZmxpcFZhcmlhdGlvbnMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IGFsbG93ZWRBdXRvUGxhY2VtZW50c1xuICAgIH0pIDogcGxhY2VtZW50KTtcbiAgfSwgW10pO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBjaGVja3NNYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBtYWtlRmFsbGJhY2tDaGVja3MgPSB0cnVlO1xuICB2YXIgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGxhY2VtZW50ID0gcGxhY2VtZW50c1tpXTtcblxuICAgIHZhciBfYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBpc1N0YXJ0VmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHN0YXJ0O1xuICAgIHZhciBpc1ZlcnRpY2FsID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKF9iYXNlUGxhY2VtZW50KSA+PSAwO1xuICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pO1xuICAgIHZhciBtYWluVmFyaWF0aW9uU2lkZSA9IGlzVmVydGljYWwgPyBpc1N0YXJ0VmFyaWF0aW9uID8gcmlnaHQgOiBsZWZ0IDogaXNTdGFydFZhcmlhdGlvbiA/IGJvdHRvbSA6IHRvcDtcblxuICAgIGlmIChyZWZlcmVuY2VSZWN0W2xlbl0gPiBwb3BwZXJSZWN0W2xlbl0pIHtcbiAgICAgIG1haW5WYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIH1cblxuICAgIHZhciBhbHRWYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIHZhciBjaGVja3MgPSBbXTtcblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tfYmFzZVBsYWNlbWVudF0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbbWFpblZhcmlhdGlvblNpZGVdIDw9IDAsIG92ZXJmbG93W2FsdFZhcmlhdGlvblNpZGVdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja3MuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICByZXR1cm4gY2hlY2s7XG4gICAgfSkpIHtcbiAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgIG1ha2VGYWxsYmFja0NoZWNrcyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XG4gIH1cblxuICBpZiAobWFrZUZhbGxiYWNrQ2hlY2tzKSB7XG4gICAgLy8gYDJgIG1heSBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMg4oCTIHJlc2VhcmNoIGxhdGVyXG4gICAgdmFyIG51bWJlck9mQ2hlY2tzID0gZmxpcFZhcmlhdGlvbnMgPyAzIDogMTtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XG4gICAgICB2YXIgZml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHMuZmluZChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICAgIHZhciBjaGVja3MgPSBjaGVja3NNYXAuZ2V0KHBsYWNlbWVudCk7XG5cbiAgICAgICAgaWYgKGNoZWNrcykge1xuICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgX2kpLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gZml0dGluZ1BsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2kgPSBudW1iZXJPZkNoZWNrczsgX2kgPiAwOyBfaS0tKSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKF9pKTtcblxuICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnBsYWNlbWVudCAhPT0gZmlyc3RGaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCA9IHRydWU7XG4gICAgc3RhdGUucGxhY2VtZW50ID0gZmlyc3RGaXR0aW5nUGxhY2VtZW50O1xuICAgIHN0YXRlLnJlc2V0ID0gdHJ1ZTtcbiAgfVxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZmxpcCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBmbGlwLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddLFxuICBkYXRhOiB7XG4gICAgX3NraXA6IGZhbHNlXG4gIH1cbn07IiwiaW1wb3J0IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XG4gIGlmIChwcmV2ZW50ZWRPZmZzZXRzID09PSB2b2lkIDApIHtcbiAgICBwcmV2ZW50ZWRPZmZzZXRzID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGggKyBwcmV2ZW50ZWRPZmZzZXRzLngsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCArIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dbc2lkZV0gPj0gMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpZGUoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuICB2YXIgcmVmZXJlbmNlT3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICB9KTtcbiAgdmFyIHBvcHBlckFsdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICB9KTtcbiAgdmFyIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHJlZmVyZW5jZU92ZXJmbG93LCByZWZlcmVuY2VSZWN0KTtcbiAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XG4gIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xuICB2YXIgaGFzUG9wcGVyRXNjYXBlZCA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChwb3BwZXJFc2NhcGVPZmZzZXRzKTtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwb3BwZXJFc2NhcGVPZmZzZXRzLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH07XG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgICdkYXRhLXBvcHBlci1lc2NhcGVkJzogaGFzUG9wcGVyRXNjYXBlZFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZVxufTsiLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgcGxhY2VtZW50cyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHJlY3RzLCBvZmZzZXQpIHtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciBpbnZlcnREaXN0YW5jZSA9IFtsZWZ0LCB0b3BdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcblxuICB2YXIgX3JlZiA9IHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicgPyBvZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgcmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KSkgOiBvZmZzZXQsXG4gICAgICBza2lkZGluZyA9IF9yZWZbMF0sXG4gICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XG5cbiAgc2tpZGRpbmcgPSBza2lkZGluZyB8fCAwO1xuICBkaXN0YW5jZSA9IChkaXN0YW5jZSB8fCAwKSAqIGludmVydERpc3RhbmNlO1xuICByZXR1cm4gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyB7XG4gICAgeDogZGlzdGFuY2UsXG4gICAgeTogc2tpZGRpbmdcbiAgfSA6IHtcbiAgICB4OiBza2lkZGluZyxcbiAgICB5OiBkaXN0YW5jZVxuICB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmMi5uYW1lO1xuICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXG4gICAgICBvZmZzZXQgPSBfb3B0aW9ucyRvZmZzZXQgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9vcHRpb25zJG9mZnNldDtcbiAgdmFyIGRhdGEgPSBwbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxuICAgICAgeCA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC54LFxuICAgICAgeSA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC55O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IHg7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0geTtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnb2Zmc2V0JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICBmbjogb2Zmc2V0XG59OyIsImltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZU9mZnNldHMuanNcIjtcblxuZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxuICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdyZWFkJyxcbiAgZm46IHBvcHBlck9mZnNldHMsXG4gIGRhdGE6IHt9XG59OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufSIsImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgc3RhcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRBbHRBeGlzIGZyb20gXCIuLi91dGlscy9nZXRBbHRBeGlzLmpzXCI7XG5pbXBvcnQgeyB3aXRoaW4sIHdpdGhpbk1heENsYW1wIH0gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4uL3V0aWxzL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiO1xuaW1wb3J0IHsgbWluIGFzIG1hdGhNaW4sIG1heCBhcyBtYXRoTWF4IH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgX29wdGlvbnMkdGV0aGVyID0gb3B0aW9ucy50ZXRoZXIsXG4gICAgICB0ZXRoZXIgPSBfb3B0aW9ucyR0ZXRoZXIgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyR0ZXRoZXIsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPSBvcHRpb25zLnRldGhlck9mZnNldCxcbiAgICAgIHRldGhlck9mZnNldCA9IF9vcHRpb25zJHRldGhlck9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHRldGhlck9mZnNldDtcbiAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgcGFkZGluZzogcGFkZGluZyxcbiAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnlcbiAgfSk7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSAhdmFyaWF0aW9uO1xuICB2YXIgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBhbHRBeGlzID0gZ2V0QWx0QXhpcyhtYWluQXhpcyk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciB0ZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbicgPyB0ZXRoZXJPZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiB0ZXRoZXJPZmZzZXQ7XG4gIHZhciBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZSxcbiAgICBhbHRBeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZVxuICB9IDogT2JqZWN0LmFzc2lnbih7XG4gICAgbWFpbkF4aXM6IDAsXG4gICAgYWx0QXhpczogMFxuICB9LCB0ZXRoZXJPZmZzZXRWYWx1ZSk7XG4gIHZhciBvZmZzZXRNb2RpZmllclN0YXRlID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFtzdGF0ZS5wbGFjZW1lbnRdIDogbnVsbDtcbiAgdmFyIGRhdGEgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkO1xuXG4gICAgdmFyIG1haW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG9mZnNldCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdO1xuICAgIHZhciBtaW4gPSBvZmZzZXQgKyBvdmVyZmxvd1ttYWluU2lkZV07XG4gICAgdmFyIG1heCA9IG9mZnNldCAtIG92ZXJmbG93W2FsdFNpZGVdO1xuICAgIHZhciBhZGRpdGl2ZSA9IHRldGhlciA/IC1wb3BwZXJSZWN0W2xlbl0gLyAyIDogMDtcbiAgICB2YXIgbWluTGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IHJlZmVyZW5jZVJlY3RbbGVuXSA6IHBvcHBlclJlY3RbbGVuXTtcbiAgICB2YXIgbWF4TGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IC1wb3BwZXJSZWN0W2xlbl0gOiAtcmVmZXJlbmNlUmVjdFtsZW5dOyAvLyBXZSBuZWVkIHRvIGluY2x1ZGUgdGhlIGFycm93IGluIHRoZSBjYWxjdWxhdGlvbiBzbyB0aGUgYXJyb3cgZG9lc24ndCBnb1xuICAgIC8vIG91dHNpZGUgdGhlIHJlZmVyZW5jZSBib3VuZHNcblxuICAgIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgICB2YXIgYXJyb3dSZWN0ID0gdGV0aGVyICYmIGFycm93RWxlbWVudCA/IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KSA6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nT2JqZWN0ID0gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddID8gc3RhdGUubW9kaWZpZXJzRGF0YVsnYXJyb3cjcGVyc2lzdGVudCddLnBhZGRpbmcgOiBnZXRGcmVzaFNpZGVPYmplY3QoKTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWluID0gYXJyb3dQYWRkaW5nT2JqZWN0W21haW5TaWRlXTtcbiAgICB2YXIgYXJyb3dQYWRkaW5nTWF4ID0gYXJyb3dQYWRkaW5nT2JqZWN0W2FsdFNpZGVdOyAvLyBJZiB0aGUgcmVmZXJlbmNlIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGFycm93IGxlbmd0aCwgd2UgZG9uJ3Qgd2FudFxuICAgIC8vIHRvIGluY2x1ZGUgaXRzIGZ1bGwgc2l6ZSBpbiB0aGUgY2FsY3VsYXRpb24uIElmIHRoZSByZWZlcmVuY2UgaXMgc21hbGxcbiAgICAvLyBhbmQgbmVhciB0aGUgZWRnZSBvZiBhIGJvdW5kYXJ5LCB0aGUgcG9wcGVyIGNhbiBvdmVyZmxvdyBldmVuIGlmIHRoZVxuICAgIC8vIHJlZmVyZW5jZSBpcyBub3Qgb3ZlcmZsb3dpbmcgYXMgd2VsbCAoZS5nLiB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggbm9cbiAgICAvLyB3aWR0aCBvciBoZWlnaHQpXG5cbiAgICB2YXIgYXJyb3dMZW4gPSB3aXRoaW4oMCwgcmVmZXJlbmNlUmVjdFtsZW5dLCBhcnJvd1JlY3RbbGVuXSk7XG4gICAgdmFyIG1pbk9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IHJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgLSBhZGRpdGl2ZSAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWluTGVuIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgdmFyIG1heE9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IC1yZWZlcmVuY2VSZWN0W2xlbl0gLyAyICsgYWRkaXRpdmUgKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1heExlbiArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIHZhciBhcnJvd09mZnNldFBhcmVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93ICYmIGdldE9mZnNldFBhcmVudChzdGF0ZS5lbGVtZW50cy5hcnJvdyk7XG4gICAgdmFyIGNsaWVudE9mZnNldCA9IGFycm93T2Zmc2V0UGFyZW50ID8gbWFpbkF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFRvcCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50TGVmdCB8fCAwIDogMDtcbiAgICB2YXIgb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW21haW5BeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJCA6IDA7XG4gICAgdmFyIHRldGhlck1pbiA9IG9mZnNldCArIG1pbk9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWUgLSBjbGllbnRPZmZzZXQ7XG4gICAgdmFyIHRldGhlck1heCA9IG9mZnNldCArIG1heE9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWU7XG4gICAgdmFyIHByZXZlbnRlZE9mZnNldCA9IHdpdGhpbih0ZXRoZXIgPyBtYXRoTWluKG1pbiwgdGV0aGVyTWluKSA6IG1pbiwgb2Zmc2V0LCB0ZXRoZXIgPyBtYXRoTWF4KG1heCwgdGV0aGVyTWF4KSA6IG1heCk7XG4gICAgcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQgLSBvZmZzZXQ7XG4gIH1cblxuICBpZiAoY2hlY2tBbHRBeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDI7XG5cbiAgICB2YXIgX21haW5TaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IHRvcCA6IGxlZnQ7XG5cbiAgICB2YXIgX2FsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gYm90dG9tIDogcmlnaHQ7XG5cbiAgICB2YXIgX29mZnNldCA9IHBvcHBlck9mZnNldHNbYWx0QXhpc107XG5cbiAgICB2YXIgX2xlbiA9IGFsdEF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHZhciBfbWluID0gX29mZnNldCArIG92ZXJmbG93W19tYWluU2lkZV07XG5cbiAgICB2YXIgX21heCA9IF9vZmZzZXQgLSBvdmVyZmxvd1tfYWx0U2lkZV07XG5cbiAgICB2YXIgaXNPcmlnaW5TaWRlID0gW3RvcCwgbGVmdF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgICB2YXIgX29mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkMiA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbYWx0QXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyIDogMDtcblxuICAgIHZhciBfdGV0aGVyTWluID0gaXNPcmlnaW5TaWRlID8gX21pbiA6IF9vZmZzZXQgLSByZWZlcmVuY2VSZWN0W19sZW5dIC0gcG9wcGVyUmVjdFtfbGVuXSAtIF9vZmZzZXRNb2RpZmllclZhbHVlICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXM7XG5cbiAgICB2YXIgX3RldGhlck1heCA9IGlzT3JpZ2luU2lkZSA/IF9vZmZzZXQgKyByZWZlcmVuY2VSZWN0W19sZW5dICsgcG9wcGVyUmVjdFtfbGVuXSAtIF9vZmZzZXRNb2RpZmllclZhbHVlIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXMgOiBfbWF4O1xuXG4gICAgdmFyIF9wcmV2ZW50ZWRPZmZzZXQgPSB0ZXRoZXIgJiYgaXNPcmlnaW5TaWRlID8gd2l0aGluTWF4Q2xhbXAoX3RldGhlck1pbiwgX29mZnNldCwgX3RldGhlck1heCkgOiB3aXRoaW4odGV0aGVyID8gX3RldGhlck1pbiA6IF9taW4sIF9vZmZzZXQsIHRldGhlciA/IF90ZXRoZXJNYXggOiBfbWF4KTtcblxuICAgIHBvcHBlck9mZnNldHNbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0IC0gX29mZnNldDtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXVxufTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRIVE1MRWxlbWVudFNjcm9sbChlbGVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0SFRNTEVsZW1lbnRTY3JvbGwgZnJvbSBcIi4vZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVTY3JvbGwobm9kZSkge1xuICBpZiAobm9kZSA9PT0gZ2V0V2luZG93KG5vZGUpIHx8ICFpc0hUTUxFbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0SFRNTEVsZW1lbnRTY3JvbGwobm9kZSk7XG4gIH1cbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldE5vZGVTY3JvbGwgZnJvbSBcIi4vZ2V0Tm9kZVNjcm9sbC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnRTY2FsZWQoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSByb3VuZChyZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMTtcbiAgdmFyIHNjYWxlWSA9IHJvdW5kKHJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDE7XG4gIHJldHVybiBzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxO1xufSAvLyBSZXR1cm5zIHRoZSBjb21wb3NpdGUgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuXG4vLyBDb21wb3NpdGUgbWVhbnMgaXQgdGFrZXMgaW50byBhY2NvdW50IHRyYW5zZm9ybXMgYXMgd2VsbCBhcyBsYXlvdXQuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcG9zaXRlUmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50LCBpc0ZpeGVkKSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnRJc1NjYWxlZCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBpc0VsZW1lbnRTY2FsZWQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50SXNTY2FsZWQpO1xuICB2YXIgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIHZhciBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICAgIGlzU2Nyb2xsUGFyZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgKz0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn0iLCJpbXBvcnQgeyBtb2RpZmllclBoYXNlcyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBzb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5ODc1MjU1XG5cbmZ1bmN0aW9uIG9yZGVyKG1vZGlmaWVycykge1xuICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBtYXAuc2V0KG1vZGlmaWVyLm5hbWUsIG1vZGlmaWVyKTtcbiAgfSk7IC8vIE9uIHZpc2l0aW5nIG9iamVjdCwgY2hlY2sgZm9yIGl0cyBkZXBlbmRlbmNpZXMgYW5kIHZpc2l0IHRoZW0gcmVjdXJzaXZlbHlcblxuICBmdW5jdGlvbiBzb3J0KG1vZGlmaWVyKSB7XG4gICAgdmlzaXRlZC5hZGQobW9kaWZpZXIubmFtZSk7XG4gICAgdmFyIHJlcXVpcmVzID0gW10uY29uY2F0KG1vZGlmaWVyLnJlcXVpcmVzIHx8IFtdLCBtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKTtcbiAgICByZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMoZGVwKSkge1xuICAgICAgICB2YXIgZGVwTW9kaWZpZXIgPSBtYXAuZ2V0KGRlcCk7XG5cbiAgICAgICAgaWYgKGRlcE1vZGlmaWVyKSB7XG4gICAgICAgICAgc29ydChkZXBNb2RpZmllcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN1bHQucHVzaChtb2RpZmllcik7XG4gIH1cblxuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAoIXZpc2l0ZWQuaGFzKG1vZGlmaWVyLm5hbWUpKSB7XG4gICAgICAvLyBjaGVjayBmb3IgdmlzaXRlZCBvYmplY3RcbiAgICAgIHNvcnQobW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9yZGVyTW9kaWZpZXJzKG1vZGlmaWVycykge1xuICAvLyBvcmRlciBiYXNlZCBvbiBkZXBlbmRlbmNpZXNcbiAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcihtb2RpZmllcnMpOyAvLyBvcmRlciBiYXNlZCBvbiBwaGFzZVxuXG4gIHJldHVybiBtb2RpZmllclBoYXNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGhhc2UpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgIHJldHVybiBtb2RpZmllci5waGFzZSA9PT0gcGhhc2U7XG4gICAgfSkpO1xuICB9LCBbXSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgdmFyIHBlbmRpbmc7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlQnlOYW1lKG1vZGlmaWVycykge1xuICB2YXIgbWVyZ2VkID0gbW9kaWZpZXJzLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBjdXJyZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XG4gICAgbWVyZ2VkW2N1cnJlbnQubmFtZV0gPSBleGlzdGluZyA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBjdXJyZW50LCB7XG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5vcHRpb25zLCBjdXJyZW50Lm9wdGlvbnMpLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSwgY3VycmVudC5kYXRhKVxuICAgIH0pIDogY3VycmVudDtcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbWVyZ2VkW2tleV07XG4gIH0pO1xufSIsImltcG9ydCBnZXRDb21wb3NpdGVSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gXCIuL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IG9yZGVyTW9kaWZpZXJzIGZyb20gXCIuL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzXCI7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSBcIi4vdXRpbHMvZGVib3VuY2UuanNcIjtcbmltcG9ydCB2YWxpZGF0ZU1vZGlmaWVycyBmcm9tIFwiLi91dGlscy92YWxpZGF0ZU1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IHVuaXF1ZUJ5IGZyb20gXCIuL3V0aWxzL3VuaXF1ZUJ5LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgbWVyZ2VCeU5hbWUgZnJvbSBcIi4vdXRpbHMvbWVyZ2VCeU5hbWUuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCB7IGF1dG8gfSBmcm9tIFwiLi9lbnVtcy5qc1wiO1xudmFyIElOVkFMSURfRUxFTUVOVF9FUlJPUiA9ICdQb3BwZXI6IEludmFsaWQgcmVmZXJlbmNlIG9yIHBvcHBlciBhcmd1bWVudCBwcm92aWRlZC4gVGhleSBtdXN0IGJlIGVpdGhlciBhIERPTSBlbGVtZW50IG9yIHZpcnR1YWwgZWxlbWVudC4nO1xudmFyIElORklOSVRFX0xPT1BfRVJST1IgPSAnUG9wcGVyOiBBbiBpbmZpbml0ZSBsb29wIGluIHRoZSBtb2RpZmllcnMgY3ljbGUgaGFzIGJlZW4gZGV0ZWN0ZWQhIFRoZSBjeWNsZSBoYXMgYmVlbiBpbnRlcnJ1cHRlZCB0byBwcmV2ZW50IGEgYnJvd3NlciBjcmFzaC4nO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgbW9kaWZpZXJzOiBbXSxcbiAgc3RyYXRlZ3k6ICdhYnNvbHV0ZSdcbn07XG5cbmZ1bmN0aW9uIGFyZVZhbGlkRWxlbWVudHMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gIWFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiAhKGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3BwZXJHZW5lcmF0b3IoZ2VuZXJhdG9yT3B0aW9ucykge1xuICBpZiAoZ2VuZXJhdG9yT3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgZ2VuZXJhdG9yT3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9nZW5lcmF0b3JPcHRpb25zID0gZ2VuZXJhdG9yT3B0aW9ucyxcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRNb2RpZmllcnMsXG4gICAgICBkZWZhdWx0TW9kaWZpZXJzID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmID09PSB2b2lkIDAgPyBbXSA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZixcbiAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHRPcHRpb25zID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9PT0gdm9pZCAwID8gREVGQVVMVF9PUFRJT05TIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmMjtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVBvcHBlcihyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSB7XG4gICAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIGRlZmF1bHRPcHRpb25zKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlcjogcG9wcGVyXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfTtcbiAgICB2YXIgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIHZhciBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHZhciBpbnN0YW5jZSA9IHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMoc2V0T3B0aW9uc0FjdGlvbikge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzZXRPcHRpb25zQWN0aW9uID09PSAnZnVuY3Rpb24nID8gc2V0T3B0aW9uc0FjdGlvbihzdGF0ZS5vcHRpb25zKSA6IHNldE9wdGlvbnNBY3Rpb247XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgc3RhdGUub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBzdGF0ZS5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGlzRWxlbWVudChyZWZlcmVuY2UpID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlKSA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICBwb3BwZXI6IGxpc3RTY3JvbGxQYXJlbnRzKHBvcHBlcilcbiAgICAgICAgfTsgLy8gT3JkZXJzIHRoZSBtb2RpZmllcnMgYmFzZWQgb24gdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCBgcGhhc2VgXG4gICAgICAgIC8vIHByb3BlcnRpZXNcblxuICAgICAgICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyTW9kaWZpZXJzKG1lcmdlQnlOYW1lKFtdLmNvbmNhdChkZWZhdWx0TW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycykpKTsgLy8gU3RyaXAgb3V0IGRpc2FibGVkIG1vZGlmaWVyc1xuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLmVuYWJsZWQ7XG4gICAgICAgIH0pOyAvLyBWYWxpZGF0ZSB0aGUgcHJvdmlkZWQgbW9kaWZpZXJzIHNvIHRoYXQgdGhlIGNvbnN1bWVyIHdpbGwgZ2V0IHdhcm5lZFxuICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIG1vZGlmaWVycyBpcyBpbnZhbGlkIGZvciBhbnkgcmVhc29uXG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIHZhciBtb2RpZmllcnMgPSB1bmlxdWVCeShbXS5jb25jYXQob3JkZXJlZE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YWxpZGF0ZU1vZGlmaWVycyhtb2RpZmllcnMpO1xuXG4gICAgICAgICAgaWYgKGdldEJhc2VQbGFjZW1lbnQoc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgICAgICAgICB2YXIgZmxpcE1vZGlmaWVyID0gc3RhdGUub3JkZXJlZE1vZGlmaWVycy5maW5kKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYyLm5hbWU7XG4gICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSAnZmxpcCc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFmbGlwTW9kaWZpZXIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhdXRvXCIgcGxhY2VtZW50cyByZXF1aXJlIHRoZSBcImZsaXBcIiBtb2RpZmllciBiZScsICdwcmVzZW50IGFuZCBlbmFibGVkIHRvIHdvcmsuJ10uam9pbignICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHBvcHBlciksXG4gICAgICAgICAgICAgIG1hcmdpblRvcCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpblRvcCxcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5SaWdodCxcbiAgICAgICAgICAgICAgbWFyZ2luQm90dG9tID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luQm90dG9tLFxuICAgICAgICAgICAgICBtYXJnaW5MZWZ0ID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luTGVmdDsgLy8gV2Ugbm8gbG9uZ2VyIHRha2UgaW50byBhY2NvdW50IGBtYXJnaW5zYCBvbiB0aGUgcG9wcGVyLCBhbmQgaXQgY2FuXG4gICAgICAgICAgLy8gY2F1c2UgYnVncyB3aXRoIHBvc2l0aW9uaW5nLCBzbyB3ZSdsbCB3YXJuIHRoZSBjb25zdW1lclxuXG5cbiAgICAgICAgICBpZiAoW21hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdF0uc29tZShmdW5jdGlvbiAobWFyZ2luKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChtYXJnaW4pO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IENTUyBcIm1hcmdpblwiIHN0eWxlcyBjYW5ub3QgYmUgdXNlZCB0byBhcHBseSBwYWRkaW5nJywgJ2JldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50IG9yIGJvdW5kYXJ5LicsICdUbyByZXBsaWNhdGUgbWFyZ2luLCB1c2UgdGhlIGBvZmZzZXRgIG1vZGlmaWVyLCBhcyB3ZWxsIGFzJywgJ3RoZSBgcGFkZGluZ2Agb3B0aW9uIGluIHRoZSBgcHJldmVudE92ZXJmbG93YCBhbmQgYGZsaXBgJywgJ21vZGlmaWVycy4nXS5qb2luKCcgJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bk1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9LFxuICAgICAgLy8gU3luYyB1cGRhdGUg4oCTIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcbiAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcbiAgICAgIC8vIGxvZ2ljLlxuICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xuICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxuICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICBpZiAoaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N0YXRlJGVsZW1lbnRzID0gc3RhdGUuZWxlbWVudHMsXG4gICAgICAgICAgICByZWZlcmVuY2UgPSBfc3RhdGUkZWxlbWVudHMucmVmZXJlbmNlLFxuICAgICAgICAgICAgcG9wcGVyID0gX3N0YXRlJGVsZW1lbnRzLnBvcHBlcjsgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXG4gICAgICAgIC8vIGFueW1vcmVcblxuICAgICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIGFuZCBwb3BwZXIgcmVjdHMgdG8gYmUgcmVhZCBieSBtb2RpZmllcnNcblxuXG4gICAgICAgIHN0YXRlLnJlY3RzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogZ2V0Q29tcG9zaXRlUmVjdChyZWZlcmVuY2UsIGdldE9mZnNldFBhcmVudChwb3BwZXIpLCBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnKSxcbiAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKVxuICAgICAgICB9OyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXNldCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUuIFRoZVxuICAgICAgICAvLyBtb3N0IGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0aGUgYGZsaXBgIG1vZGlmaWVyIGNoYW5naW5nIHRoZVxuICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBsb2dpYyB3YXMgcHJldmlvdXNseSByYW4gZm9yIHRoZSBwcmV2aW91cyBwbGFjZW1lbnQgYW5kIGlzIHRoZXJlZm9yZVxuICAgICAgICAvLyBzdGFsZS9pbmNvcnJlY3RcblxuICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcbiAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgcGVyc2lzdCBhbmQgaXMgZnJlc2ggb24gZWFjaCB1cGRhdGUuXG4gICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubW9kaWZpZXJzRGF0YVttb2RpZmllci5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIG1vZGlmaWVyLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9fZGVidWdfbG9vcHNfXyA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgX19kZWJ1Z19sb29wc19fICs9IDE7XG5cbiAgICAgICAgICAgIGlmIChfX2RlYnVnX2xvb3BzX18gPiAxMDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTkZJTklURV9MT09QX0VSUk9SKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoSU5WQUxJRF9FTEVNRU5UX0VSUk9SKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucykudGhlbihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmICghaXNEZXN0cm95ZWQgJiYgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIG9wdGlvbnMub25GaXJzdFVwZGF0ZShzdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgYmVmb3JlIHRoZSBmaXJzdFxuICAgIC8vIHVwZGF0ZSBjeWNsZSBydW5zLiBUaGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHVwZGF0ZVxuICAgIC8vIGN5Y2xlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbW9kaWZpZXIgYWRkcyBzb21lIHBlcnNpc3RlbnQgZGF0YSB0aGF0XG4gICAgLy8gb3RoZXIgbW9kaWZpZXJzIG5lZWQgdG8gdXNlLCBidXQgdGhlIG1vZGlmaWVyIGlzIHJ1biBhZnRlciB0aGUgZGVwZW5kZW50XG4gICAgLy8gb25lLlxuXG4gICAgZnVuY3Rpb24gcnVuTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYzLm5hbWUsXG4gICAgICAgICAgICBfcmVmMyRvcHRpb25zID0gX3JlZjMub3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfcmVmMyRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYzJG9wdGlvbnMsXG4gICAgICAgICAgICBlZmZlY3QgPSBfcmVmMy5lZmZlY3Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgY2xlYW51cEZuID0gZWZmZWN0KHtcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XG5cbiAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSk7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufVxuZXhwb3J0IHZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgZGV0ZWN0T3ZlcmZsb3cgfTsiLCJpbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7XG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tIFwiLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcIjtcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcIjtcbmltcG9ydCBvZmZzZXQgZnJvbSBcIi4vbW9kaWZpZXJzL29mZnNldC5qc1wiO1xuaW1wb3J0IGZsaXAgZnJvbSBcIi4vbW9kaWZpZXJzL2ZsaXAuanNcIjtcbmltcG9ydCBwcmV2ZW50T3ZlcmZsb3cgZnJvbSBcIi4vbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGFycm93IGZyb20gXCIuL21vZGlmaWVycy9hcnJvdy5qc1wiO1xuaW1wb3J0IGhpZGUgZnJvbSBcIi4vbW9kaWZpZXJzL2hpZGUuanNcIjtcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzLCBjb21wdXRlU3R5bGVzLCBhcHBseVN0eWxlcywgb2Zmc2V0LCBmbGlwLCBwcmV2ZW50T3ZlcmZsb3csIGFycm93LCBoaWRlXTtcbnZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVyc1xufSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyLCBwb3BwZXJHZW5lcmF0b3IsIGRlZmF1bHRNb2RpZmllcnMsIGRldGVjdE92ZXJmbG93IH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyIGFzIGNyZWF0ZVBvcHBlckxpdGUgfSBmcm9tIFwiLi9wb3BwZXItbGl0ZS5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCAqIGZyb20gXCIuL21vZGlmaWVycy9pbmRleC5qc1wiOyIsImZ1bmN0aW9uIF9nZXRDZW50ZXJlZFN0eWxlUG9wcGVyTW9kaWZpZXIoKSB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgICAgIGZuKHsgc3RhdGUgfSkge1xuICAgICAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgIGlmIChuYW1lICE9PSAncG9wcGVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgbGVmdDogJzUwJScsXG4gICAgICAgICAgICB0b3A6ICc1MCUnLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC01MCUsIC01MCUpJ1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICAgICAgICBjb25zdCBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG5cbiAgICAgICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGFkYXB0aXZlOiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgXTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBtb2RpZmllciBmb3IgcG9wcGVyIHRoYXQgd2lsbCBoZWxwIGZvY3VzIHRoZSBlbGVtZW50IGFmdGVyIGl0IGhhc1xuICogYmVlbiByZW5kZXJlZFxuICpcbiAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZm9jdXMgYWZ0ZXIgcmVuZGVyIG1vZGlmaWVyIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUZvY3VzQWZ0ZXJSZW5kZXJNb2RpZmllcihzdGVwKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2ZvY3VzQWZ0ZXJSZW5kZXInLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgcGhhc2U6ICdhZnRlcldyaXRlJyxcbiAgICBmbigpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoc3RlcC5lbCkge1xuICAgICAgICAgIGNvbnN0IGZvY3VzT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgc3RlcC5lbC5mb2N1cyhmb2N1c09wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9LCAzMDApO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgdGhlIGFycmF5IG9mIG9wdGlvbnMgZm9yIGEgdG9vbHRpcCB0aGF0IGRvZXNuJ3QgaGF2ZSBhXG4gKiB0YXJnZXQgZWxlbWVudCBpbiB0aGUgRE9NIC0tIGFuZCB0aHVzIGlzIHBvc2l0aW9uZWQgaW4gdGhlIGNlbnRlclxuICogb2YgdGhlIHZpZXdcbiAqXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGZpbmFsIFBvcHBlciBvcHRpb25zIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUNlbnRlcmVkUG9wcGVyKHN0ZXApIHtcbiAgY29uc3QgY2VudGVyZWRTdHlsZVBvcHBlck1vZGlmaWVyID0gX2dldENlbnRlcmVkU3R5bGVQb3BwZXJNb2RpZmllcigpO1xuXG4gIGxldCBwb3BwZXJPcHRpb25zID0ge1xuICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgc3RyYXRlZ3k6ICdmaXhlZCcsXG4gICAgbW9kaWZpZXJzOiBbZ2VuZXJhdGVGb2N1c0FmdGVyUmVuZGVyTW9kaWZpZXIoc3RlcCldXG4gIH07XG5cbiAgcG9wcGVyT3B0aW9ucyA9IHtcbiAgICAuLi5wb3BwZXJPcHRpb25zLFxuICAgIG1vZGlmaWVyczogQXJyYXkuZnJvbShcbiAgICAgIG5ldyBTZXQoWy4uLnBvcHBlck9wdGlvbnMubW9kaWZpZXJzLCAuLi5jZW50ZXJlZFN0eWxlUG9wcGVyTW9kaWZpZXJdKVxuICAgIClcbiAgfTtcblxuICByZXR1cm4gcG9wcGVyT3B0aW9ucztcbn1cbiIsImltcG9ydCB7IGNyZWF0ZVBvcHBlciB9IGZyb20gJ0Bwb3BwZXJqcy9jb3JlJztcbmltcG9ydCB7IGlzRnVuY3Rpb24sIGlzU3RyaW5nIH0gZnJvbSAnLi90eXBlLWNoZWNrJztcbmltcG9ydCB7IG1ha2VDZW50ZXJlZFBvcHBlciwgZ2VuZXJhdGVGb2N1c0FmdGVyUmVuZGVyTW9kaWZpZXIgfSBmcm9tICcuL3BvcHBlci1vcHRpb25zJztcblxuLyoqXG4gKiBFbnN1cmUgY2xhc3MgcHJlZml4IGVuZHMgaW4gYC1gXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IFRoZSBwcmVmaXggdG8gcHJlcGVuZCB0byB0aGUgY2xhc3MgbmFtZXMgZ2VuZXJhdGVkIGJ5IG5hbm8tY3NzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwcmVmaXggZW5kaW5nIGluIGAtYFxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUHJlZml4KHByZWZpeCkge1xuICBpZiAoIWlzU3RyaW5nKHByZWZpeCkgfHwgcHJlZml4ID09PSAnJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiBwcmVmaXguY2hhckF0KHByZWZpeC5sZW5ndGggLSAxKSAhPT0gJy0nID8gYCR7cHJlZml4fS1gIDogcHJlZml4O1xufVxuXG4vKipcbiAqIFJlc29sdmVzIGF0dGFjaFRvIG9wdGlvbnMsIGNvbnZlcnRpbmcgZWxlbWVudCBvcHRpb24gdmFsdWUgdG8gYSBxdWFsaWZpZWQgSFRNTEVsZW1lbnQuXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHt7fXx7ZWxlbWVudCwgb259fVxuICogYGVsZW1lbnRgIGlzIGEgcXVhbGlmaWVkIEhUTUwgRWxlbWVudFxuICogYG9uYCBpcyBhIHN0cmluZyBwb3NpdGlvbiB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBdHRhY2hUbyhzdGVwKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBzdGVwLm9wdGlvbnMuYXR0YWNoVG8gfHwge307XG4gIGNvbnN0IHJldHVybk9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblxuICBpZiAoaXNGdW5jdGlvbihyZXR1cm5PcHRzLmVsZW1lbnQpKSB7XG4gICAgLy8gQmluZCB0aGUgY2FsbGJhY2sgdG8gc3RlcCBzbyB0aGF0IGl0IGhhcyBhY2Nlc3MgdG8gdGhlIG9iamVjdCwgdG8gZW5hYmxlIHJ1bm5pbmcgYWRkaXRpb25hbCBsb2dpY1xuICAgIHJldHVybk9wdHMuZWxlbWVudCA9IHJldHVybk9wdHMuZWxlbWVudC5jYWxsKHN0ZXApO1xuICB9XG5cbiAgaWYgKGlzU3RyaW5nKHJldHVybk9wdHMuZWxlbWVudCkpIHtcbiAgICAvLyBDYW4ndCBvdmVycmlkZSB0aGUgZWxlbWVudCBpbiB1c2VyIG9wdHMgcmVmZXJlbmNlIGJlY2F1c2Ugd2UgY2FuJ3RcbiAgICAvLyBndWFyYW50ZWUgdGhhdCB0aGUgZWxlbWVudCB3aWxsIGV4aXN0IGluIHRoZSBmdXR1cmUuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybk9wdHMuZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocmV0dXJuT3B0cy5lbGVtZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBUT0RPXG4gICAgfVxuICAgIGlmICghcmV0dXJuT3B0cy5lbGVtZW50KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgVGhlIGVsZW1lbnQgZm9yIHRoaXMgU2hlcGhlcmQgc3RlcCB3YXMgbm90IGZvdW5kICR7b3B0aW9ucy5lbGVtZW50fWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVybk9wdHM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBzdGVwIHNob3VsZCBiZSBjZW50ZXJlZCBvciBub3QuIERvZXMgbm90IHRyaWdnZXIgYXR0YWNoVG8uZWxlbWVudCBldmFsdWF0aW9uLCBtYWtpbmcgaXQgYSBwdXJlXG4gKiBhbHRlcm5hdGl2ZSBmb3IgdGhlIGRlcHJlY2F0ZWQgc3RlcC5pc0NlbnRlcmVkKCkgbWV0aG9kLlxuICogQHBhcmFtIHJlc29sdmVkQXR0YWNoVG9PcHRpb25zXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZENlbnRlclN0ZXAocmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMpIHtcbiAgaWYgKHJlc29sdmVkQXR0YWNoVG9PcHRpb25zID09PSB1bmRlZmluZWQgfHwgcmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIFxuICByZXR1cm4gIXJlc29sdmVkQXR0YWNoVG9PcHRpb25zLmVsZW1lbnQgfHwgIXJlc29sdmVkQXR0YWNoVG9PcHRpb25zLm9uO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgb3B0aW9ucyBmb3IgdGhlIHRvb2x0aXAgYW5kIGluaXRpYWxpemVzXG4gKiBgc3RlcC50b29sdGlwYCBhcyBhIFBvcHBlciBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBUb29sdGlwKHN0ZXApIHtcbiAgaWYgKHN0ZXAudG9vbHRpcCkge1xuICAgIHN0ZXAudG9vbHRpcC5kZXN0cm95KCk7XG4gIH1cblxuICBjb25zdCBhdHRhY2hUb09wdGlvbnMgPSBzdGVwLl9nZXRSZXNvbHZlZEF0dGFjaFRvT3B0aW9ucygpO1xuXG4gIGxldCB0YXJnZXQgPSBhdHRhY2hUb09wdGlvbnMuZWxlbWVudDtcbiAgY29uc3QgcG9wcGVyT3B0aW9ucyA9IGdldFBvcHBlck9wdGlvbnMoYXR0YWNoVG9PcHRpb25zLCBzdGVwKTtcblxuICBpZiAoc2hvdWxkQ2VudGVyU3RlcChhdHRhY2hUb09wdGlvbnMpKSB7XG4gICAgdGFyZ2V0ID0gZG9jdW1lbnQuYm9keTtcbiAgICBjb25zdCBjb250ZW50ID0gc3RlcC5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQuZ2V0RWxlbWVudCgpO1xuICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnc2hlcGhlcmQtY2VudGVyZWQnKTtcbiAgfVxuXG4gIHN0ZXAudG9vbHRpcCA9IGNyZWF0ZVBvcHBlcih0YXJnZXQsIHN0ZXAuZWwsIHBvcHBlck9wdGlvbnMpO1xuICBzdGVwLnRhcmdldCA9IGF0dGFjaFRvT3B0aW9ucy5lbGVtZW50O1xuXG4gIHJldHVybiBwb3BwZXJPcHRpb25zO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHVuaXF1ZSBpZCBmb3Igc3RlcHMsIHRvdXJzLCBtb2RhbHMsIGV0Y1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXVpZCgpIHtcbiAgbGV0IGQgPSBEYXRlLm5vdygpO1xuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCAoYykgPT4ge1xuICAgIGNvbnN0IHIgPSAoZCArIE1hdGgucmFuZG9tKCkgKiAxNikgJSAxNiB8IDA7XG4gICAgZCA9IE1hdGguZmxvb3IoZCAvIDE2KTtcbiAgICByZXR1cm4gKGMgPT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4OCkudG9TdHJpbmcoMTYpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBgUG9wcGVyYCBvcHRpb25zIGZyb20gYSBzZXQgb2YgYmFzZSBgYXR0YWNoVG9gIG9wdGlvbnNcbiAqIEBwYXJhbSBhdHRhY2hUb09wdGlvbnNcbiAqIEBwYXJhbSB7U3RlcH0gc3RlcCBUaGUgc3RlcCBpbnN0YW5jZVxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBvcHBlck9wdGlvbnMoYXR0YWNoVG9PcHRpb25zLCBzdGVwKSB7XG4gIGxldCBwb3BwZXJPcHRpb25zID0ge1xuICAgIG1vZGlmaWVyczogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGFsdEF4aXM6IHRydWUsXG4gICAgICAgICAgdGV0aGVyOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2VuZXJhdGVGb2N1c0FmdGVyUmVuZGVyTW9kaWZpZXIoc3RlcClcbiAgICBdLFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG4gIH07XG5cbiAgaWYgKHNob3VsZENlbnRlclN0ZXAoYXR0YWNoVG9PcHRpb25zKSkge1xuICAgIHBvcHBlck9wdGlvbnMgPSBtYWtlQ2VudGVyZWRQb3BwZXIoc3RlcCk7XG4gIH0gZWxzZSB7XG4gICAgcG9wcGVyT3B0aW9ucy5wbGFjZW1lbnQgPSBhdHRhY2hUb09wdGlvbnMub247XG4gIH1cblxuICBjb25zdCBkZWZhdWx0U3RlcE9wdGlvbnMgPVxuICAgIHN0ZXAudG91ciAmJiBzdGVwLnRvdXIub3B0aW9ucyAmJiBzdGVwLnRvdXIub3B0aW9ucy5kZWZhdWx0U3RlcE9wdGlvbnM7XG5cbiAgaWYgKGRlZmF1bHRTdGVwT3B0aW9ucykge1xuICAgIHBvcHBlck9wdGlvbnMgPSBfbWVyZ2VNb2RpZmllcnMoZGVmYXVsdFN0ZXBPcHRpb25zLCBwb3BwZXJPcHRpb25zKTtcbiAgfVxuXG4gIHBvcHBlck9wdGlvbnMgPSBfbWVyZ2VNb2RpZmllcnMoc3RlcC5vcHRpb25zLCBwb3BwZXJPcHRpb25zKTtcblxuICByZXR1cm4gcG9wcGVyT3B0aW9ucztcbn1cblxuZnVuY3Rpb24gX21lcmdlTW9kaWZpZXJzKHN0ZXBPcHRpb25zLCBwb3BwZXJPcHRpb25zKSB7XG4gIGlmIChzdGVwT3B0aW9ucy5wb3BwZXJPcHRpb25zKSB7XG4gICAgbGV0IG1lcmdlZFBvcHBlck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKFxuICAgICAge30sXG4gICAgICBwb3BwZXJPcHRpb25zLFxuICAgICAgc3RlcE9wdGlvbnMucG9wcGVyT3B0aW9uc1xuICAgICk7XG5cbiAgICBpZiAoXG4gICAgICBzdGVwT3B0aW9ucy5wb3BwZXJPcHRpb25zLm1vZGlmaWVycyAmJlxuICAgICAgc3RlcE9wdGlvbnMucG9wcGVyT3B0aW9ucy5tb2RpZmllcnMubGVuZ3RoID4gMFxuICAgICkge1xuICAgICAgY29uc3QgbmFtZXMgPSBzdGVwT3B0aW9ucy5wb3BwZXJPcHRpb25zLm1vZGlmaWVycy5tYXAoKG1vZCkgPT4gbW9kLm5hbWUpO1xuICAgICAgY29uc3QgZmlsdGVyZWRNb2RpZmllcnMgPSBwb3BwZXJPcHRpb25zLm1vZGlmaWVycy5maWx0ZXIoXG4gICAgICAgIChtb2QpID0+ICFuYW1lcy5pbmNsdWRlcyhtb2QubmFtZSlcbiAgICAgICk7XG5cbiAgICAgIG1lcmdlZFBvcHBlck9wdGlvbnMubW9kaWZpZXJzID0gQXJyYXkuZnJvbShcbiAgICAgICAgbmV3IFNldChbLi4uZmlsdGVyZWRNb2RpZmllcnMsIC4uLnN0ZXBPcHRpb25zLnBvcHBlck9wdGlvbnMubW9kaWZpZXJzXSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlZFBvcHBlck9wdGlvbnM7XG4gIH1cblxuICByZXR1cm4gcG9wcGVyT3B0aW9ucztcbn1cbiIsImZ1bmN0aW9uIG5vb3AoKSB7IH1cbmNvbnN0IGlkZW50aXR5ID0geCA9PiB4O1xuZnVuY3Rpb24gYXNzaWduKHRhciwgc3JjKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGZvciAoY29uc3QgayBpbiBzcmMpXG4gICAgICAgIHRhcltrXSA9IHNyY1trXTtcbiAgICByZXR1cm4gdGFyO1xufVxuZnVuY3Rpb24gaXNfcHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gYWRkX2xvY2F0aW9uKGVsZW1lbnQsIGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhcikge1xuICAgIGVsZW1lbnQuX19zdmVsdGVfbWV0YSA9IHtcbiAgICAgICAgbG9jOiB7IGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhciB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJ1bihmbikge1xuICAgIHJldHVybiBmbigpO1xufVxuZnVuY3Rpb24gYmxhbmtfb2JqZWN0KCkge1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuZnVuY3Rpb24gcnVuX2FsbChmbnMpIHtcbiAgICBmbnMuZm9yRWFjaChydW4pO1xufVxuZnVuY3Rpb24gaXNfZnVuY3Rpb24odGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gc2FmZV9ub3RfZXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiIHx8ICgoYSAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHx8IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nKTtcbn1cbmxldCBzcmNfdXJsX2VxdWFsX2FuY2hvcjtcbmZ1bmN0aW9uIHNyY191cmxfZXF1YWwoZWxlbWVudF9zcmMsIHVybCkge1xuICAgIGlmICghc3JjX3VybF9lcXVhbF9hbmNob3IpIHtcbiAgICAgICAgc3JjX3VybF9lcXVhbF9hbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgfVxuICAgIHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWYgPSB1cmw7XG4gICAgcmV0dXJuIGVsZW1lbnRfc3JjID09PSBzcmNfdXJsX2VxdWFsX2FuY2hvci5ocmVmO1xufVxuZnVuY3Rpb24gbm90X2VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYSAhPSBhID8gYiA9PSBiIDogYSAhPT0gYjtcbn1cbmZ1bmN0aW9uIGlzX2VtcHR5KG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX3N0b3JlKHN0b3JlLCBuYW1lKSB7XG4gICAgaWYgKHN0b3JlICE9IG51bGwgJiYgdHlwZW9mIHN0b3JlLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCcke25hbWV9JyBpcyBub3QgYSBzdG9yZSB3aXRoIGEgJ3N1YnNjcmliZScgbWV0aG9kYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3Vic2NyaWJlKHN0b3JlLCAuLi5jYWxsYmFja3MpIHtcbiAgICBpZiAoc3RvcmUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gICAgY29uc3QgdW5zdWIgPSBzdG9yZS5zdWJzY3JpYmUoLi4uY2FsbGJhY2tzKTtcbiAgICByZXR1cm4gdW5zdWIudW5zdWJzY3JpYmUgPyAoKSA9PiB1bnN1Yi51bnN1YnNjcmliZSgpIDogdW5zdWI7XG59XG5mdW5jdGlvbiBnZXRfc3RvcmVfdmFsdWUoc3RvcmUpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgc3Vic2NyaWJlKHN0b3JlLCBfID0+IHZhbHVlID0gXykoKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjb21wb25lbnRfc3Vic2NyaWJlKGNvbXBvbmVudCwgc3RvcmUsIGNhbGxiYWNrKSB7XG4gICAgY29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaChzdWJzY3JpYmUoc3RvcmUsIGNhbGxiYWNrKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVfc2xvdChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG4gICAgaWYgKGRlZmluaXRpb24pIHtcbiAgICAgICAgY29uc3Qgc2xvdF9jdHggPSBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblswXShzbG90X2N0eCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG4gICAgcmV0dXJuIGRlZmluaXRpb25bMV0gJiYgZm5cbiAgICAgICAgPyBhc3NpZ24oJCRzY29wZS5jdHguc2xpY2UoKSwgZGVmaW5pdGlvblsxXShmbihjdHgpKSlcbiAgICAgICAgOiAkJHNjb3BlLmN0eDtcbn1cbmZ1bmN0aW9uIGdldF9zbG90X2NoYW5nZXMoZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGZuKSB7XG4gICAgaWYgKGRlZmluaXRpb25bMl0gJiYgZm4pIHtcbiAgICAgICAgY29uc3QgbGV0cyA9IGRlZmluaXRpb25bMl0oZm4oZGlydHkpKTtcbiAgICAgICAgaWYgKCQkc2NvcGUuZGlydHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxldHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsZXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gW107XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBNYXRoLm1heCgkJHNjb3BlLmRpcnR5Lmxlbmd0aCwgbGV0cy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZFtpXSA9ICQkc2NvcGUuZGlydHlbaV0gfCBsZXRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJCRzY29wZS5kaXJ0eSB8IGxldHM7XG4gICAgfVxuICAgIHJldHVybiAkJHNjb3BlLmRpcnR5O1xufVxuZnVuY3Rpb24gdXBkYXRlX3Nsb3RfYmFzZShzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgc2xvdF9jaGFuZ2VzLCBnZXRfc2xvdF9jb250ZXh0X2ZuKSB7XG4gICAgaWYgKHNsb3RfY2hhbmdlcykge1xuICAgICAgICBjb25zdCBzbG90X2NvbnRleHQgPSBnZXRfc2xvdF9jb250ZXh0KHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcbiAgICAgICAgc2xvdC5wKHNsb3RfY29udGV4dCwgc2xvdF9jaGFuZ2VzKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVfc2xvdChzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4sIGdldF9zbG90X2NvbnRleHRfZm4pIHtcbiAgICBjb25zdCBzbG90X2NoYW5nZXMgPSBnZXRfc2xvdF9jaGFuZ2VzKHNsb3RfZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4pO1xuICAgIHVwZGF0ZV9zbG90X2Jhc2Uoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIHNsb3RfY2hhbmdlcywgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG59XG5mdW5jdGlvbiBnZXRfYWxsX2RpcnR5X2Zyb21fc2NvcGUoJCRzY29wZSkge1xuICAgIGlmICgkJHNjb3BlLmN0eC5sZW5ndGggPiAzMikge1xuICAgICAgICBjb25zdCBkaXJ0eSA9IFtdO1xuICAgICAgICBjb25zdCBsZW5ndGggPSAkJHNjb3BlLmN0eC5sZW5ndGggLyAzMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGlydHlbaV0gPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlydHk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMocHJvcHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gcHJvcHMpXG4gICAgICAgIGlmIChrWzBdICE9PSAnJCcpXG4gICAgICAgICAgICByZXN1bHRba10gPSBwcm9wc1trXTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29tcHV0ZV9yZXN0X3Byb3BzKHByb3BzLCBrZXlzKSB7XG4gICAgY29uc3QgcmVzdCA9IHt9O1xuICAgIGtleXMgPSBuZXcgU2V0KGtleXMpO1xuICAgIGZvciAoY29uc3QgayBpbiBwcm9wcylcbiAgICAgICAgaWYgKCFrZXlzLmhhcyhrKSAmJiBrWzBdICE9PSAnJCcpXG4gICAgICAgICAgICByZXN0W2tdID0gcHJvcHNba107XG4gICAgcmV0dXJuIHJlc3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlX3Nsb3RzKHNsb3RzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gb25jZShmbikge1xuICAgIGxldCByYW4gPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHJhbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgICAgZm4uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbnVsbF90b19lbXB0eSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldF9zdG9yZV92YWx1ZShzdG9yZSwgcmV0LCB2YWx1ZSkge1xuICAgIHN0b3JlLnNldCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IGhhc19wcm9wID0gKG9iaiwgcHJvcCkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG5mdW5jdGlvbiBhY3Rpb25fZGVzdHJveWVyKGFjdGlvbl9yZXN1bHQpIHtcbiAgICByZXR1cm4gYWN0aW9uX3Jlc3VsdCAmJiBpc19mdW5jdGlvbihhY3Rpb25fcmVzdWx0LmRlc3Ryb3kpID8gYWN0aW9uX3Jlc3VsdC5kZXN0cm95IDogbm9vcDtcbn1cblxuY29uc3QgaXNfY2xpZW50ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5sZXQgbm93ID0gaXNfY2xpZW50XG4gICAgPyAoKSA9PiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClcbiAgICA6ICgpID0+IERhdGUubm93KCk7XG5sZXQgcmFmID0gaXNfY2xpZW50ID8gY2IgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKSA6IG5vb3A7XG4vLyB1c2VkIGludGVybmFsbHkgZm9yIHRlc3RpbmdcbmZ1bmN0aW9uIHNldF9ub3coZm4pIHtcbiAgICBub3cgPSBmbjtcbn1cbmZ1bmN0aW9uIHNldF9yYWYoZm4pIHtcbiAgICByYWYgPSBmbjtcbn1cblxuY29uc3QgdGFza3MgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBydW5fdGFza3Mobm93KSB7XG4gICAgdGFza3MuZm9yRWFjaCh0YXNrID0+IHtcbiAgICAgICAgaWYgKCF0YXNrLmMobm93KSkge1xuICAgICAgICAgICAgdGFza3MuZGVsZXRlKHRhc2spO1xuICAgICAgICAgICAgdGFzay5mKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodGFza3Muc2l6ZSAhPT0gMClcbiAgICAgICAgcmFmKHJ1bl90YXNrcyk7XG59XG4vKipcbiAqIEZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkhXG4gKi9cbmZ1bmN0aW9uIGNsZWFyX2xvb3BzKCkge1xuICAgIHRhc2tzLmNsZWFyKCk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdGFzayB0aGF0IHJ1bnMgb24gZWFjaCByYWYgZnJhbWVcbiAqIHVudGlsIGl0IHJldHVybnMgYSBmYWxzeSB2YWx1ZSBvciBpcyBhYm9ydGVkXG4gKi9cbmZ1bmN0aW9uIGxvb3AoY2FsbGJhY2spIHtcbiAgICBsZXQgdGFzaztcbiAgICBpZiAodGFza3Muc2l6ZSA9PT0gMClcbiAgICAgICAgcmFmKHJ1bl90YXNrcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvbWlzZTogbmV3IFByb21pc2UoZnVsZmlsbCA9PiB7XG4gICAgICAgICAgICB0YXNrcy5hZGQodGFzayA9IHsgYzogY2FsbGJhY2ssIGY6IGZ1bGZpbGwgfSk7XG4gICAgICAgIH0pLFxuICAgICAgICBhYm9ydCgpIHtcbiAgICAgICAgICAgIHRhc2tzLmRlbGV0ZSh0YXNrKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8vIFRyYWNrIHdoaWNoIG5vZGVzIGFyZSBjbGFpbWVkIGR1cmluZyBoeWRyYXRpb24uIFVuY2xhaW1lZCBub2RlcyBjYW4gdGhlbiBiZSByZW1vdmVkIGZyb20gdGhlIERPTVxuLy8gYXQgdGhlIGVuZCBvZiBoeWRyYXRpb24gd2l0aG91dCB0b3VjaGluZyB0aGUgcmVtYWluaW5nIG5vZGVzLlxubGV0IGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xuZnVuY3Rpb24gc3RhcnRfaHlkcmF0aW5nKCkge1xuICAgIGlzX2h5ZHJhdGluZyA9IHRydWU7XG59XG5mdW5jdGlvbiBlbmRfaHlkcmF0aW5nKCkge1xuICAgIGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gdXBwZXJfYm91bmQobG93LCBoaWdoLCBrZXksIHZhbHVlKSB7XG4gICAgLy8gUmV0dXJuIGZpcnN0IGluZGV4IG9mIHZhbHVlIGxhcmdlciB0aGFuIGlucHV0IHZhbHVlIGluIHRoZSByYW5nZSBbbG93LCBoaWdoKVxuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIGNvbnN0IG1pZCA9IGxvdyArICgoaGlnaCAtIGxvdykgPj4gMSk7XG4gICAgICAgIGlmIChrZXkobWlkKSA8PSB2YWx1ZSkge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbn1cbmZ1bmN0aW9uIGluaXRfaHlkcmF0ZSh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0Lmh5ZHJhdGVfaW5pdClcbiAgICAgICAgcmV0dXJuO1xuICAgIHRhcmdldC5oeWRyYXRlX2luaXQgPSB0cnVlO1xuICAgIC8vIFdlIGtub3cgdGhhdCBhbGwgY2hpbGRyZW4gaGF2ZSBjbGFpbV9vcmRlciB2YWx1ZXMgc2luY2UgdGhlIHVuY2xhaW1lZCBoYXZlIGJlZW4gZGV0YWNoZWQgaWYgdGFyZ2V0IGlzIG5vdCA8aGVhZD5cbiAgICBsZXQgY2hpbGRyZW4gPSB0YXJnZXQuY2hpbGROb2RlcztcbiAgICAvLyBJZiB0YXJnZXQgaXMgPGhlYWQ+LCB0aGVyZSBtYXkgYmUgY2hpbGRyZW4gd2l0aG91dCBjbGFpbV9vcmRlclxuICAgIGlmICh0YXJnZXQubm9kZU5hbWUgPT09ICdIRUFEJykge1xuICAgICAgICBjb25zdCBteUNoaWxkcmVuID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChub2RlLmNsYWltX29yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBteUNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4gPSBteUNoaWxkcmVuO1xuICAgIH1cbiAgICAvKlxuICAgICogUmVvcmRlciBjbGFpbWVkIGNoaWxkcmVuIG9wdGltYWxseS5cbiAgICAqIFdlIGNhbiByZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5IGJ5IGZpbmRpbmcgdGhlIGxvbmdlc3Qgc3Vic2VxdWVuY2Ugb2ZcbiAgICAqIG5vZGVzIHRoYXQgYXJlIGFscmVhZHkgY2xhaW1lZCBpbiBvcmRlciBhbmQgb25seSBtb3ZpbmcgdGhlIHJlc3QuIFRoZSBsb25nZXN0XG4gICAgKiBzdWJzZXF1ZW5jZSBzdWJzZXF1ZW5jZSBvZiBub2RlcyB0aGF0IGFyZSBjbGFpbWVkIGluIG9yZGVyIGNhbiBiZSBmb3VuZCBieVxuICAgICogY29tcHV0aW5nIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgLmNsYWltX29yZGVyIHZhbHVlcy5cbiAgICAqXG4gICAgKiBUaGlzIGFsZ29yaXRobSBpcyBvcHRpbWFsIGluIGdlbmVyYXRpbmcgdGhlIGxlYXN0IGFtb3VudCBvZiByZW9yZGVyIG9wZXJhdGlvbnNcbiAgICAqIHBvc3NpYmxlLlxuICAgICpcbiAgICAqIFByb29mOlxuICAgICogV2Uga25vdyB0aGF0LCBnaXZlbiBhIHNldCBvZiByZW9yZGVyaW5nIG9wZXJhdGlvbnMsIHRoZSBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlXG4gICAgKiBhbHdheXMgZm9ybSBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLCBzaW5jZSB0aGV5IGRvIG5vdCBtb3ZlIGFtb25nIGVhY2ggb3RoZXJcbiAgICAqIG1lYW5pbmcgdGhhdCB0aGV5IG11c3QgYmUgYWxyZWFkeSBvcmRlcmVkIGFtb25nIGVhY2ggb3RoZXIuIFRodXMsIHRoZSBtYXhpbWFsXG4gICAgKiBzZXQgb2Ygbm9kZXMgdGhhdCBkbyBub3QgbW92ZSBmb3JtIGEgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLlxuICAgICovXG4gICAgLy8gQ29tcHV0ZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2VcbiAgICAvLyBtOiBzdWJzZXF1ZW5jZSBsZW5ndGggaiA9PiBpbmRleCBrIG9mIHNtYWxsZXN0IHZhbHVlIHRoYXQgZW5kcyBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIGxlbmd0aCBqXG4gICAgY29uc3QgbSA9IG5ldyBJbnQzMkFycmF5KGNoaWxkcmVuLmxlbmd0aCArIDEpO1xuICAgIC8vIFByZWRlY2Vzc29yIGluZGljZXMgKyAxXG4gICAgY29uc3QgcCA9IG5ldyBJbnQzMkFycmF5KGNoaWxkcmVuLmxlbmd0aCk7XG4gICAgbVswXSA9IC0xO1xuICAgIGxldCBsb25nZXN0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBjaGlsZHJlbltpXS5jbGFpbV9vcmRlcjtcbiAgICAgICAgLy8gRmluZCB0aGUgbGFyZ2VzdCBzdWJzZXF1ZW5jZSBsZW5ndGggc3VjaCB0aGF0IGl0IGVuZHMgaW4gYSB2YWx1ZSBsZXNzIHRoYW4gb3VyIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgLy8gdXBwZXJfYm91bmQgcmV0dXJucyBmaXJzdCBncmVhdGVyIHZhbHVlLCBzbyB3ZSBzdWJ0cmFjdCBvbmVcbiAgICAgICAgLy8gd2l0aCBmYXN0IHBhdGggZm9yIHdoZW4gd2UgYXJlIG9uIHRoZSBjdXJyZW50IGxvbmdlc3Qgc3Vic2VxdWVuY2VcbiAgICAgICAgY29uc3Qgc2VxTGVuID0gKChsb25nZXN0ID4gMCAmJiBjaGlsZHJlblttW2xvbmdlc3RdXS5jbGFpbV9vcmRlciA8PSBjdXJyZW50KSA/IGxvbmdlc3QgKyAxIDogdXBwZXJfYm91bmQoMSwgbG9uZ2VzdCwgaWR4ID0+IGNoaWxkcmVuW21baWR4XV0uY2xhaW1fb3JkZXIsIGN1cnJlbnQpKSAtIDE7XG4gICAgICAgIHBbaV0gPSBtW3NlcUxlbl0gKyAxO1xuICAgICAgICBjb25zdCBuZXdMZW4gPSBzZXFMZW4gKyAxO1xuICAgICAgICAvLyBXZSBjYW4gZ3VhcmFudGVlIHRoYXQgY3VycmVudCBpcyB0aGUgc21hbGxlc3QgdmFsdWUuIE90aGVyd2lzZSwgd2Ugd291bGQgaGF2ZSBnZW5lcmF0ZWQgYSBsb25nZXIgc2VxdWVuY2UuXG4gICAgICAgIG1bbmV3TGVuXSA9IGk7XG4gICAgICAgIGxvbmdlc3QgPSBNYXRoLm1heChuZXdMZW4sIGxvbmdlc3QpO1xuICAgIH1cbiAgICAvLyBUaGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIG5vZGVzIChpbml0aWFsbHkgcmV2ZXJzZWQpXG4gICAgY29uc3QgbGlzID0gW107XG4gICAgLy8gVGhlIHJlc3Qgb2YgdGhlIG5vZGVzLCBub2RlcyB0aGF0IHdpbGwgYmUgbW92ZWRcbiAgICBjb25zdCB0b01vdmUgPSBbXTtcbiAgICBsZXQgbGFzdCA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgZm9yIChsZXQgY3VyID0gbVtsb25nZXN0XSArIDE7IGN1ciAhPSAwOyBjdXIgPSBwW2N1ciAtIDFdKSB7XG4gICAgICAgIGxpcy5wdXNoKGNoaWxkcmVuW2N1ciAtIDFdKTtcbiAgICAgICAgZm9yICg7IGxhc3QgPj0gY3VyOyBsYXN0LS0pIHtcbiAgICAgICAgICAgIHRvTW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0LS07XG4gICAgfVxuICAgIGZvciAoOyBsYXN0ID49IDA7IGxhc3QtLSkge1xuICAgICAgICB0b01vdmUucHVzaChjaGlsZHJlbltsYXN0XSk7XG4gICAgfVxuICAgIGxpcy5yZXZlcnNlKCk7XG4gICAgLy8gV2Ugc29ydCB0aGUgbm9kZXMgYmVpbmcgbW92ZWQgdG8gZ3VhcmFudGVlIHRoYXQgdGhlaXIgaW5zZXJ0aW9uIG9yZGVyIG1hdGNoZXMgdGhlIGNsYWltIG9yZGVyXG4gICAgdG9Nb3ZlLnNvcnQoKGEsIGIpID0+IGEuY2xhaW1fb3JkZXIgLSBiLmNsYWltX29yZGVyKTtcbiAgICAvLyBGaW5hbGx5LCB3ZSBtb3ZlIHRoZSBub2Rlc1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHRvTW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB3aGlsZSAoaiA8IGxpcy5sZW5ndGggJiYgdG9Nb3ZlW2ldLmNsYWltX29yZGVyID49IGxpc1tqXS5jbGFpbV9vcmRlcikge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IGogPCBsaXMubGVuZ3RoID8gbGlzW2pdIDogbnVsbDtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZSh0b01vdmVbaV0sIGFuY2hvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwZW5kKHRhcmdldCwgbm9kZSkge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9zdHlsZXModGFyZ2V0LCBzdHlsZV9zaGVldF9pZCwgc3R5bGVzKSB7XG4gICAgY29uc3QgYXBwZW5kX3N0eWxlc190byA9IGdldF9yb290X2Zvcl9zdHlsZSh0YXJnZXQpO1xuICAgIGlmICghYXBwZW5kX3N0eWxlc190by5nZXRFbGVtZW50QnlJZChzdHlsZV9zaGVldF9pZCkpIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBlbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZS5pZCA9IHN0eWxlX3NoZWV0X2lkO1xuICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHN0eWxlcztcbiAgICAgICAgYXBwZW5kX3N0eWxlc2hlZXQoYXBwZW5kX3N0eWxlc190bywgc3R5bGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldF9yb290X2Zvcl9zdHlsZShub2RlKSB7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgY29uc3Qgcm9vdCA9IG5vZGUuZ2V0Um9vdE5vZGUgPyBub2RlLmdldFJvb3ROb2RlKCkgOiBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgaWYgKHJvb3QgJiYgcm9vdC5ob3N0KSB7XG4gICAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50O1xufVxuZnVuY3Rpb24gYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQobm9kZSkge1xuICAgIGNvbnN0IHN0eWxlX2VsZW1lbnQgPSBlbGVtZW50KCdzdHlsZScpO1xuICAgIGFwcGVuZF9zdHlsZXNoZWV0KGdldF9yb290X2Zvcl9zdHlsZShub2RlKSwgc3R5bGVfZWxlbWVudCk7XG4gICAgcmV0dXJuIHN0eWxlX2VsZW1lbnQuc2hlZXQ7XG59XG5mdW5jdGlvbiBhcHBlbmRfc3R5bGVzaGVldChub2RlLCBzdHlsZSkge1xuICAgIGFwcGVuZChub2RlLmhlYWQgfHwgbm9kZSwgc3R5bGUpO1xufVxuZnVuY3Rpb24gYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpIHtcbiAgICBpZiAoaXNfaHlkcmF0aW5nKSB7XG4gICAgICAgIGluaXRfaHlkcmF0ZSh0YXJnZXQpO1xuICAgICAgICBpZiAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID09PSB1bmRlZmluZWQpIHx8ICgodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgIT09IG51bGwpICYmICh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZC5wYXJlbnRFbGVtZW50ICE9PSB0YXJnZXQpKSkge1xuICAgICAgICAgICAgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSB0YXJnZXQuZmlyc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTa2lwIG5vZGVzIG9mIHVuZGVmaW5lZCBvcmRlcmluZ1xuICAgICAgICB3aGlsZSAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsKSAmJiAodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQuY2xhaW1fb3JkZXIgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgIT09IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKSB7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IGluc2VydCBpZiB0aGUgb3JkZXJpbmcgb2YgdGhpcyBub2RlIHNob3VsZCBiZSBtb2RpZmllZCBvciB0aGUgcGFyZW50IG5vZGUgaXMgbm90IHRhcmdldFxuICAgICAgICAgICAgaWYgKG5vZGUuY2xhaW1fb3JkZXIgIT09IHVuZGVmaW5lZCB8fCBub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGlmIChpc19oeWRyYXRpbmcgJiYgIWFuY2hvcikge1xuICAgICAgICBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gdGFyZ2V0IHx8IG5vZGUubmV4dFNpYmxpbmcgIT0gYW5jaG9yKSB7XG4gICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaChub2RlKSB7XG4gICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuZnVuY3Rpb24gZGVzdHJveV9lYWNoKGl0ZXJhdGlvbnMsIGRldGFjaGluZykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoaXRlcmF0aW9uc1tpXSlcbiAgICAgICAgICAgIGl0ZXJhdGlvbnNbaV0uZChkZXRhY2hpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVsZW1lbnQobmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xufVxuZnVuY3Rpb24gZWxlbWVudF9pcyhuYW1lLCBpcykge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUsIHsgaXMgfSk7XG59XG5mdW5jdGlvbiBvYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzKG9iaiwgZXhjbHVkZSkge1xuICAgIGNvbnN0IHRhcmdldCA9IHt9O1xuICAgIGZvciAoY29uc3QgayBpbiBvYmopIHtcbiAgICAgICAgaWYgKGhhc19wcm9wKG9iaiwgaylcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICYmIGV4Y2x1ZGUuaW5kZXhPZihrKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRhcmdldFtrXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gc3ZnX2VsZW1lbnQobmFtZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbmFtZSk7XG59XG5mdW5jdGlvbiB0ZXh0KGRhdGEpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSk7XG59XG5mdW5jdGlvbiBzcGFjZSgpIHtcbiAgICByZXR1cm4gdGV4dCgnICcpO1xufVxuZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgcmV0dXJuIHRleHQoJycpO1xufVxuZnVuY3Rpb24gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHByZXZlbnRfZGVmYXVsdChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN0b3BfcHJvcGFnYXRpb24oZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc2VsZihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzKVxuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRydXN0ZWQoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGV2ZW50LmlzVHJ1c3RlZClcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICBlbHNlIGlmIChub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpICE9PSB2YWx1ZSlcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobm9kZS5fX3Byb3RvX18pO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5jc3NUZXh0ID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ19fdmFsdWUnKSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gbm9kZVtrZXldID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlc2NyaXB0b3JzW2tleV0gJiYgZGVzY3JpcHRvcnNba2V5XS5zZXQpIHtcbiAgICAgICAgICAgIG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X3N2Z19hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGF0dHIobm9kZSwga2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9jdXN0b21fZWxlbWVudF9kYXRhKG5vZGUsIHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKHByb3AgaW4gbm9kZSkge1xuICAgICAgICBub2RlW3Byb3BdID0gdHlwZW9mIG5vZGVbcHJvcF0gPT09ICdib29sZWFuJyAmJiB2YWx1ZSA9PT0gJycgPyB0cnVlIDogdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhdHRyKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB4bGlua19hdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgYXR0cmlidXRlLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cF92YWx1ZShncm91cCwgX192YWx1ZSwgY2hlY2tlZCkge1xuICAgIGNvbnN0IHZhbHVlID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGdyb3VwW2ldLmNoZWNrZWQpXG4gICAgICAgICAgICB2YWx1ZS5hZGQoZ3JvdXBbaV0uX192YWx1ZSk7XG4gICAgfVxuICAgIGlmICghY2hlY2tlZCkge1xuICAgICAgICB2YWx1ZS5kZWxldGUoX192YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHRvX251bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gJycgPyBudWxsIDogK3ZhbHVlO1xufVxuZnVuY3Rpb24gdGltZV9yYW5nZXNfdG9fYXJyYXkocmFuZ2VzKSB7XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBhcnJheS5wdXNoKHsgc3RhcnQ6IHJhbmdlcy5zdGFydChpKSwgZW5kOiByYW5nZXMuZW5kKGkpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiBjaGlsZHJlbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5jaGlsZE5vZGVzKTtcbn1cbmZ1bmN0aW9uIGluaXRfY2xhaW1faW5mbyhub2Rlcykge1xuICAgIGlmIChub2Rlcy5jbGFpbV9pbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZXMuY2xhaW1faW5mbyA9IHsgbGFzdF9pbmRleDogMCwgdG90YWxfY2xhaW1lZDogMCB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsYWltX25vZGUobm9kZXMsIHByZWRpY2F0ZSwgcHJvY2Vzc05vZGUsIGNyZWF0ZU5vZGUsIGRvbnRVcGRhdGVMYXN0SW5kZXggPSBmYWxzZSkge1xuICAgIC8vIFRyeSB0byBmaW5kIG5vZGVzIGluIGFuIG9yZGVyIHN1Y2ggdGhhdCB3ZSBsZW5ndGhlbiB0aGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlXG4gICAgaW5pdF9jbGFpbV9pbmZvKG5vZGVzKTtcbiAgICBjb25zdCByZXN1bHROb2RlID0gKCgpID0+IHtcbiAgICAgICAgLy8gV2UgZmlyc3QgdHJ5IHRvIGZpbmQgYW4gZWxlbWVudCBhZnRlciB0aGUgcHJldmlvdXMgb25lXG4gICAgICAgIGZvciAobGV0IGkgPSBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXg7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc05vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkb250VXBkYXRlTGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgdHJ5IHRvIGZpbmQgb25lIGJlZm9yZVxuICAgICAgICAvLyBXZSBpdGVyYXRlIGluIHJldmVyc2Ugc28gdGhhdCB3ZSBkb24ndCBnbyB0b28gZmFyIGJhY2tcbiAgICAgICAgZm9yIChsZXQgaSA9IG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBwcm9jZXNzTm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRvbnRVcGRhdGVMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVwbGFjZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB3ZSBzcGxpY2VkIGJlZm9yZSB0aGUgbGFzdF9pbmRleCwgd2UgZGVjcmVhc2UgaXRcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGNhbid0IGZpbmQgYW55IG1hdGNoaW5nIG5vZGUsIHdlIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU5vZGUoKTtcbiAgICB9KSgpO1xuICAgIHJlc3VsdE5vZGUuY2xhaW1fb3JkZXIgPSBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQ7XG4gICAgbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkICs9IDE7XG4gICAgcmV0dXJuIHJlc3VsdE5vZGU7XG59XG5mdW5jdGlvbiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGNyZWF0ZV9lbGVtZW50KSB7XG4gICAgcmV0dXJuIGNsYWltX25vZGUobm9kZXMsIChub2RlKSA9PiBub2RlLm5vZGVOYW1lID09PSBuYW1lLCAobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCByZW1vdmUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IG5vZGUuYXR0cmlidXRlc1tqXTtcbiAgICAgICAgICAgIGlmICghYXR0cmlidXRlc1thdHRyaWJ1dGUubmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZW1vdmUucHVzaChhdHRyaWJ1dGUubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlLmZvckVhY2godiA9PiBub2RlLnJlbW92ZUF0dHJpYnV0ZSh2KSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSwgKCkgPT4gY3JlYXRlX2VsZW1lbnQobmFtZSkpO1xufVxuZnVuY3Rpb24gY2xhaW1fZWxlbWVudChub2RlcywgbmFtZSwgYXR0cmlidXRlcykge1xuICAgIHJldHVybiBjbGFpbV9lbGVtZW50X2Jhc2Uobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMsIGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gY2xhaW1fc3ZnX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBzdmdfZWxlbWVudCk7XG59XG5mdW5jdGlvbiBjbGFpbV90ZXh0KG5vZGVzLCBkYXRhKSB7XG4gICAgcmV0dXJuIGNsYWltX25vZGUobm9kZXMsIChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSAzLCAobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhU3RyID0gJycgKyBkYXRhO1xuICAgICAgICBpZiAobm9kZS5kYXRhLnN0YXJ0c1dpdGgoZGF0YVN0cikpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmRhdGEubGVuZ3RoICE9PSBkYXRhU3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnNwbGl0VGV4dChkYXRhU3RyLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlLmRhdGEgPSBkYXRhU3RyO1xuICAgICAgICB9XG4gICAgfSwgKCkgPT4gdGV4dChkYXRhKSwgdHJ1ZSAvLyBUZXh0IG5vZGVzIHNob3VsZCBub3QgdXBkYXRlIGxhc3QgaW5kZXggc2luY2UgaXQgaXMgbGlrZWx5IG5vdCB3b3J0aCBpdCB0byBlbGltaW5hdGUgYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBhY3R1YWwgZWxlbWVudHNcbiAgICApO1xufVxuZnVuY3Rpb24gY2xhaW1fc3BhY2Uobm9kZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fdGV4dChub2RlcywgJyAnKTtcbn1cbmZ1bmN0aW9uIGZpbmRfY29tbWVudChub2RlcywgdGV4dCwgc3RhcnQpIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIGNvbW1lbnQgbm9kZSAqLyAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSA9PT0gdGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGNsYWltX2h0bWxfdGFnKG5vZGVzLCBpc19zdmcpIHtcbiAgICAvLyBmaW5kIGh0bWwgb3BlbmluZyB0YWdcbiAgICBjb25zdCBzdGFydF9pbmRleCA9IGZpbmRfY29tbWVudChub2RlcywgJ0hUTUxfVEFHX1NUQVJUJywgMCk7XG4gICAgY29uc3QgZW5kX2luZGV4ID0gZmluZF9jb21tZW50KG5vZGVzLCAnSFRNTF9UQUdfRU5EJywgc3RhcnRfaW5kZXgpO1xuICAgIGlmIChzdGFydF9pbmRleCA9PT0gZW5kX2luZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbih1bmRlZmluZWQsIGlzX3N2Zyk7XG4gICAgfVxuICAgIGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG4gICAgY29uc3QgaHRtbF90YWdfbm9kZXMgPSBub2Rlcy5zcGxpY2Uoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSk7XG4gICAgZGV0YWNoKGh0bWxfdGFnX25vZGVzWzBdKTtcbiAgICBkZXRhY2goaHRtbF90YWdfbm9kZXNbaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMV0pO1xuICAgIGNvbnN0IGNsYWltZWRfbm9kZXMgPSBodG1sX3RhZ19ub2Rlcy5zbGljZSgxLCBodG1sX3RhZ19ub2Rlcy5sZW5ndGggLSAxKTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgY2xhaW1lZF9ub2Rlcykge1xuICAgICAgICBuLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLnRvdGFsX2NsYWltZWQgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIdG1sVGFnSHlkcmF0aW9uKGNsYWltZWRfbm9kZXMsIGlzX3N2Zyk7XG59XG5mdW5jdGlvbiBzZXRfZGF0YSh0ZXh0LCBkYXRhKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgICBpZiAodGV4dC53aG9sZVRleHQgIT09IGRhdGEpXG4gICAgICAgIHRleHQuZGF0YSA9IGRhdGE7XG59XG5mdW5jdGlvbiBzZXRfaW5wdXRfdmFsdWUoaW5wdXQsIHZhbHVlKSB7XG4gICAgaW5wdXQudmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldF9pbnB1dF90eXBlKGlucHV0LCB0eXBlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaW5wdXQudHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfc3R5bGUobm9kZSwga2V5LCB2YWx1ZSwgaW1wb3J0YW50KSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIG5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkoa2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSwgaW1wb3J0YW50ID8gJ2ltcG9ydGFudCcgOiAnJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0X29wdGlvbihzZWxlY3QsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcbiAgICAgICAgaWYgKG9wdGlvbi5fX3ZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3Quc2VsZWN0ZWRJbmRleCA9IC0xOyAvLyBubyBvcHRpb24gc2hvdWxkIGJlIHNlbGVjdGVkXG59XG5mdW5jdGlvbiBzZWxlY3Rfb3B0aW9ucyhzZWxlY3QsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Qub3B0aW9ucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBzZWxlY3Qub3B0aW9uc1tpXTtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gfnZhbHVlLmluZGV4T2Yob3B0aW9uLl9fdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdF92YWx1ZShzZWxlY3QpIHtcbiAgICBjb25zdCBzZWxlY3RlZF9vcHRpb24gPSBzZWxlY3QucXVlcnlTZWxlY3RvcignOmNoZWNrZWQnKSB8fCBzZWxlY3Qub3B0aW9uc1swXTtcbiAgICByZXR1cm4gc2VsZWN0ZWRfb3B0aW9uICYmIHNlbGVjdGVkX29wdGlvbi5fX3ZhbHVlO1xufVxuZnVuY3Rpb24gc2VsZWN0X211bHRpcGxlX3ZhbHVlKHNlbGVjdCkge1xuICAgIHJldHVybiBbXS5tYXAuY2FsbChzZWxlY3QucXVlcnlTZWxlY3RvckFsbCgnOmNoZWNrZWQnKSwgb3B0aW9uID0+IG9wdGlvbi5fX3ZhbHVlKTtcbn1cbi8vIHVuZm9ydHVuYXRlbHkgdGhpcyBjYW4ndCBiZSBhIGNvbnN0YW50IGFzIHRoYXQgd291bGRuJ3QgYmUgdHJlZS1zaGFrZWFibGVcbi8vIHNvIHdlIGNhY2hlIHRoZSByZXN1bHQgaW5zdGVhZFxubGV0IGNyb3Nzb3JpZ2luO1xuZnVuY3Rpb24gaXNfY3Jvc3NvcmlnaW4oKSB7XG4gICAgaWYgKGNyb3Nzb3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3Jvc3NvcmlnaW4gPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdm9pZCB3aW5kb3cucGFyZW50LmRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY3Jvc3NvcmlnaW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcm9zc29yaWdpbjtcbn1cbmZ1bmN0aW9uIGFkZF9yZXNpemVfbGlzdGVuZXIobm9kZSwgZm4pIHtcbiAgICBjb25zdCBjb21wdXRlZF9zdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgaWYgKGNvbXB1dGVkX3N0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB9XG4gICAgY29uc3QgaWZyYW1lID0gZWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogYmxvY2s7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyAnICtcbiAgICAgICAgJ292ZXJmbG93OiBoaWRkZW47IGJvcmRlcjogMDsgb3BhY2l0eTogMDsgcG9pbnRlci1ldmVudHM6IG5vbmU7IHotaW5kZXg6IC0xOycpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICBpZnJhbWUudGFiSW5kZXggPSAtMTtcbiAgICBjb25zdCBjcm9zc29yaWdpbiA9IGlzX2Nyb3Nzb3JpZ2luKCk7XG4gICAgbGV0IHVuc3Vic2NyaWJlO1xuICAgIGlmIChjcm9zc29yaWdpbikge1xuICAgICAgICBpZnJhbWUuc3JjID0gXCJkYXRhOnRleHQvaHRtbCw8c2NyaXB0Pm9ucmVzaXplPWZ1bmN0aW9uKCl7cGFyZW50LnBvc3RNZXNzYWdlKDAsJyonKX08L3NjcmlwdD5cIjtcbiAgICAgICAgdW5zdWJzY3JpYmUgPSBsaXN0ZW4od2luZG93LCAnbWVzc2FnZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gaWZyYW1lLmNvbnRlbnRXaW5kb3cpXG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZnJhbWUuc3JjID0gJ2Fib3V0OmJsYW5rJztcbiAgICAgICAgaWZyYW1lLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlID0gbGlzdGVuKGlmcmFtZS5jb250ZW50V2luZG93LCAncmVzaXplJywgZm4pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhcHBlbmQobm9kZSwgaWZyYW1lKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoY3Jvc3NvcmlnaW4pIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodW5zdWJzY3JpYmUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWNoKGlmcmFtZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZV9jbGFzcyhlbGVtZW50LCBuYW1lLCB0b2dnbGUpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdFt0b2dnbGUgPyAnYWRkJyA6ICdyZW1vdmUnXShuYW1lKTtcbn1cbmZ1bmN0aW9uIGN1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwsIHsgYnViYmxlcyA9IGZhbHNlLCBjYW5jZWxhYmxlID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgIGUuaW5pdEN1c3RvbUV2ZW50KHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUsIGRldGFpbCk7XG4gICAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBxdWVyeV9zZWxlY3Rvcl9hbGwoc2VsZWN0b3IsIHBhcmVudCA9IGRvY3VtZW50LmJvZHkpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShwYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xufVxuY2xhc3MgSHRtbFRhZyB7XG4gICAgY29uc3RydWN0b3IoaXNfc3ZnID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5pc19zdmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc19zdmcgPSBpc19zdmc7XG4gICAgICAgIHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG4gICAgfVxuICAgIGMoaHRtbCkge1xuICAgICAgICB0aGlzLmgoaHRtbCk7XG4gICAgfVxuICAgIG0oaHRtbCwgdGFyZ2V0LCBhbmNob3IgPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc19zdmcpXG4gICAgICAgICAgICAgICAgdGhpcy5lID0gc3ZnX2VsZW1lbnQodGFyZ2V0Lm5vZGVOYW1lKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmUgPSBlbGVtZW50KHRhcmdldC5ub2RlTmFtZSk7XG4gICAgICAgICAgICB0aGlzLnQgPSB0YXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmMoaHRtbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pKGFuY2hvcik7XG4gICAgfVxuICAgIGgoaHRtbCkge1xuICAgICAgICB0aGlzLmUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgdGhpcy5uID0gQXJyYXkuZnJvbSh0aGlzLmUuY2hpbGROb2Rlcyk7XG4gICAgfVxuICAgIGkoYW5jaG9yKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbnNlcnQodGhpcy50LCB0aGlzLm5baV0sIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcChodG1sKSB7XG4gICAgICAgIHRoaXMuZCgpO1xuICAgICAgICB0aGlzLmgoaHRtbCk7XG4gICAgICAgIHRoaXMuaSh0aGlzLmEpO1xuICAgIH1cbiAgICBkKCkge1xuICAgICAgICB0aGlzLm4uZm9yRWFjaChkZXRhY2gpO1xuICAgIH1cbn1cbmNsYXNzIEh0bWxUYWdIeWRyYXRpb24gZXh0ZW5kcyBIdG1sVGFnIHtcbiAgICBjb25zdHJ1Y3RvcihjbGFpbWVkX25vZGVzLCBpc19zdmcgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcihpc19zdmcpO1xuICAgICAgICB0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuICAgICAgICB0aGlzLmwgPSBjbGFpbWVkX25vZGVzO1xuICAgIH1cbiAgICBjKGh0bWwpIHtcbiAgICAgICAgaWYgKHRoaXMubCkge1xuICAgICAgICAgICAgdGhpcy5uID0gdGhpcy5sO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIuYyhodG1sKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpKGFuY2hvcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5zZXJ0X2h5ZHJhdGlvbih0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGF0dHJpYnV0ZV90b19vYmplY3QoYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmVzdWx0W2F0dHJpYnV0ZS5uYW1lXSA9IGF0dHJpYnV0ZS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHMoZWxlbWVudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGVsZW1lbnQuY2hpbGROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIHJlc3VsdFtub2RlLnNsb3QgfHwgJ2RlZmF1bHQnXSA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gd2UgbmVlZCB0byBzdG9yZSB0aGUgaW5mb3JtYXRpb24gZm9yIG11bHRpcGxlIGRvY3VtZW50cyBiZWNhdXNlIGEgU3ZlbHRlIGFwcGxpY2F0aW9uIGNvdWxkIGFsc28gY29udGFpbiBpZnJhbWVzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy8zNjI0XG5jb25zdCBtYW5hZ2VkX3N0eWxlcyA9IG5ldyBNYXAoKTtcbmxldCBhY3RpdmUgPSAwO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2gvYmxvYi9tYXN0ZXIvaW5kZXguanNcbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gICAgbGV0IGhhc2ggPSA1MzgxO1xuICAgIGxldCBpID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgXiBzdHIuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gaGFzaCA+Pj4gMDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9zdHlsZV9pbmZvcm1hdGlvbihkb2MsIG5vZGUpIHtcbiAgICBjb25zdCBpbmZvID0geyBzdHlsZXNoZWV0OiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSwgcnVsZXM6IHt9IH07XG4gICAgbWFuYWdlZF9zdHlsZXMuc2V0KGRvYywgaW5mbyk7XG4gICAgcmV0dXJuIGluZm87XG59XG5mdW5jdGlvbiBjcmVhdGVfcnVsZShub2RlLCBhLCBiLCBkdXJhdGlvbiwgZGVsYXksIGVhc2UsIGZuLCB1aWQgPSAwKSB7XG4gICAgY29uc3Qgc3RlcCA9IDE2LjY2NiAvIGR1cmF0aW9uO1xuICAgIGxldCBrZXlmcmFtZXMgPSAne1xcbic7XG4gICAgZm9yIChsZXQgcCA9IDA7IHAgPD0gMTsgcCArPSBzdGVwKSB7XG4gICAgICAgIGNvbnN0IHQgPSBhICsgKGIgLSBhKSAqIGVhc2UocCk7XG4gICAgICAgIGtleWZyYW1lcyArPSBwICogMTAwICsgYCV7JHtmbih0LCAxIC0gdCl9fVxcbmA7XG4gICAgfVxuICAgIGNvbnN0IHJ1bGUgPSBrZXlmcmFtZXMgKyBgMTAwJSB7JHtmbihiLCAxIC0gYil9fVxcbn1gO1xuICAgIGNvbnN0IG5hbWUgPSBgX19zdmVsdGVfJHtoYXNoKHJ1bGUpfV8ke3VpZH1gO1xuICAgIGNvbnN0IGRvYyA9IGdldF9yb290X2Zvcl9zdHlsZShub2RlKTtcbiAgICBjb25zdCB7IHN0eWxlc2hlZXQsIHJ1bGVzIH0gPSBtYW5hZ2VkX3N0eWxlcy5nZXQoZG9jKSB8fCBjcmVhdGVfc3R5bGVfaW5mb3JtYXRpb24oZG9jLCBub2RlKTtcbiAgICBpZiAoIXJ1bGVzW25hbWVdKSB7XG4gICAgICAgIHJ1bGVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgc3R5bGVzaGVldC5pbnNlcnRSdWxlKGBAa2V5ZnJhbWVzICR7bmFtZX0gJHtydWxlfWAsIHN0eWxlc2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9uID0gbm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJyc7XG4gICAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSBgJHthbmltYXRpb24gPyBgJHthbmltYXRpb259LCBgIDogJyd9JHtuYW1lfSAke2R1cmF0aW9ufW1zIGxpbmVhciAke2RlbGF5fW1zIDEgYm90aGA7XG4gICAgYWN0aXZlICs9IDE7XG4gICAgcmV0dXJuIG5hbWU7XG59XG5mdW5jdGlvbiBkZWxldGVfcnVsZShub2RlLCBuYW1lKSB7XG4gICAgY29uc3QgcHJldmlvdXMgPSAobm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIGNvbnN0IG5leHQgPSBwcmV2aW91cy5maWx0ZXIobmFtZVxuICAgICAgICA/IGFuaW0gPT4gYW5pbS5pbmRleE9mKG5hbWUpIDwgMCAvLyByZW1vdmUgc3BlY2lmaWMgYW5pbWF0aW9uXG4gICAgICAgIDogYW5pbSA9PiBhbmltLmluZGV4T2YoJ19fc3ZlbHRlJykgPT09IC0xIC8vIHJlbW92ZSBhbGwgU3ZlbHRlIGFuaW1hdGlvbnNcbiAgICApO1xuICAgIGNvbnN0IGRlbGV0ZWQgPSBwcmV2aW91cy5sZW5ndGggLSBuZXh0Lmxlbmd0aDtcbiAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICBub2RlLnN0eWxlLmFuaW1hdGlvbiA9IG5leHQuam9pbignLCAnKTtcbiAgICAgICAgYWN0aXZlIC09IGRlbGV0ZWQ7XG4gICAgICAgIGlmICghYWN0aXZlKVxuICAgICAgICAgICAgY2xlYXJfcnVsZXMoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGVhcl9ydWxlcygpIHtcbiAgICByYWYoKCkgPT4ge1xuICAgICAgICBpZiAoYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBtYW5hZ2VkX3N0eWxlcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzdHlsZXNoZWV0IH0gPSBpbmZvO1xuICAgICAgICAgICAgbGV0IGkgPSBzdHlsZXNoZWV0LmNzc1J1bGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgc3R5bGVzaGVldC5kZWxldGVSdWxlKGkpO1xuICAgICAgICAgICAgaW5mby5ydWxlcyA9IHt9O1xuICAgICAgICB9KTtcbiAgICAgICAgbWFuYWdlZF9zdHlsZXMuY2xlYXIoKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2FuaW1hdGlvbihub2RlLCBmcm9tLCBmbiwgcGFyYW1zKSB7XG4gICAgaWYgKCFmcm9tKVxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICBjb25zdCB0byA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGZyb20ubGVmdCA9PT0gdG8ubGVmdCAmJiBmcm9tLnJpZ2h0ID09PSB0by5yaWdodCAmJiBmcm9tLnRvcCA9PT0gdG8udG9wICYmIGZyb20uYm90dG9tID09PSB0by5ib3R0b20pXG4gICAgICAgIHJldHVybiBub29wO1xuICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIFxuICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogc2hvdWxkIHRoaXMgYmUgc2VwYXJhdGVkIGZyb20gZGVzdHJ1Y3R1cmluZz8gT3Igc3RhcnQvZW5kIGFkZGVkIHRvIHB1YmxpYyBhcGkgYW5kIGRvY3VtZW50YXRpb24/XG4gICAgc3RhcnQ6IHN0YXJ0X3RpbWUgPSBub3coKSArIGRlbGF5LCBcbiAgICAvLyBAdHMtaWdub3JlIHRvZG86XG4gICAgZW5kID0gc3RhcnRfdGltZSArIGR1cmF0aW9uLCB0aWNrID0gbm9vcCwgY3NzIH0gPSBmbihub2RlLCB7IGZyb20sIHRvIH0sIHBhcmFtcyk7XG4gICAgbGV0IHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxldCBzdGFydGVkID0gZmFsc2U7XG4gICAgbGV0IG5hbWU7XG4gICAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAwLCAxLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlbGF5KSB7XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICBpZiAoY3NzKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgbmFtZSk7XG4gICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgbG9vcChub3cgPT4ge1xuICAgICAgICBpZiAoIXN0YXJ0ZWQgJiYgbm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydGVkICYmIG5vdyA+PSBlbmQpIHtcbiAgICAgICAgICAgIHRpY2soMSwgMCk7XG4gICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFydW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBub3cgLSBzdGFydF90aW1lO1xuICAgICAgICAgICAgY29uc3QgdCA9IDAgKyAxICogZWFzaW5nKHAgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBzdGFydCgpO1xuICAgIHRpY2soMCwgMSk7XG4gICAgcmV0dXJuIHN0b3A7XG59XG5mdW5jdGlvbiBmaXhfcG9zaXRpb24obm9kZSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBpZiAoc3R5bGUucG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgc3R5bGUucG9zaXRpb24gIT09ICdmaXhlZCcpIHtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBzdHlsZTtcbiAgICAgICAgY29uc3QgYSA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBub2RlLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBhZGRfdHJhbnNmb3JtKG5vZGUsIGEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZF90cmFuc2Zvcm0obm9kZSwgYSkge1xuICAgIGNvbnN0IGIgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChhLmxlZnQgIT09IGIubGVmdCB8fCBhLnRvcCAhPT0gYi50b3ApIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9IGAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7YS5sZWZ0IC0gYi5sZWZ0fXB4LCAke2EudG9wIC0gYi50b3B9cHgpYDtcbiAgICB9XG59XG5cbmxldCBjdXJyZW50X2NvbXBvbmVudDtcbmZ1bmN0aW9uIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICBjdXJyZW50X2NvbXBvbmVudCA9IGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGdldF9jdXJyZW50X2NvbXBvbmVudCgpIHtcbiAgICBpZiAoIWN1cnJlbnRfY29tcG9uZW50KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGNhbGxlZCBvdXRzaWRlIGNvbXBvbmVudCBpbml0aWFsaXphdGlvbicpO1xuICAgIHJldHVybiBjdXJyZW50X2NvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGJlZm9yZVVwZGF0ZShmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmJlZm9yZV91cGRhdGUucHVzaChmbik7XG59XG5mdW5jdGlvbiBvbk1vdW50KGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fbW91bnQucHVzaChmbik7XG59XG5mdW5jdGlvbiBhZnRlclVwZGF0ZShmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmFmdGVyX3VwZGF0ZS5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIG9uRGVzdHJveShmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX2Rlc3Ryb3kucHVzaChmbik7XG59XG5mdW5jdGlvbiBjcmVhdGVFdmVudERpc3BhdGNoZXIoKSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG4gICAgcmV0dXJuICh0eXBlLCBkZXRhaWwsIHsgY2FuY2VsYWJsZSA9IGZhbHNlIH0gPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW3R5cGVdO1xuICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGFyZSB0aGVyZSBzaXR1YXRpb25zIHdoZXJlIGV2ZW50cyBjb3VsZCBiZSBkaXNwYXRjaGVkXG4gICAgICAgICAgICAvLyBpbiBhIHNlcnZlciAobm9uLURPTSkgZW52aXJvbm1lbnQ/XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGN1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwsIHsgY2FuY2VsYWJsZSB9KTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goZm4gPT4ge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY29tcG9uZW50LCBldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc2V0Q29udGV4dChrZXksIGNvbnRleHQpIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0LnNldChrZXksIGNvbnRleHQpO1xuICAgIHJldHVybiBjb250ZXh0O1xufVxuZnVuY3Rpb24gZ2V0Q29udGV4dChrZXkpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5nZXQoa2V5KTtcbn1cbmZ1bmN0aW9uIGdldEFsbENvbnRleHRzKCkge1xuICAgIHJldHVybiBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5jb250ZXh0O1xufVxuZnVuY3Rpb24gaGFzQ29udGV4dChrZXkpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5oYXMoa2V5KTtcbn1cbi8vIFRPRE8gZmlndXJlIG91dCBpZiB3ZSBzdGlsbCB3YW50IHRvIHN1cHBvcnRcbi8vIHNob3J0aGFuZCBldmVudHMsIG9yIGlmIHdlIHdhbnQgdG8gaW1wbGVtZW50XG4vLyBhIHJlYWwgYnViYmxpbmcgbWVjaGFuaXNtXG5mdW5jdGlvbiBidWJibGUoY29tcG9uZW50LCBldmVudCkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbZXZlbnQudHlwZV07XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goZm4gPT4gZm4uY2FsbCh0aGlzLCBldmVudCkpO1xuICAgIH1cbn1cblxuY29uc3QgZGlydHlfY29tcG9uZW50cyA9IFtdO1xuY29uc3QgaW50cm9zID0geyBlbmFibGVkOiBmYWxzZSB9O1xuY29uc3QgYmluZGluZ19jYWxsYmFja3MgPSBbXTtcbmNvbnN0IHJlbmRlcl9jYWxsYmFja3MgPSBbXTtcbmNvbnN0IGZsdXNoX2NhbGxiYWNrcyA9IFtdO1xuY29uc3QgcmVzb2x2ZWRfcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xubGV0IHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIHNjaGVkdWxlX3VwZGF0ZSgpIHtcbiAgICBpZiAoIXVwZGF0ZV9zY2hlZHVsZWQpIHtcbiAgICAgICAgdXBkYXRlX3NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgIHJlc29sdmVkX3Byb21pc2UudGhlbihmbHVzaCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdGljaygpIHtcbiAgICBzY2hlZHVsZV91cGRhdGUoKTtcbiAgICByZXR1cm4gcmVzb2x2ZWRfcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGFkZF9yZW5kZXJfY2FsbGJhY2soZm4pIHtcbiAgICByZW5kZXJfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuZnVuY3Rpb24gYWRkX2ZsdXNoX2NhbGxiYWNrKGZuKSB7XG4gICAgZmx1c2hfY2FsbGJhY2tzLnB1c2goZm4pO1xufVxuLy8gZmx1c2goKSBjYWxscyBjYWxsYmFja3MgaW4gdGhpcyBvcmRlcjpcbi8vIDEuIEFsbCBiZWZvcmVVcGRhdGUgY2FsbGJhY2tzLCBpbiBvcmRlcjogcGFyZW50cyBiZWZvcmUgY2hpbGRyZW5cbi8vIDIuIEFsbCBiaW5kOnRoaXMgY2FsbGJhY2tzLCBpbiByZXZlcnNlIG9yZGVyOiBjaGlsZHJlbiBiZWZvcmUgcGFyZW50cy5cbi8vIDMuIEFsbCBhZnRlclVwZGF0ZSBjYWxsYmFja3MsIGluIG9yZGVyOiBwYXJlbnRzIGJlZm9yZSBjaGlsZHJlbi4gRVhDRVBUXG4vLyAgICBmb3IgYWZ0ZXJVcGRhdGVzIGNhbGxlZCBkdXJpbmcgdGhlIGluaXRpYWwgb25Nb3VudCwgd2hpY2ggYXJlIGNhbGxlZCBpblxuLy8gICAgcmV2ZXJzZSBvcmRlcjogY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMuXG4vLyBTaW5jZSBjYWxsYmFja3MgbWlnaHQgdXBkYXRlIGNvbXBvbmVudCB2YWx1ZXMsIHdoaWNoIGNvdWxkIHRyaWdnZXIgYW5vdGhlclxuLy8gY2FsbCB0byBmbHVzaCgpLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGd1YXJkIGFnYWluc3QgdGhpczpcbi8vIDEuIER1cmluZyBiZWZvcmVVcGRhdGUsIGFueSB1cGRhdGVkIGNvbXBvbmVudHMgd2lsbCBiZSBhZGRlZCB0byB0aGVcbi8vICAgIGRpcnR5X2NvbXBvbmVudHMgYXJyYXkgYW5kIHdpbGwgY2F1c2UgYSByZWVudHJhbnQgY2FsbCB0byBmbHVzaCgpLiBCZWNhdXNlXG4vLyAgICB0aGUgZmx1c2ggaW5kZXggaXMga2VwdCBvdXRzaWRlIHRoZSBmdW5jdGlvbiwgdGhlIHJlZW50cmFudCBjYWxsIHdpbGwgcGlja1xuLy8gICAgdXAgd2hlcmUgdGhlIGVhcmxpZXIgY2FsbCBsZWZ0IG9mZiBhbmQgZ28gdGhyb3VnaCBhbGwgZGlydHkgY29tcG9uZW50cy4gVGhlXG4vLyAgICBjdXJyZW50X2NvbXBvbmVudCB2YWx1ZSBpcyBzYXZlZCBhbmQgcmVzdG9yZWQgc28gdGhhdCB0aGUgcmVlbnRyYW50IGNhbGwgd2lsbFxuLy8gICAgbm90IGludGVyZmVyZSB3aXRoIHRoZSBcInBhcmVudFwiIGZsdXNoKCkgY2FsbC5cbi8vIDIuIGJpbmQ6dGhpcyBjYWxsYmFja3MgY2Fubm90IHRyaWdnZXIgbmV3IGZsdXNoKCkgY2FsbHMuXG4vLyAzLiBEdXJpbmcgYWZ0ZXJVcGRhdGUsIGFueSB1cGRhdGVkIGNvbXBvbmVudHMgd2lsbCBOT1QgaGF2ZSB0aGVpciBhZnRlclVwZGF0ZVxuLy8gICAgY2FsbGJhY2sgY2FsbGVkIGEgc2Vjb25kIHRpbWU7IHRoZSBzZWVuX2NhbGxiYWNrcyBzZXQsIG91dHNpZGUgdGhlIGZsdXNoKClcbi8vICAgIGZ1bmN0aW9uLCBndWFyYW50ZWVzIHRoaXMgYmVoYXZpb3IuXG5jb25zdCBzZWVuX2NhbGxiYWNrcyA9IG5ldyBTZXQoKTtcbmxldCBmbHVzaGlkeCA9IDA7IC8vIERvICpub3QqIG1vdmUgdGhpcyBpbnNpZGUgdGhlIGZsdXNoKCkgZnVuY3Rpb25cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIGNvbnN0IHNhdmVkX2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgIGRvIHtcbiAgICAgICAgLy8gZmlyc3QsIGNhbGwgYmVmb3JlVXBkYXRlIGZ1bmN0aW9uc1xuICAgICAgICAvLyBhbmQgdXBkYXRlIGNvbXBvbmVudHNcbiAgICAgICAgd2hpbGUgKGZsdXNoaWR4IDwgZGlydHlfY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGRpcnR5X2NvbXBvbmVudHNbZmx1c2hpZHhdO1xuICAgICAgICAgICAgZmx1c2hpZHgrKztcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGNvbXBvbmVudC4kJCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIGZsdXNoaWR4ID0gMDtcbiAgICAgICAgd2hpbGUgKGJpbmRpbmdfY2FsbGJhY2tzLmxlbmd0aClcbiAgICAgICAgICAgIGJpbmRpbmdfY2FsbGJhY2tzLnBvcCgpKCk7XG4gICAgICAgIC8vIHRoZW4sIG9uY2UgY29tcG9uZW50cyBhcmUgdXBkYXRlZCwgY2FsbFxuICAgICAgICAvLyBhZnRlclVwZGF0ZSBmdW5jdGlvbnMuIFRoaXMgbWF5IGNhdXNlXG4gICAgICAgIC8vIHN1YnNlcXVlbnQgdXBkYXRlcy4uLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gcmVuZGVyX2NhbGxiYWNrc1tpXTtcbiAgICAgICAgICAgIGlmICghc2Vlbl9jYWxsYmFja3MuaGFzKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIC8vIC4uLnNvIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgbG9vcHNcbiAgICAgICAgICAgICAgICBzZWVuX2NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyX2NhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIH0gd2hpbGUgKGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKTtcbiAgICB3aGlsZSAoZmx1c2hfY2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICBmbHVzaF9jYWxsYmFja3MucG9wKCkoKTtcbiAgICB9XG4gICAgdXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHNlZW5fY2FsbGJhY2tzLmNsZWFyKCk7XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHNhdmVkX2NvbXBvbmVudCk7XG59XG5mdW5jdGlvbiB1cGRhdGUoJCQpIHtcbiAgICBpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgJCQudXBkYXRlKCk7XG4gICAgICAgIHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG4gICAgICAgIGNvbnN0IGRpcnR5ID0gJCQuZGlydHk7XG4gICAgICAgICQkLmRpcnR5ID0gWy0xXTtcbiAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQucCgkJC5jdHgsIGRpcnR5KTtcbiAgICAgICAgJCQuYWZ0ZXJfdXBkYXRlLmZvckVhY2goYWRkX3JlbmRlcl9jYWxsYmFjayk7XG4gICAgfVxufVxuXG5sZXQgcHJvbWlzZTtcbmZ1bmN0aW9uIHdhaXQoKSB7XG4gICAgaWYgKCFwcm9taXNlKSB7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgcHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHByb21pc2UgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiBkaXNwYXRjaChub2RlLCBkaXJlY3Rpb24sIGtpbmQpIHtcbiAgICBub2RlLmRpc3BhdGNoRXZlbnQoY3VzdG9tX2V2ZW50KGAke2RpcmVjdGlvbiA/ICdpbnRybycgOiAnb3V0cm8nfSR7a2luZH1gKSk7XG59XG5jb25zdCBvdXRyb2luZyA9IG5ldyBTZXQoKTtcbmxldCBvdXRyb3M7XG5mdW5jdGlvbiBncm91cF9vdXRyb3MoKSB7XG4gICAgb3V0cm9zID0ge1xuICAgICAgICByOiAwLFxuICAgICAgICBjOiBbXSxcbiAgICAgICAgcDogb3V0cm9zIC8vIHBhcmVudCBncm91cFxuICAgIH07XG59XG5mdW5jdGlvbiBjaGVja19vdXRyb3MoKSB7XG4gICAgaWYgKCFvdXRyb3Mucikge1xuICAgICAgICBydW5fYWxsKG91dHJvcy5jKTtcbiAgICB9XG4gICAgb3V0cm9zID0gb3V0cm9zLnA7XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uX2luKGJsb2NrLCBsb2NhbCkge1xuICAgIGlmIChibG9jayAmJiBibG9jay5pKSB7XG4gICAgICAgIG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG4gICAgICAgIGJsb2NrLmkobG9jYWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYW5zaXRpb25fb3V0KGJsb2NrLCBsb2NhbCwgZGV0YWNoLCBjYWxsYmFjaykge1xuICAgIGlmIChibG9jayAmJiBibG9jay5vKSB7XG4gICAgICAgIGlmIChvdXRyb2luZy5oYXMoYmxvY2spKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBvdXRyb2luZy5hZGQoYmxvY2spO1xuICAgICAgICBvdXRyb3MuYy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIG91dHJvaW5nLmRlbGV0ZShibG9jayk7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZGV0YWNoKVxuICAgICAgICAgICAgICAgICAgICBibG9jay5kKDEpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBibG9jay5vKGxvY2FsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG59XG5jb25zdCBudWxsX3RyYW5zaXRpb24gPSB7IGR1cmF0aW9uOiAwIH07XG5mdW5jdGlvbiBjcmVhdGVfaW5fdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcyk7XG4gICAgbGV0IHJ1bm5pbmcgPSBmYWxzZTtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWU7XG4gICAgbGV0IHRhc2s7XG4gICAgbGV0IHVpZCA9IDA7XG4gICAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnbygpIHtcbiAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCBlYXNpbmcgPSBpZGVudGl0eSwgdGljayA9IG5vb3AsIGNzcyB9ID0gY29uZmlnIHx8IG51bGxfdHJhbnNpdGlvbjtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcywgdWlkKyspO1xuICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcbiAgICAgICAgY29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG4gICAgICAgIGlmICh0YXNrKVxuICAgICAgICAgICAgdGFzay5hYm9ydCgpO1xuICAgICAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCB0cnVlLCAnc3RhcnQnKSk7XG4gICAgICAgIHRhc2sgPSBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gZW5kX3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGljaygxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0KCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBkZWxldGVfcnVsZShub2RlKTtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnID0gY29uZmlnKCk7XG4gICAgICAgICAgICAgICAgd2FpdCgpLnRoZW4oZ28pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9vdXRfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcyk7XG4gICAgbGV0IHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxldCBhbmltYXRpb25fbmFtZTtcbiAgICBjb25zdCBncm91cCA9IG91dHJvcztcbiAgICBncm91cC5yICs9IDE7XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDEsIDAsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcbiAgICAgICAgY29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdzdGFydCcpKTtcbiAgICAgICAgbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobm93ID49IGVuZF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghLS1ncm91cC5yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgcmVzdWx0IGluIGBlbmQoKWAgYmVpbmcgY2FsbGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBjbGVhbiB1cCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5fYWxsKGdyb3VwLmMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDEgLSB0LCB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVubmluZztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgIHdhaXQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZygpO1xuICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbygpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmQocmVzZXQpIHtcbiAgICAgICAgICAgIGlmIChyZXNldCAmJiBjb25maWcudGljaykge1xuICAgICAgICAgICAgICAgIGNvbmZpZy50aWNrKDEsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uX25hbWUpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICAgICAgICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlX2JpZGlyZWN0aW9uYWxfdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zLCBpbnRybykge1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMpO1xuICAgIGxldCB0ID0gaW50cm8gPyAwIDogMTtcbiAgICBsZXQgcnVubmluZ19wcm9ncmFtID0gbnVsbDtcbiAgICBsZXQgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWUgPSBudWxsO1xuICAgIGZ1bmN0aW9uIGNsZWFyX2FuaW1hdGlvbigpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0KHByb2dyYW0sIGR1cmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGQgPSAocHJvZ3JhbS5iIC0gdCk7XG4gICAgICAgIGR1cmF0aW9uICo9IE1hdGguYWJzKGQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYTogdCxcbiAgICAgICAgICAgIGI6IHByb2dyYW0uYixcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIHN0YXJ0OiBwcm9ncmFtLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBwcm9ncmFtLnN0YXJ0ICsgZHVyYXRpb24sXG4gICAgICAgICAgICBncm91cDogcHJvZ3JhbS5ncm91cFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnbyhiKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSB7XG4gICAgICAgICAgICBzdGFydDogbm93KCkgKyBkZWxheSxcbiAgICAgICAgICAgIGJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgcHJvZ3JhbS5ncm91cCA9IG91dHJvcztcbiAgICAgICAgICAgIG91dHJvcy5yICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgIHBlbmRpbmdfcHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIGludHJvLCBhbmQgdGhlcmUncyBhIGRlbGF5LCB3ZSBuZWVkIHRvIGRvXG4gICAgICAgICAgICAvLyBhbiBpbml0aWFsIHRpY2sgYW5kL29yIGFwcGx5IENTUyBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIpXG4gICAgICAgICAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocHJvZ3JhbSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBiLCAnc3RhcnQnKSk7XG4gICAgICAgICAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdfcHJvZ3JhbSAmJiBub3cgPiBwZW5kaW5nX3Byb2dyYW0uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gaW5pdChwZW5kaW5nX3Byb2dyYW0sIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdzdGFydCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgcnVubmluZ19wcm9ncmFtLmIsIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbiwgMCwgZWFzaW5nLCBjb25maWcuY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljayh0ID0gcnVubmluZ19wcm9ncmFtLmIsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBlbmRpbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtLmIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW50cm8g4oCUIHdlIGNhbiB0aWR5IHVwIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3V0cm8g4oCUIG5lZWRzIHRvIGJlIGNvb3JkaW5hdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghLS1ydW5uaW5nX3Byb2dyYW0uZ3JvdXAucilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bl9hbGwocnVubmluZ19wcm9ncmFtLmdyb3VwLmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IG5vdyAtIHJ1bm5pbmdfcHJvZ3JhbS5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBydW5uaW5nX3Byb2dyYW0uYSArIHJ1bm5pbmdfcHJvZ3JhbS5kICogZWFzaW5nKHAgLyBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcnVuKGIpIHtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgd2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZygpO1xuICAgICAgICAgICAgICAgICAgICBnbyhiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdvKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbmQoKSB7XG4gICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVfcHJvbWlzZShwcm9taXNlLCBpbmZvKSB7XG4gICAgY29uc3QgdG9rZW4gPSBpbmZvLnRva2VuID0ge307XG4gICAgZnVuY3Rpb24gdXBkYXRlKHR5cGUsIGluZGV4LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpbmZvLnRva2VuICE9PSB0b2tlbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaW5mby5yZXNvbHZlZCA9IHZhbHVlO1xuICAgICAgICBsZXQgY2hpbGRfY3R4ID0gaW5mby5jdHg7XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hpbGRfY3R4ID0gY2hpbGRfY3R4LnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZF9jdHhba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrID0gdHlwZSAmJiAoaW5mby5jdXJyZW50ID0gdHlwZSkoY2hpbGRfY3R4KTtcbiAgICAgICAgbGV0IG5lZWRzX2ZsdXNoID0gZmFsc2U7XG4gICAgICAgIGlmIChpbmZvLmJsb2NrKSB7XG4gICAgICAgICAgICBpZiAoaW5mby5ibG9ja3MpIHtcbiAgICAgICAgICAgICAgICBpbmZvLmJsb2Nrcy5mb3JFYWNoKChibG9jaywgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaW5kZXggJiYgYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwX291dHJvcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mby5ibG9ja3NbaV0gPT09IGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uYmxvY2tzW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmZvLmJsb2NrLmQoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jay5jKCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcbiAgICAgICAgICAgIGJsb2NrLm0oaW5mby5tb3VudCgpLCBpbmZvLmFuY2hvcik7XG4gICAgICAgICAgICBuZWVkc19mbHVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaW5mby5ibG9jayA9IGJsb2NrO1xuICAgICAgICBpZiAoaW5mby5ibG9ja3MpXG4gICAgICAgICAgICBpbmZvLmJsb2Nrc1tpbmRleF0gPSBibG9jaztcbiAgICAgICAgaWYgKG5lZWRzX2ZsdXNoKSB7XG4gICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc19wcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRfY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG4gICAgICAgIHByb21pc2UudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY3VycmVudF9jb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGluZm8udGhlbiwgMSwgaW5mby52YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY3VycmVudF9jb21wb25lbnQpO1xuICAgICAgICAgICAgdXBkYXRlKGluZm8uY2F0Y2gsIDIsIGluZm8uZXJyb3IsIGVycm9yKTtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgICAgIGlmICghaW5mby5oYXNDYXRjaCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gaWYgd2UgcHJldmlvdXNseSBoYWQgYSB0aGVuL2NhdGNoIGJsb2NrLCBkZXN0cm95IGl0XG4gICAgICAgIGlmIChpbmZvLmN1cnJlbnQgIT09IGluZm8ucGVuZGluZykge1xuICAgICAgICAgICAgdXBkYXRlKGluZm8ucGVuZGluZywgMCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGluZm8uY3VycmVudCAhPT0gaW5mby50aGVuKSB7XG4gICAgICAgICAgICB1cGRhdGUoaW5mby50aGVuLCAxLCBpbmZvLnZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGluZm8ucmVzb2x2ZWQgPSBwcm9taXNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZV9hd2FpdF9ibG9ja19icmFuY2goaW5mbywgY3R4LCBkaXJ0eSkge1xuICAgIGNvbnN0IGNoaWxkX2N0eCA9IGN0eC5zbGljZSgpO1xuICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IGluZm87XG4gICAgaWYgKGluZm8uY3VycmVudCA9PT0gaW5mby50aGVuKSB7XG4gICAgICAgIGNoaWxkX2N0eFtpbmZvLnZhbHVlXSA9IHJlc29sdmVkO1xuICAgIH1cbiAgICBpZiAoaW5mby5jdXJyZW50ID09PSBpbmZvLmNhdGNoKSB7XG4gICAgICAgIGNoaWxkX2N0eFtpbmZvLmVycm9yXSA9IHJlc29sdmVkO1xuICAgIH1cbiAgICBpbmZvLmJsb2NrLnAoY2hpbGRfY3R4LCBkaXJ0eSk7XG59XG5cbmNvbnN0IGdsb2JhbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IHdpbmRvd1xuICAgIDogdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gZ2xvYmFsVGhpc1xuICAgICAgICA6IGdsb2JhbCk7XG5cbmZ1bmN0aW9uIGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmQoMSk7XG4gICAgbG9va3VwLmRlbGV0ZShibG9jay5rZXkpO1xufVxuZnVuY3Rpb24gb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIHRyYW5zaXRpb25fb3V0KGJsb2NrLCAxLCAxLCAoKSA9PiB7XG4gICAgICAgIGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZpeF9hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZigpO1xuICAgIGRlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5mdW5jdGlvbiBmaXhfYW5kX291dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5mKCk7XG4gICAgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCk7XG59XG5mdW5jdGlvbiB1cGRhdGVfa2V5ZWRfZWFjaChvbGRfYmxvY2tzLCBkaXJ0eSwgZ2V0X2tleSwgZHluYW1pYywgY3R4LCBsaXN0LCBsb29rdXAsIG5vZGUsIGRlc3Ryb3ksIGNyZWF0ZV9lYWNoX2Jsb2NrLCBuZXh0LCBnZXRfY29udGV4dCkge1xuICAgIGxldCBvID0gb2xkX2Jsb2Nrcy5sZW5ndGg7XG4gICAgbGV0IG4gPSBsaXN0Lmxlbmd0aDtcbiAgICBsZXQgaSA9IG87XG4gICAgY29uc3Qgb2xkX2luZGV4ZXMgPSB7fTtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBvbGRfaW5kZXhlc1tvbGRfYmxvY2tzW2ldLmtleV0gPSBpO1xuICAgIGNvbnN0IG5ld19ibG9ja3MgPSBbXTtcbiAgICBjb25zdCBuZXdfbG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRlbHRhcyA9IG5ldyBNYXAoKTtcbiAgICBpID0gbjtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkX2N0eCA9IGdldF9jb250ZXh0KGN0eCwgbGlzdCwgaSk7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldF9rZXkoY2hpbGRfY3R4KTtcbiAgICAgICAgbGV0IGJsb2NrID0gbG9va3VwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWJsb2NrKSB7XG4gICAgICAgICAgICBibG9jayA9IGNyZWF0ZV9lYWNoX2Jsb2NrKGtleSwgY2hpbGRfY3R4KTtcbiAgICAgICAgICAgIGJsb2NrLmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICBibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpO1xuICAgICAgICB9XG4gICAgICAgIG5ld19sb29rdXAuc2V0KGtleSwgbmV3X2Jsb2Nrc1tpXSA9IGJsb2NrKTtcbiAgICAgICAgaWYgKGtleSBpbiBvbGRfaW5kZXhlcylcbiAgICAgICAgICAgIGRlbHRhcy5zZXQoa2V5LCBNYXRoLmFicyhpIC0gb2xkX2luZGV4ZXNba2V5XSkpO1xuICAgIH1cbiAgICBjb25zdCB3aWxsX21vdmUgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgZGlkX21vdmUgPSBuZXcgU2V0KCk7XG4gICAgZnVuY3Rpb24gaW5zZXJ0KGJsb2NrKSB7XG4gICAgICAgIHRyYW5zaXRpb25faW4oYmxvY2ssIDEpO1xuICAgICAgICBibG9jay5tKG5vZGUsIG5leHQpO1xuICAgICAgICBsb29rdXAuc2V0KGJsb2NrLmtleSwgYmxvY2spO1xuICAgICAgICBuZXh0ID0gYmxvY2suZmlyc3Q7XG4gICAgICAgIG4tLTtcbiAgICB9XG4gICAgd2hpbGUgKG8gJiYgbikge1xuICAgICAgICBjb25zdCBuZXdfYmxvY2sgPSBuZXdfYmxvY2tzW24gLSAxXTtcbiAgICAgICAgY29uc3Qgb2xkX2Jsb2NrID0gb2xkX2Jsb2Nrc1tvIC0gMV07XG4gICAgICAgIGNvbnN0IG5ld19rZXkgPSBuZXdfYmxvY2sua2V5O1xuICAgICAgICBjb25zdCBvbGRfa2V5ID0gb2xkX2Jsb2NrLmtleTtcbiAgICAgICAgaWYgKG5ld19ibG9jayA9PT0gb2xkX2Jsb2NrKSB7XG4gICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgICAgICBuZXh0ID0gbmV3X2Jsb2NrLmZpcnN0O1xuICAgICAgICAgICAgby0tO1xuICAgICAgICAgICAgbi0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFuZXdfbG9va3VwLmhhcyhvbGRfa2V5KSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIG9sZCBibG9ja1xuICAgICAgICAgICAgZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWxvb2t1cC5oYXMobmV3X2tleSkgfHwgd2lsbF9tb3ZlLmhhcyhuZXdfa2V5KSkge1xuICAgICAgICAgICAgaW5zZXJ0KG5ld19ibG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlkX21vdmUuaGFzKG9sZF9rZXkpKSB7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVsdGFzLmdldChuZXdfa2V5KSA+IGRlbHRhcy5nZXQob2xkX2tleSkpIHtcbiAgICAgICAgICAgIGRpZF9tb3ZlLmFkZChuZXdfa2V5KTtcbiAgICAgICAgICAgIGluc2VydChuZXdfYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2lsbF9tb3ZlLmFkZChvbGRfa2V5KTtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoby0tKSB7XG4gICAgICAgIGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3Nbb107XG4gICAgICAgIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2Jsb2NrLmtleSkpXG4gICAgICAgICAgICBkZXN0cm95KG9sZF9ibG9jaywgbG9va3VwKTtcbiAgICB9XG4gICAgd2hpbGUgKG4pXG4gICAgICAgIGluc2VydChuZXdfYmxvY2tzW24gLSAxXSk7XG4gICAgcmV0dXJuIG5ld19ibG9ja3M7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9lYWNoX2tleXMoY3R4LCBsaXN0LCBnZXRfY29udGV4dCwgZ2V0X2tleSkge1xuICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldF9rZXkoZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKSk7XG4gICAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYXZlIGR1cGxpY2F0ZSBrZXlzIGluIGEga2V5ZWQgZWFjaCcpO1xuICAgICAgICB9XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRfc3ByZWFkX3VwZGF0ZShsZXZlbHMsIHVwZGF0ZXMpIHtcbiAgICBjb25zdCB1cGRhdGUgPSB7fTtcbiAgICBjb25zdCB0b19udWxsX291dCA9IHt9O1xuICAgIGNvbnN0IGFjY291bnRlZF9mb3IgPSB7ICQkc2NvcGU6IDEgfTtcbiAgICBsZXQgaSA9IGxldmVscy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBvID0gbGV2ZWxzW2ldO1xuICAgICAgICBjb25zdCBuID0gdXBkYXRlc1tpXTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gbikpXG4gICAgICAgICAgICAgICAgICAgIHRvX251bGxfb3V0W2tleV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbikge1xuICAgICAgICAgICAgICAgIGlmICghYWNjb3VudGVkX2ZvcltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVtrZXldID0gbltrZXldO1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50ZWRfZm9yW2tleV0gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsc1tpXSA9IG47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudGVkX2ZvcltrZXldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0b19udWxsX291dCkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdXBkYXRlKSlcbiAgICAgICAgICAgIHVwZGF0ZVtrZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gZ2V0X3NwcmVhZF9vYmplY3Qoc3ByZWFkX3Byb3BzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzcHJlYWRfcHJvcHMgPT09ICdvYmplY3QnICYmIHNwcmVhZF9wcm9wcyAhPT0gbnVsbCA/IHNwcmVhZF9wcm9wcyA6IHt9O1xufVxuXG4vLyBzb3VyY2U6IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbFxuY29uc3QgYm9vbGVhbl9hdHRyaWJ1dGVzID0gbmV3IFNldChbXG4gICAgJ2FsbG93ZnVsbHNjcmVlbicsXG4gICAgJ2FsbG93cGF5bWVudHJlcXVlc3QnLFxuICAgICdhc3luYycsXG4gICAgJ2F1dG9mb2N1cycsXG4gICAgJ2F1dG9wbGF5JyxcbiAgICAnY2hlY2tlZCcsXG4gICAgJ2NvbnRyb2xzJyxcbiAgICAnZGVmYXVsdCcsXG4gICAgJ2RlZmVyJyxcbiAgICAnZGlzYWJsZWQnLFxuICAgICdmb3Jtbm92YWxpZGF0ZScsXG4gICAgJ2hpZGRlbicsXG4gICAgJ2lzbWFwJyxcbiAgICAnbG9vcCcsXG4gICAgJ211bHRpcGxlJyxcbiAgICAnbXV0ZWQnLFxuICAgICdub21vZHVsZScsXG4gICAgJ25vdmFsaWRhdGUnLFxuICAgICdvcGVuJyxcbiAgICAncGxheXNpbmxpbmUnLFxuICAgICdyZWFkb25seScsXG4gICAgJ3JlcXVpcmVkJyxcbiAgICAncmV2ZXJzZWQnLFxuICAgICdzZWxlY3RlZCdcbl0pO1xuXG5jb25zdCB2b2lkX2VsZW1lbnRfbmFtZXMgPSAvXig/OmFyZWF8YmFzZXxicnxjb2x8Y29tbWFuZHxlbWJlZHxocnxpbWd8aW5wdXR8a2V5Z2VufGxpbmt8bWV0YXxwYXJhbXxzb3VyY2V8dHJhY2t8d2JyKSQvO1xuZnVuY3Rpb24gaXNfdm9pZChuYW1lKSB7XG4gICAgcmV0dXJuIHZvaWRfZWxlbWVudF9uYW1lcy50ZXN0KG5hbWUpIHx8IG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJyFkb2N0eXBlJztcbn1cblxuY29uc3QgaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIgPSAvW1xccydcIj4vPVxcdXtGREQwfS1cXHV7RkRFRn1cXHV7RkZGRX1cXHV7RkZGRn1cXHV7MUZGRkV9XFx1ezFGRkZGfVxcdXsyRkZGRX1cXHV7MkZGRkZ9XFx1ezNGRkZFfVxcdXszRkZGRn1cXHV7NEZGRkV9XFx1ezRGRkZGfVxcdXs1RkZGRX1cXHV7NUZGRkZ9XFx1ezZGRkZFfVxcdXs2RkZGRn1cXHV7N0ZGRkV9XFx1ezdGRkZGfVxcdXs4RkZGRX1cXHV7OEZGRkZ9XFx1ezlGRkZFfVxcdXs5RkZGRn1cXHV7QUZGRkV9XFx1e0FGRkZGfVxcdXtCRkZGRX1cXHV7QkZGRkZ9XFx1e0NGRkZFfVxcdXtDRkZGRn1cXHV7REZGRkV9XFx1e0RGRkZGfVxcdXtFRkZGRX1cXHV7RUZGRkZ9XFx1e0ZGRkZFfVxcdXtGRkZGRn1cXHV7MTBGRkZFfVxcdXsxMEZGRkZ9XS91O1xuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jbm9uY2hhcmFjdGVyXG5mdW5jdGlvbiBzcHJlYWQoYXJncywgYXR0cnNfdG9fYWRkKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oe30sIC4uLmFyZ3MpO1xuICAgIGlmIChhdHRyc190b19hZGQpIHtcbiAgICAgICAgY29uc3QgY2xhc3Nlc190b19hZGQgPSBhdHRyc190b19hZGQuY2xhc3NlcztcbiAgICAgICAgY29uc3Qgc3R5bGVzX3RvX2FkZCA9IGF0dHJzX3RvX2FkZC5zdHlsZXM7XG4gICAgICAgIGlmIChjbGFzc2VzX3RvX2FkZCkge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuY2xhc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgPSBjbGFzc2VzX3RvX2FkZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgKz0gJyAnICsgY2xhc3Nlc190b19hZGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlc190b19hZGQpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLnN0eWxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhzdHlsZXNfdG9fYWRkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuc3R5bGUgPSBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKG1lcmdlX3Nzcl9zdHlsZXMoYXR0cmlidXRlcy5zdHlsZSwgc3R5bGVzX3RvX2FkZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBzdHIgPSAnJztcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICBpZiAoaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIudGVzdChuYW1lKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHRydWUpXG4gICAgICAgICAgICBzdHIgKz0gJyAnICsgbmFtZTtcbiAgICAgICAgZWxzZSBpZiAoYm9vbGVhbl9hdHRyaWJ1dGVzLmhhcyhuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICAgICAgc3RyICs9ICcgJyArIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyICs9IGAgJHtuYW1lfT1cIiR7dmFsdWV9XCJgO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIG1lcmdlX3Nzcl9zdHlsZXMoc3R5bGVfYXR0cmlidXRlLCBzdHlsZV9kaXJlY3RpdmUpIHtcbiAgICBjb25zdCBzdHlsZV9vYmplY3QgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGluZGl2aWR1YWxfc3R5bGUgb2Ygc3R5bGVfYXR0cmlidXRlLnNwbGl0KCc7JykpIHtcbiAgICAgICAgY29uc3QgY29sb25faW5kZXggPSBpbmRpdmlkdWFsX3N0eWxlLmluZGV4T2YoJzonKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGluZGl2aWR1YWxfc3R5bGUuc2xpY2UoMCwgY29sb25faW5kZXgpLnRyaW0oKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpbmRpdmlkdWFsX3N0eWxlLnNsaWNlKGNvbG9uX2luZGV4ICsgMSkudHJpbSgpO1xuICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgc3R5bGVfb2JqZWN0W25hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbmFtZSBpbiBzdHlsZV9kaXJlY3RpdmUpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdHlsZV9kaXJlY3RpdmVbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgc3R5bGVfb2JqZWN0W25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgc3R5bGVfb2JqZWN0W25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHlsZV9vYmplY3Q7XG59XG5jb25zdCBBVFRSX1JFR0VYID0gL1smXCJdL2c7XG5jb25zdCBDT05URU5UX1JFR0VYID0gL1smPF0vZztcbi8qKlxuICogTm90ZTogdGhpcyBtZXRob2QgaXMgcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlIGFuZCBoYXMgYmVlbiBvcHRpbWl6ZWRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvcHVsbC81NzAxXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZSh2YWx1ZSwgaXNfYXR0ciA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc3RyID0gU3RyaW5nKHZhbHVlKTtcbiAgICBjb25zdCBwYXR0ZXJuID0gaXNfYXR0ciA/IEFUVFJfUkVHRVggOiBDT05URU5UX1JFR0VYO1xuICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICBsZXQgZXNjYXBlZCA9ICcnO1xuICAgIGxldCBsYXN0ID0gMDtcbiAgICB3aGlsZSAocGF0dGVybi50ZXN0KHN0cikpIHtcbiAgICAgICAgY29uc3QgaSA9IHBhdHRlcm4ubGFzdEluZGV4IC0gMTtcbiAgICAgICAgY29uc3QgY2ggPSBzdHJbaV07XG4gICAgICAgIGVzY2FwZWQgKz0gc3RyLnN1YnN0cmluZyhsYXN0LCBpKSArIChjaCA9PT0gJyYnID8gJyZhbXA7JyA6IChjaCA9PT0gJ1wiJyA/ICcmcXVvdDsnIDogJyZsdDsnKSk7XG4gICAgICAgIGxhc3QgPSBpICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIGVzY2FwZWQgKyBzdHIuc3Vic3RyaW5nKGxhc3QpO1xufVxuZnVuY3Rpb24gZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZSh2YWx1ZSkge1xuICAgIC8vIGtlZXAgYm9vbGVhbnMsIG51bGwsIGFuZCB1bmRlZmluZWQgZm9yIHRoZSBzYWtlIG9mIGBzcHJlYWRgXG4gICAgY29uc3Qgc2hvdWxkX2VzY2FwZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpO1xuICAgIHJldHVybiBzaG91bGRfZXNjYXBlID8gZXNjYXBlKHZhbHVlLCB0cnVlKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZXNjYXBlX29iamVjdChvYmopIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBlc2NhcGVfYXR0cmlidXRlX3ZhbHVlKG9ialtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGVhY2goaXRlbXMsIGZuKSB7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc3RyICs9IGZuKGl0ZW1zW2ldLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmNvbnN0IG1pc3NpbmdfY29tcG9uZW50ID0ge1xuICAgICQkcmVuZGVyOiAoKSA9PiAnJ1xufTtcbmZ1bmN0aW9uIHZhbGlkYXRlX2NvbXBvbmVudChjb21wb25lbnQsIG5hbWUpIHtcbiAgICBpZiAoIWNvbXBvbmVudCB8fCAhY29tcG9uZW50LiQkcmVuZGVyKSB7XG4gICAgICAgIGlmIChuYW1lID09PSAnc3ZlbHRlOmNvbXBvbmVudCcpXG4gICAgICAgICAgICBuYW1lICs9ICcgdGhpcz17Li4ufSc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgPCR7bmFtZX0+IGlzIG5vdCBhIHZhbGlkIFNTUiBjb21wb25lbnQuIFlvdSBtYXkgbmVlZCB0byByZXZpZXcgeW91ciBidWlsZCBjb25maWcgdG8gZW5zdXJlIHRoYXQgZGVwZW5kZW5jaWVzIGFyZSBjb21waWxlZCwgcmF0aGVyIHRoYW4gaW1wb3J0ZWQgYXMgcHJlLWNvbXBpbGVkIG1vZHVsZXNgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGRlYnVnKGZpbGUsIGxpbmUsIGNvbHVtbiwgdmFsdWVzKSB7XG4gICAgY29uc29sZS5sb2coYHtAZGVidWd9ICR7ZmlsZSA/IGZpbGUgKyAnICcgOiAnJ30oJHtsaW5lfToke2NvbHVtbn0pYCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKHZhbHVlcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIHJldHVybiAnJztcbn1cbmxldCBvbl9kZXN0cm95O1xuZnVuY3Rpb24gY3JlYXRlX3Nzcl9jb21wb25lbnQoZm4pIHtcbiAgICBmdW5jdGlvbiAkJHJlbmRlcihyZXN1bHQsIHByb3BzLCBiaW5kaW5ncywgc2xvdHMsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgICAgICBjb25zdCAkJCA9IHtcbiAgICAgICAgICAgIG9uX2Rlc3Ryb3ksXG4gICAgICAgICAgICBjb250ZXh0OiBuZXcgTWFwKGNvbnRleHQgfHwgKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSkpLFxuICAgICAgICAgICAgLy8gdGhlc2Ugd2lsbCBiZSBpbW1lZGlhdGVseSBkaXNjYXJkZWRcbiAgICAgICAgICAgIG9uX21vdW50OiBbXSxcbiAgICAgICAgICAgIGJlZm9yZV91cGRhdGU6IFtdLFxuICAgICAgICAgICAgYWZ0ZXJfdXBkYXRlOiBbXSxcbiAgICAgICAgICAgIGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KClcbiAgICAgICAgfTtcbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHsgJCQgfSk7XG4gICAgICAgIGNvbnN0IGh0bWwgPSBmbihyZXN1bHQsIHByb3BzLCBiaW5kaW5ncywgc2xvdHMpO1xuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQocGFyZW50X2NvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXI6IChwcm9wcyA9IHt9LCB7ICQkc2xvdHMgPSB7fSwgY29udGV4dCA9IG5ldyBNYXAoKSB9ID0ge30pID0+IHtcbiAgICAgICAgICAgIG9uX2Rlc3Ryb3kgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdGl0bGU6ICcnLCBoZWFkOiAnJywgY3NzOiBuZXcgU2V0KCkgfTtcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSAkJHJlbmRlcihyZXN1bHQsIHByb3BzLCB7fSwgJCRzbG90cywgY29udGV4dCk7XG4gICAgICAgICAgICBydW5fYWxsKG9uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBodG1sLFxuICAgICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBBcnJheS5mcm9tKHJlc3VsdC5jc3MpLm1hcChjc3MgPT4gY3NzLmNvZGUpLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgICAgICAgICBtYXA6IG51bGwgLy8gVE9ET1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGVhZDogcmVzdWx0LnRpdGxlICsgcmVzdWx0LmhlYWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgICQkcmVuZGVyXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFkZF9hdHRyaWJ1dGUobmFtZSwgdmFsdWUsIGJvb2xlYW4pIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCAoYm9vbGVhbiAmJiAhdmFsdWUpKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgY29uc3QgYXNzaWdubWVudCA9IChib29sZWFuICYmIHZhbHVlID09PSB0cnVlKSA/ICcnIDogYD1cIiR7ZXNjYXBlKHZhbHVlLCB0cnVlKX1cImA7XG4gICAgcmV0dXJuIGAgJHtuYW1lfSR7YXNzaWdubWVudH1gO1xufVxuZnVuY3Rpb24gYWRkX2NsYXNzZXMoY2xhc3Nlcykge1xuICAgIHJldHVybiBjbGFzc2VzID8gYCBjbGFzcz1cIiR7Y2xhc3Nlc31cImAgOiAnJztcbn1cbmZ1bmN0aW9uIHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVfb2JqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlX29iamVjdClcbiAgICAgICAgLmZpbHRlcihrZXkgPT4gc3R5bGVfb2JqZWN0W2tleV0pXG4gICAgICAgIC5tYXAoa2V5ID0+IGAke2tleX06ICR7c3R5bGVfb2JqZWN0W2tleV19O2ApXG4gICAgICAgIC5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBhZGRfc3R5bGVzKHN0eWxlX29iamVjdCkge1xuICAgIGNvbnN0IHN0eWxlcyA9IHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVfb2JqZWN0KTtcbiAgICByZXR1cm4gc3R5bGVzID8gYCBzdHlsZT1cIiR7c3R5bGVzfVwiYCA6ICcnO1xufVxuXG5mdW5jdGlvbiBiaW5kKGNvbXBvbmVudCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBpbmRleCA9IGNvbXBvbmVudC4kJC5wcm9wc1tuYW1lXTtcbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb21wb25lbnQuJCQuYm91bmRbaW5kZXhdID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrKGNvbXBvbmVudC4kJC5jdHhbaW5kZXhdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVfY29tcG9uZW50KGJsb2NrKSB7XG4gICAgYmxvY2sgJiYgYmxvY2suYygpO1xufVxuZnVuY3Rpb24gY2xhaW1fY29tcG9uZW50KGJsb2NrLCBwYXJlbnRfbm9kZXMpIHtcbiAgICBibG9jayAmJiBibG9jay5sKHBhcmVudF9ub2Rlcyk7XG59XG5mdW5jdGlvbiBtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCB0YXJnZXQsIGFuY2hvciwgY3VzdG9tRWxlbWVudCkge1xuICAgIGNvbnN0IHsgZnJhZ21lbnQsIG9uX21vdW50LCBvbl9kZXN0cm95LCBhZnRlcl91cGRhdGUgfSA9IGNvbXBvbmVudC4kJDtcbiAgICBmcmFnbWVudCAmJiBmcmFnbWVudC5tKHRhcmdldCwgYW5jaG9yKTtcbiAgICBpZiAoIWN1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgLy8gb25Nb3VudCBoYXBwZW5zIGJlZm9yZSB0aGUgaW5pdGlhbCBhZnRlclVwZGF0ZVxuICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld19vbl9kZXN0cm95ID0gb25fbW91bnQubWFwKHJ1bikuZmlsdGVyKGlzX2Z1bmN0aW9uKTtcbiAgICAgICAgICAgIGlmIChvbl9kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgb25fZGVzdHJveS5wdXNoKC4uLm5ld19vbl9kZXN0cm95KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVkZ2UgY2FzZSAtIGNvbXBvbmVudCB3YXMgZGVzdHJveWVkIGltbWVkaWF0ZWx5LFxuICAgICAgICAgICAgICAgIC8vIG1vc3QgbGlrZWx5IGFzIGEgcmVzdWx0IG9mIGEgYmluZGluZyBpbml0aWFsaXNpbmdcbiAgICAgICAgICAgICAgICBydW5fYWxsKG5ld19vbl9kZXN0cm95KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudC4kJC5vbl9tb3VudCA9IFtdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWZ0ZXJfdXBkYXRlLmZvckVhY2goYWRkX3JlbmRlcl9jYWxsYmFjayk7XG59XG5mdW5jdGlvbiBkZXN0cm95X2NvbXBvbmVudChjb21wb25lbnQsIGRldGFjaGluZykge1xuICAgIGNvbnN0ICQkID0gY29tcG9uZW50LiQkO1xuICAgIGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICBydW5fYWxsKCQkLm9uX2Rlc3Ryb3kpO1xuICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5kKGRldGFjaGluZyk7XG4gICAgICAgIC8vIFRPRE8gbnVsbCBvdXQgb3RoZXIgcmVmcywgaW5jbHVkaW5nIGNvbXBvbmVudC4kJCAoYnV0IG5lZWQgdG9cbiAgICAgICAgLy8gcHJlc2VydmUgZmluYWwgc3RhdGU/KVxuICAgICAgICAkJC5vbl9kZXN0cm95ID0gJCQuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICAkJC5jdHggPSBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYWtlX2RpcnR5KGNvbXBvbmVudCwgaSkge1xuICAgIGlmIChjb21wb25lbnQuJCQuZGlydHlbMF0gPT09IC0xKSB7XG4gICAgICAgIGRpcnR5X2NvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICBzY2hlZHVsZV91cGRhdGUoKTtcbiAgICAgICAgY29tcG9uZW50LiQkLmRpcnR5LmZpbGwoMCk7XG4gICAgfVxuICAgIGNvbXBvbmVudC4kJC5kaXJ0eVsoaSAvIDMxKSB8IDBdIHw9ICgxIDw8IChpICUgMzEpKTtcbn1cbmZ1bmN0aW9uIGluaXQoY29tcG9uZW50LCBvcHRpb25zLCBpbnN0YW5jZSwgY3JlYXRlX2ZyYWdtZW50LCBub3RfZXF1YWwsIHByb3BzLCBhcHBlbmRfc3R5bGVzLCBkaXJ0eSA9IFstMV0pIHtcbiAgICBjb25zdCBwYXJlbnRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgY29uc3QgJCQgPSBjb21wb25lbnQuJCQgPSB7XG4gICAgICAgIGZyYWdtZW50OiBudWxsLFxuICAgICAgICBjdHg6IG51bGwsXG4gICAgICAgIC8vIHN0YXRlXG4gICAgICAgIHByb3BzLFxuICAgICAgICB1cGRhdGU6IG5vb3AsXG4gICAgICAgIG5vdF9lcXVhbCxcbiAgICAgICAgYm91bmQ6IGJsYW5rX29iamVjdCgpLFxuICAgICAgICAvLyBsaWZlY3ljbGVcbiAgICAgICAgb25fbW91bnQ6IFtdLFxuICAgICAgICBvbl9kZXN0cm95OiBbXSxcbiAgICAgICAgb25fZGlzY29ubmVjdDogW10sXG4gICAgICAgIGJlZm9yZV91cGRhdGU6IFtdLFxuICAgICAgICBhZnRlcl91cGRhdGU6IFtdLFxuICAgICAgICBjb250ZXh0OiBuZXcgTWFwKG9wdGlvbnMuY29udGV4dCB8fCAocGFyZW50X2NvbXBvbmVudCA/IHBhcmVudF9jb21wb25lbnQuJCQuY29udGV4dCA6IFtdKSksXG4gICAgICAgIC8vIGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICBjYWxsYmFja3M6IGJsYW5rX29iamVjdCgpLFxuICAgICAgICBkaXJ0eSxcbiAgICAgICAgc2tpcF9ib3VuZDogZmFsc2UsXG4gICAgICAgIHJvb3Q6IG9wdGlvbnMudGFyZ2V0IHx8IHBhcmVudF9jb21wb25lbnQuJCQucm9vdFxuICAgIH07XG4gICAgYXBwZW5kX3N0eWxlcyAmJiBhcHBlbmRfc3R5bGVzKCQkLnJvb3QpO1xuICAgIGxldCByZWFkeSA9IGZhbHNlO1xuICAgICQkLmN0eCA9IGluc3RhbmNlXG4gICAgICAgID8gaW5zdGFuY2UoY29tcG9uZW50LCBvcHRpb25zLnByb3BzIHx8IHt9LCAoaSwgcmV0LCAuLi5yZXN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3QubGVuZ3RoID8gcmVzdFswXSA6IHJldDtcbiAgICAgICAgICAgIGlmICgkJC5jdHggJiYgbm90X2VxdWFsKCQkLmN0eFtpXSwgJCQuY3R4W2ldID0gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEkJC5za2lwX2JvdW5kICYmICQkLmJvdW5kW2ldKVxuICAgICAgICAgICAgICAgICAgICAkJC5ib3VuZFtpXSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWR5KVxuICAgICAgICAgICAgICAgICAgICBtYWtlX2RpcnR5KGNvbXBvbmVudCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9KVxuICAgICAgICA6IFtdO1xuICAgICQkLnVwZGF0ZSgpO1xuICAgIHJlYWR5ID0gdHJ1ZTtcbiAgICBydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuICAgIC8vIGBmYWxzZWAgYXMgYSBzcGVjaWFsIGNhc2Ugb2Ygbm8gRE9NIGNvbXBvbmVudFxuICAgICQkLmZyYWdtZW50ID0gY3JlYXRlX2ZyYWdtZW50ID8gY3JlYXRlX2ZyYWdtZW50KCQkLmN0eCkgOiBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy50YXJnZXQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaHlkcmF0ZSkge1xuICAgICAgICAgICAgc3RhcnRfaHlkcmF0aW5nKCk7XG4gICAgICAgICAgICBjb25zdCBub2RlcyA9IGNoaWxkcmVuKG9wdGlvbnMudGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5sKG5vZGVzKTtcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZGV0YWNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuaW50cm8pXG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGNvbXBvbmVudC4kJC5mcmFnbWVudCk7XG4gICAgICAgIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIG9wdGlvbnMudGFyZ2V0LCBvcHRpb25zLmFuY2hvciwgb3B0aW9ucy5jdXN0b21FbGVtZW50KTtcbiAgICAgICAgZW5kX2h5ZHJhdGluZygpO1xuICAgICAgICBmbHVzaCgpO1xuICAgIH1cbiAgICBzZXRfY3VycmVudF9jb21wb25lbnQocGFyZW50X2NvbXBvbmVudCk7XG59XG5sZXQgU3ZlbHRlRWxlbWVudDtcbmlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBTdmVsdGVFbGVtZW50ID0gY2xhc3MgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgY29uc3QgeyBvbl9tb3VudCB9ID0gdGhpcy4kJDtcbiAgICAgICAgICAgIHRoaXMuJCQub25fZGlzY29ubmVjdCA9IG9uX21vdW50Lm1hcChydW4pLmZpbHRlcihpc19mdW5jdGlvbik7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy4kJC5zbG90dGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuJCQuc2xvdHRlZFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ciwgX29sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpc1thdHRyXSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgICAgcnVuX2FsbCh0aGlzLiQkLm9uX2Rpc2Nvbm5lY3QpO1xuICAgICAgICB9XG4gICAgICAgICRkZXN0cm95KCkge1xuICAgICAgICAgICAgZGVzdHJveV9jb21wb25lbnQodGhpcywgMSk7XG4gICAgICAgICAgICB0aGlzLiRkZXN0cm95ID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICAkb24odHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIFRPRE8gc2hvdWxkIHRoaXMgZGVsZWdhdGUgdG8gYWRkRXZlbnRMaXN0ZW5lcj9cbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSB8fCAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gPSBbXSkpO1xuICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgJHNldCgkJHByb3BzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kJHNldCAmJiAhaXNfZW1wdHkoJCRwcm9wcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuJCRzZXQoJCRwcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBTdmVsdGUgY29tcG9uZW50cy4gVXNlZCB3aGVuIGRldj1mYWxzZS5cbiAqL1xuY2xhc3MgU3ZlbHRlQ29tcG9uZW50IHtcbiAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgZGVzdHJveV9jb21wb25lbnQodGhpcywgMSk7XG4gICAgICAgIHRoaXMuJGRlc3Ryb3kgPSBub29wO1xuICAgIH1cbiAgICAkb24odHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKSk7XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgICAgICAgICBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgJHNldCgkJHByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLiQkc2V0ICYmICFpc19lbXB0eSgkJHByb3BzKSkge1xuICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuJCRzZXQoJCRwcm9wcyk7XG4gICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hfZGV2KHR5cGUsIGRldGFpbCkge1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoY3VzdG9tX2V2ZW50KHR5cGUsIE9iamVjdC5hc3NpZ24oeyB2ZXJzaW9uOiAnMy40OS4wJyB9LCBkZXRhaWwpLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xufVxuZnVuY3Rpb24gYXBwZW5kX2Rldih0YXJnZXQsIG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlIH0pO1xuICAgIGFwcGVuZCh0YXJnZXQsIG5vZGUpO1xufVxuZnVuY3Rpb24gYXBwZW5kX2h5ZHJhdGlvbl9kZXYodGFyZ2V0LCBub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSB9KTtcbiAgICBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSk7XG59XG5mdW5jdGlvbiBpbnNlcnRfZGV2KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSwgYW5jaG9yIH0pO1xuICAgIGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcik7XG59XG5mdW5jdGlvbiBpbnNlcnRfaHlkcmF0aW9uX2Rldih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUsIGFuY2hvciB9KTtcbiAgICBpbnNlcnRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcbn1cbmZ1bmN0aW9uIGRldGFjaF9kZXYobm9kZSkge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlJywgeyBub2RlIH0pO1xuICAgIGRldGFjaChub2RlKTtcbn1cbmZ1bmN0aW9uIGRldGFjaF9iZXR3ZWVuX2RldihiZWZvcmUsIGFmdGVyKSB7XG4gICAgd2hpbGUgKGJlZm9yZS5uZXh0U2libGluZyAmJiBiZWZvcmUubmV4dFNpYmxpbmcgIT09IGFmdGVyKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYmVmb3JlLm5leHRTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2hfYmVmb3JlX2RldihhZnRlcikge1xuICAgIHdoaWxlIChhZnRlci5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgZGV0YWNoX2RldihhZnRlci5wcmV2aW91c1NpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaF9hZnRlcl9kZXYoYmVmb3JlKSB7XG4gICAgd2hpbGUgKGJlZm9yZS5uZXh0U2libGluZykge1xuICAgICAgICBkZXRhY2hfZGV2KGJlZm9yZS5uZXh0U2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbGlzdGVuX2Rldihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucywgaGFzX3ByZXZlbnRfZGVmYXVsdCwgaGFzX3N0b3BfcHJvcGFnYXRpb24pIHtcbiAgICBjb25zdCBtb2RpZmllcnMgPSBvcHRpb25zID09PSB0cnVlID8gWydjYXB0dXJlJ10gOiBvcHRpb25zID8gQXJyYXkuZnJvbShPYmplY3Qua2V5cyhvcHRpb25zKSkgOiBbXTtcbiAgICBpZiAoaGFzX3ByZXZlbnRfZGVmYXVsdClcbiAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3ByZXZlbnREZWZhdWx0Jyk7XG4gICAgaWYgKGhhc19zdG9wX3Byb3BhZ2F0aW9uKVxuICAgICAgICBtb2RpZmllcnMucHVzaCgnc3RvcFByb3BhZ2F0aW9uJyk7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01BZGRFdmVudExpc3RlbmVyJywgeyBub2RlLCBldmVudCwgaGFuZGxlciwgbW9kaWZpZXJzIH0pO1xuICAgIGNvbnN0IGRpc3Bvc2UgPSBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlRXZlbnRMaXN0ZW5lcicsIHsgbm9kZSwgZXZlbnQsIGhhbmRsZXIsIG1vZGlmaWVycyB9KTtcbiAgICAgICAgZGlzcG9zZSgpO1xuICAgIH07XG59XG5mdW5jdGlvbiBhdHRyX2Rldihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmVBdHRyaWJ1dGUnLCB7IG5vZGUsIGF0dHJpYnV0ZSB9KTtcbiAgICBlbHNlXG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0QXR0cmlidXRlJywgeyBub2RlLCBhdHRyaWJ1dGUsIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gcHJvcF9kZXYobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgbm9kZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldFByb3BlcnR5JywgeyBub2RlLCBwcm9wZXJ0eSwgdmFsdWUgfSk7XG59XG5mdW5jdGlvbiBkYXRhc2V0X2Rldihub2RlLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBub2RlLmRhdGFzZXRbcHJvcGVydHldID0gdmFsdWU7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXREYXRhc2V0JywgeyBub2RlLCBwcm9wZXJ0eSwgdmFsdWUgfSk7XG59XG5mdW5jdGlvbiBzZXRfZGF0YV9kZXYodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQud2hvbGVUZXh0ID09PSBkYXRhKVxuICAgICAgICByZXR1cm47XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXREYXRhJywgeyBub2RlOiB0ZXh0LCBkYXRhIH0pO1xuICAgIHRleHQuZGF0YSA9IGRhdGE7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9lYWNoX2FyZ3VtZW50KGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnc3RyaW5nJyAmJiAhKGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBhcmcpKSB7XG4gICAgICAgIGxldCBtc2cgPSAneyNlYWNofSBvbmx5IGl0ZXJhdGVzIG92ZXIgYXJyYXktbGlrZSBvYmplY3RzLic7XG4gICAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIGFyZyAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gYXJnKSB7XG4gICAgICAgICAgICBtc2cgKz0gJyBZb3UgY2FuIHVzZSBhIHNwcmVhZCB0byBjb252ZXJ0IHRoaXMgaXRlcmFibGUgaW50byBhbiBhcnJheS4nO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX3Nsb3RzKG5hbWUsIHNsb3QsIGtleXMpIHtcbiAgICBmb3IgKGNvbnN0IHNsb3Rfa2V5IG9mIE9iamVjdC5rZXlzKHNsb3QpKSB7XG4gICAgICAgIGlmICghfmtleXMuaW5kZXhPZihzbG90X2tleSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgPCR7bmFtZX0+IHJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgc2xvdCBcIiR7c2xvdF9rZXl9XCIuYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9keW5hbWljX2VsZW1lbnQodGFnKSB7XG4gICAgY29uc3QgaXNfc3RyaW5nID0gdHlwZW9mIHRhZyA9PT0gJ3N0cmluZyc7XG4gICAgaWYgKHRhZyAmJiAhaXNfc3RyaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignPHN2ZWx0ZTplbGVtZW50PiBleHBlY3RzIFwidGhpc1wiIGF0dHJpYnV0ZSB0byBiZSBhIHN0cmluZy4nKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV92b2lkX2R5bmFtaWNfZWxlbWVudCh0YWcpIHtcbiAgICBpZiAodGFnICYmIGlzX3ZvaWQodGFnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYDxzdmVsdGU6ZWxlbWVudCB0aGlzPVwiJHt0YWd9XCI+IGlzIHNlbGYtY2xvc2luZyBhbmQgY2Fubm90IGhhdmUgY29udGVudC5gKTtcbiAgICB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzIHdpdGggc29tZSBtaW5vciBkZXYtZW5oYW5jZW1lbnRzLiBVc2VkIHdoZW4gZGV2PXRydWUuXG4gKi9cbmNsYXNzIFN2ZWx0ZUNvbXBvbmVudERldiBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgKCFvcHRpb25zLnRhcmdldCAmJiAhb3B0aW9ucy4kJGlubGluZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIid0YXJnZXQnIGlzIGEgcmVxdWlyZWQgb3B0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuICAgICRkZXN0cm95KCkge1xuICAgICAgICBzdXBlci4kZGVzdHJveSgpO1xuICAgICAgICB0aGlzLiRkZXN0cm95ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb21wb25lbnQgd2FzIGFscmVhZHkgZGVzdHJveWVkJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAkY2FwdHVyZV9zdGF0ZSgpIHsgfVxuICAgICRpbmplY3Rfc3RhdGUoKSB7IH1cbn1cbi8qKlxuICogQmFzZSBjbGFzcyB0byBjcmVhdGUgc3Ryb25nbHkgdHlwZWQgU3ZlbHRlIGNvbXBvbmVudHMuXG4gKiBUaGlzIG9ubHkgZXhpc3RzIGZvciB0eXBpbmcgcHVycG9zZXMgYW5kIHNob3VsZCBiZSB1c2VkIGluIGAuZC50c2AgZmlsZXMuXG4gKlxuICogIyMjIEV4YW1wbGU6XG4gKlxuICogWW91IGhhdmUgY29tcG9uZW50IGxpYnJhcnkgb24gbnBtIGNhbGxlZCBgY29tcG9uZW50LWxpYnJhcnlgLCBmcm9tIHdoaWNoXG4gKiB5b3UgZXhwb3J0IGEgY29tcG9uZW50IGNhbGxlZCBgTXlDb21wb25lbnRgLiBGb3IgU3ZlbHRlK1R5cGVTY3JpcHQgdXNlcnMsXG4gKiB5b3Ugd2FudCB0byBwcm92aWRlIHR5cGluZ3MuIFRoZXJlZm9yZSB5b3UgY3JlYXRlIGEgYGluZGV4LmQudHNgOlxuICogYGBgdHNcbiAqIGltcG9ydCB7IFN2ZWx0ZUNvbXBvbmVudFR5cGVkIH0gZnJvbSBcInN2ZWx0ZVwiO1xuICogZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50VHlwZWQ8e2Zvbzogc3RyaW5nfT4ge31cbiAqIGBgYFxuICogVHlwaW5nIHRoaXMgbWFrZXMgaXQgcG9zc2libGUgZm9yIElERXMgbGlrZSBWUyBDb2RlIHdpdGggdGhlIFN2ZWx0ZSBleHRlbnNpb25cbiAqIHRvIHByb3ZpZGUgaW50ZWxsaXNlbnNlIGFuZCB0byB1c2UgdGhlIGNvbXBvbmVudCBsaWtlIHRoaXMgaW4gYSBTdmVsdGUgZmlsZVxuICogd2l0aCBUeXBlU2NyaXB0OlxuICogYGBgc3ZlbHRlXG4gKiA8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICogXHRpbXBvcnQgeyBNeUNvbXBvbmVudCB9IGZyb20gXCJjb21wb25lbnQtbGlicmFyeVwiO1xuICogPC9zY3JpcHQ+XG4gKiA8TXlDb21wb25lbnQgZm9vPXsnYmFyJ30gLz5cbiAqIGBgYFxuICpcbiAqICMjIyMgV2h5IG5vdCBtYWtlIHRoaXMgcGFydCBvZiBgU3ZlbHRlQ29tcG9uZW50KERldilgP1xuICogQmVjYXVzZVxuICogYGBgdHNcbiAqIGNsYXNzIEFTdWJjbGFzc09mU3ZlbHRlQ29tcG9uZW50IGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50PHtmb286IHN0cmluZ30+IHt9XG4gKiBjb25zdCBjb21wb25lbnQ6IHR5cGVvZiBTdmVsdGVDb21wb25lbnQgPSBBU3ViY2xhc3NPZlN2ZWx0ZUNvbXBvbmVudDtcbiAqIGBgYFxuICogd2lsbCB0aHJvdyBhIHR5cGUgZXJyb3IsIHNvIHdlIG5lZWQgdG8gc2VwYXJhdGUgdGhlIG1vcmUgc3RyaWN0bHkgdHlwZWQgY2xhc3MuXG4gKi9cbmNsYXNzIFN2ZWx0ZUNvbXBvbmVudFR5cGVkIGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50RGV2IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxvb3BfZ3VhcmQodGltZW91dCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHN0YXJ0ID4gdGltZW91dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSBsb29wIGRldGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5leHBvcnQgeyBIdG1sVGFnLCBIdG1sVGFnSHlkcmF0aW9uLCBTdmVsdGVDb21wb25lbnQsIFN2ZWx0ZUNvbXBvbmVudERldiwgU3ZlbHRlQ29tcG9uZW50VHlwZWQsIFN2ZWx0ZUVsZW1lbnQsIGFjdGlvbl9kZXN0cm95ZXIsIGFkZF9hdHRyaWJ1dGUsIGFkZF9jbGFzc2VzLCBhZGRfZmx1c2hfY2FsbGJhY2ssIGFkZF9sb2NhdGlvbiwgYWRkX3JlbmRlcl9jYWxsYmFjaywgYWRkX3Jlc2l6ZV9saXN0ZW5lciwgYWRkX3N0eWxlcywgYWRkX3RyYW5zZm9ybSwgYWZ0ZXJVcGRhdGUsIGFwcGVuZCwgYXBwZW5kX2RldiwgYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQsIGFwcGVuZF9oeWRyYXRpb24sIGFwcGVuZF9oeWRyYXRpb25fZGV2LCBhcHBlbmRfc3R5bGVzLCBhc3NpZ24sIGF0dHIsIGF0dHJfZGV2LCBhdHRyaWJ1dGVfdG9fb2JqZWN0LCBiZWZvcmVVcGRhdGUsIGJpbmQsIGJpbmRpbmdfY2FsbGJhY2tzLCBibGFua19vYmplY3QsIGJ1YmJsZSwgY2hlY2tfb3V0cm9zLCBjaGlsZHJlbiwgY2xhaW1fY29tcG9uZW50LCBjbGFpbV9lbGVtZW50LCBjbGFpbV9odG1sX3RhZywgY2xhaW1fc3BhY2UsIGNsYWltX3N2Z19lbGVtZW50LCBjbGFpbV90ZXh0LCBjbGVhcl9sb29wcywgY29tcG9uZW50X3N1YnNjcmliZSwgY29tcHV0ZV9yZXN0X3Byb3BzLCBjb21wdXRlX3Nsb3RzLCBjcmVhdGVFdmVudERpc3BhdGNoZXIsIGNyZWF0ZV9hbmltYXRpb24sIGNyZWF0ZV9iaWRpcmVjdGlvbmFsX3RyYW5zaXRpb24sIGNyZWF0ZV9jb21wb25lbnQsIGNyZWF0ZV9pbl90cmFuc2l0aW9uLCBjcmVhdGVfb3V0X3RyYW5zaXRpb24sIGNyZWF0ZV9zbG90LCBjcmVhdGVfc3NyX2NvbXBvbmVudCwgY3VycmVudF9jb21wb25lbnQsIGN1c3RvbV9ldmVudCwgZGF0YXNldF9kZXYsIGRlYnVnLCBkZXN0cm95X2Jsb2NrLCBkZXN0cm95X2NvbXBvbmVudCwgZGVzdHJveV9lYWNoLCBkZXRhY2gsIGRldGFjaF9hZnRlcl9kZXYsIGRldGFjaF9iZWZvcmVfZGV2LCBkZXRhY2hfYmV0d2Vlbl9kZXYsIGRldGFjaF9kZXYsIGRpcnR5X2NvbXBvbmVudHMsIGRpc3BhdGNoX2RldiwgZWFjaCwgZWxlbWVudCwgZWxlbWVudF9pcywgZW1wdHksIGVuZF9oeWRyYXRpbmcsIGVzY2FwZSwgZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZSwgZXNjYXBlX29iamVjdCwgZXhjbHVkZV9pbnRlcm5hbF9wcm9wcywgZml4X2FuZF9kZXN0cm95X2Jsb2NrLCBmaXhfYW5kX291dHJvX2FuZF9kZXN0cm95X2Jsb2NrLCBmaXhfcG9zaXRpb24sIGZsdXNoLCBnZXRBbGxDb250ZXh0cywgZ2V0Q29udGV4dCwgZ2V0X2FsbF9kaXJ0eV9mcm9tX3Njb3BlLCBnZXRfYmluZGluZ19ncm91cF92YWx1ZSwgZ2V0X2N1cnJlbnRfY29tcG9uZW50LCBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzLCBnZXRfcm9vdF9mb3Jfc3R5bGUsIGdldF9zbG90X2NoYW5nZXMsIGdldF9zcHJlYWRfb2JqZWN0LCBnZXRfc3ByZWFkX3VwZGF0ZSwgZ2V0X3N0b3JlX3ZhbHVlLCBnbG9iYWxzLCBncm91cF9vdXRyb3MsIGhhbmRsZV9wcm9taXNlLCBoYXNDb250ZXh0LCBoYXNfcHJvcCwgaWRlbnRpdHksIGluaXQsIGluc2VydCwgaW5zZXJ0X2RldiwgaW5zZXJ0X2h5ZHJhdGlvbiwgaW5zZXJ0X2h5ZHJhdGlvbl9kZXYsIGludHJvcywgaW52YWxpZF9hdHRyaWJ1dGVfbmFtZV9jaGFyYWN0ZXIsIGlzX2NsaWVudCwgaXNfY3Jvc3NvcmlnaW4sIGlzX2VtcHR5LCBpc19mdW5jdGlvbiwgaXNfcHJvbWlzZSwgaXNfdm9pZCwgbGlzdGVuLCBsaXN0ZW5fZGV2LCBsb29wLCBsb29wX2d1YXJkLCBtZXJnZV9zc3Jfc3R5bGVzLCBtaXNzaW5nX2NvbXBvbmVudCwgbW91bnRfY29tcG9uZW50LCBub29wLCBub3RfZXF1YWwsIG5vdywgbnVsbF90b19lbXB0eSwgb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllcywgb25EZXN0cm95LCBvbk1vdW50LCBvbmNlLCBvdXRyb19hbmRfZGVzdHJveV9ibG9jaywgcHJldmVudF9kZWZhdWx0LCBwcm9wX2RldiwgcXVlcnlfc2VsZWN0b3JfYWxsLCByYWYsIHJ1biwgcnVuX2FsbCwgc2FmZV9ub3RfZXF1YWwsIHNjaGVkdWxlX3VwZGF0ZSwgc2VsZWN0X211bHRpcGxlX3ZhbHVlLCBzZWxlY3Rfb3B0aW9uLCBzZWxlY3Rfb3B0aW9ucywgc2VsZWN0X3ZhbHVlLCBzZWxmLCBzZXRDb250ZXh0LCBzZXRfYXR0cmlidXRlcywgc2V0X2N1cnJlbnRfY29tcG9uZW50LCBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YSwgc2V0X2RhdGEsIHNldF9kYXRhX2Rldiwgc2V0X2lucHV0X3R5cGUsIHNldF9pbnB1dF92YWx1ZSwgc2V0X25vdywgc2V0X3JhZiwgc2V0X3N0b3JlX3ZhbHVlLCBzZXRfc3R5bGUsIHNldF9zdmdfYXR0cmlidXRlcywgc3BhY2UsIHNwcmVhZCwgc3JjX3VybF9lcXVhbCwgc3RhcnRfaHlkcmF0aW5nLCBzdG9wX3Byb3BhZ2F0aW9uLCBzdWJzY3JpYmUsIHN2Z19lbGVtZW50LCB0ZXh0LCB0aWNrLCB0aW1lX3Jhbmdlc190b19hcnJheSwgdG9fbnVtYmVyLCB0b2dnbGVfY2xhc3MsIHRyYW5zaXRpb25faW4sIHRyYW5zaXRpb25fb3V0LCB0cnVzdGVkLCB1cGRhdGVfYXdhaXRfYmxvY2tfYnJhbmNoLCB1cGRhdGVfa2V5ZWRfZWFjaCwgdXBkYXRlX3Nsb3QsIHVwZGF0ZV9zbG90X2Jhc2UsIHZhbGlkYXRlX2NvbXBvbmVudCwgdmFsaWRhdGVfZHluYW1pY19lbGVtZW50LCB2YWxpZGF0ZV9lYWNoX2FyZ3VtZW50LCB2YWxpZGF0ZV9lYWNoX2tleXMsIHZhbGlkYXRlX3Nsb3RzLCB2YWxpZGF0ZV9zdG9yZSwgdmFsaWRhdGVfdm9pZF9keW5hbWljX2VsZW1lbnQsIHhsaW5rX2F0dHIgfTtcbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlscy90eXBlLWNoZWNrJztcblxuICBleHBvcnQgbGV0IGNvbmZpZywgc3RlcDtcbiAgbGV0IGFjdGlvbiwgY2xhc3NlcywgZGlzYWJsZWQsIGxhYmVsLCBzZWNvbmRhcnksIHRleHQ7XG5cbiAgJDoge1xuICAgIGFjdGlvbiA9IGNvbmZpZy5hY3Rpb24gPyBjb25maWcuYWN0aW9uLmJpbmQoc3RlcC50b3VyKSA6IG51bGw7XG4gICAgY2xhc3NlcyA9IGNvbmZpZy5jbGFzc2VzO1xuICAgIGRpc2FibGVkID0gY29uZmlnLmRpc2FibGVkID8gZ2V0Q29uZmlnT3B0aW9uKGNvbmZpZy5kaXNhYmxlZCkgOiBmYWxzZTtcbiAgICBsYWJlbCA9IGNvbmZpZy5sYWJlbCA/IGdldENvbmZpZ09wdGlvbihjb25maWcubGFiZWwpIDogbnVsbDtcbiAgICBzZWNvbmRhcnkgPSBjb25maWcuc2Vjb25kYXJ5O1xuICAgIHRleHQgPSBjb25maWcudGV4dCA/IGdldENvbmZpZ09wdGlvbihjb25maWcudGV4dCkgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29uZmlnT3B0aW9uKG9wdGlvbikge1xuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbikpIHtcbiAgICAgIHJldHVybiBvcHRpb24gPSBvcHRpb24uY2FsbChzdGVwKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbjtcbiAgfVxuXG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLWJ1dHRvbiB7XG4gICAgYmFja2dyb3VuZDogcmdiKDUwLCAxMzYsIDIzMCk7XG4gICAgYm9yZGVyOiAwO1xuICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjc1KTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgbWFyZ2luLXJpZ2h0OiAwLjVyZW07XG4gICAgcGFkZGluZzogMC41cmVtIDEuNXJlbTtcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC41cyBlYXNlO1xuICB9XG5cbiAgLnNoZXBoZXJkLWJ1dHRvbjpub3QoOmRpc2FibGVkKTpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogcmdiKDI1LCAxMTEsIDIwNCk7XG4gICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSk7XG4gIH1cblxuICAuc2hlcGhlcmQtYnV0dG9uLnNoZXBoZXJkLWJ1dHRvbi1zZWNvbmRhcnkge1xuICAgIGJhY2tncm91bmQ6IHJnYigyNDEsIDI0MiwgMjQzKTtcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1idXR0b24uc2hlcGhlcmQtYnV0dG9uLXNlY29uZGFyeTpub3QoOmRpc2FibGVkKTpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogcmdiKDIxNCwgMjE3LCAyMTkpO1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNzUpO1xuICB9XG5cbiAgLnNoZXBoZXJkLWJ1dHRvbjpkaXNhYmxlZCB7XG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcbiAgfVxuPC9zdHlsZT5cblxuPGJ1dHRvblxuICBhcmlhLWxhYmVsPVwie2xhYmVsID8gbGFiZWwgOiBudWxsfVwiXG4gIGNsYXNzPVwie2AkeyhjbGFzc2VzIHx8ICcnKX0gc2hlcGhlcmQtYnV0dG9uICR7KHNlY29uZGFyeSA/ICdzaGVwaGVyZC1idXR0b24tc2Vjb25kYXJ5JyA6ICcnKX1gfVwiXG4gIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgb246Y2xpY2s9e2FjdGlvbn1cbiAgdGFiaW5kZXg9XCIwXCJcbj5cbiAgICB7QGh0bWwgdGV4dH1cbjwvYnV0dG9uPlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IFNoZXBoZXJkQnV0dG9uIGZyb20gJy4vc2hlcGhlcmQtYnV0dG9uLnN2ZWx0ZSc7XG5cbiAgZXhwb3J0IGxldCBzdGVwO1xuXG4gICQ6IGJ1dHRvbnMgPSBzdGVwLm9wdGlvbnMuYnV0dG9ucztcbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtZm9vdGVyIHtcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiA1cHg7XG4gICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDVweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG4gICAgcGFkZGluZzogMCAwLjc1cmVtIDAuNzVyZW07XG4gIH1cblxuICAuc2hlcGhlcmQtZm9vdGVyIC5zaGVwaGVyZC1idXR0b246bGFzdC1jaGlsZCB7XG4gICAgbWFyZ2luLXJpZ2h0OiAwO1xuICB9XG48L3N0eWxlPlxuXG48Zm9vdGVyIGNsYXNzPVwic2hlcGhlcmQtZm9vdGVyXCI+XG4gICAgeyNpZiBidXR0b25zfVxuICAgICAgICB7I2VhY2ggYnV0dG9ucyBhcyBjb25maWd9XG4gICAgICAgICAgPFNoZXBoZXJkQnV0dG9uXG4gICAgICAgICAgICB7Y29uZmlnfVxuICAgICAgICAgICAge3N0ZXB9XG4gICAgICAgICAgLz5cbiAgICAgICAgey9lYWNofVxuICAgIHsvaWZ9XG48L2Zvb3Rlcj5cbiIsIjxzY3JpcHQ+XG4gIGV4cG9ydCBsZXQgY2FuY2VsSWNvbiwgc3RlcDtcblxuICAvKipcbiAgICogQWRkIGEgY2xpY2sgbGlzdGVuZXIgdG8gdGhlIGNhbmNlbCBsaW5rIHRoYXQgY2FuY2VscyB0aGUgdG91clxuICAgKi9cbiAgY29uc3QgaGFuZGxlQ2FuY2VsQ2xpY2sgPSAoZSkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBzdGVwLmNhbmNlbCgpO1xuICB9O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1jYW5jZWwtaWNvbiB7XG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgYm9yZGVyOiBub25lO1xuICAgIGNvbG9yOiByZ2JhKDEyOCwgMTI4LCAxMjgsIDAuNzUpO1xuICAgIGZvbnQtc2l6ZTogMmVtO1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBmb250LXdlaWdodDogbm9ybWFsO1xuICAgIG1hcmdpbjogMDtcbiAgICBwYWRkaW5nOiAwO1xuICAgIHRyYW5zaXRpb246IGNvbG9yIDAuNXMgZWFzZTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1jYW5jZWwtaWNvbjpob3ZlciB7XG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gIH1cblxuICAuc2hlcGhlcmQtaGFzLXRpdGxlIC5zaGVwaGVyZC1jb250ZW50IC5zaGVwaGVyZC1jYW5jZWwtaWNvbiB7XG4gICAgY29sb3I6IHJnYmEoMTI4LCAxMjgsIDEyOCwgMC43NSk7XG4gIH1cblxuICAuc2hlcGhlcmQtaGFzLXRpdGxlIC5zaGVwaGVyZC1jb250ZW50IC5zaGVwaGVyZC1jYW5jZWwtaWNvbjpob3ZlciB7XG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gIH1cbjwvc3R5bGU+XG5cbjxidXR0b25cbiAgYXJpYS1sYWJlbD1cIntjYW5jZWxJY29uLmxhYmVsID8gY2FuY2VsSWNvbi5sYWJlbCA6ICdDbG9zZSBUb3VyJ31cIlxuICBjbGFzcz1cInNoZXBoZXJkLWNhbmNlbC1pY29uXCJcbiAgb246Y2xpY2s9e2hhbmRsZUNhbmNlbENsaWNrfVxuICB0eXBlPVwiYnV0dG9uXCJcbj5cbiAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvc3Bhbj5cbjwvYnV0dG9uPlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgYWZ0ZXJVcGRhdGUgfSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbHMvdHlwZS1jaGVjayc7XG4gIFxuICBleHBvcnQgbGV0IGxhYmVsSWQsIGVsZW1lbnQsIHRpdGxlO1xuICBcbiAgYWZ0ZXJVcGRhdGUoKCkgPT4ge1xuICAgIGlmIChpc0Z1bmN0aW9uKHRpdGxlKSkge1xuICAgICAgdGl0bGUgPSB0aXRsZSgpO1xuICAgIH1cbiAgICBcbiAgICBlbGVtZW50LmlubmVySFRNTCA9IHRpdGxlO1xuICB9KTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtdGl0bGUge1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNzUpO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZm9udC1zaXplOiAxcmVtO1xuICAgIGZvbnQtd2VpZ2h0OiBub3JtYWw7XG4gICAgZmxleDogMSAwIGF1dG87XG4gICAgbWFyZ2luOiAwO1xuICAgIHBhZGRpbmc6IDA7XG4gIH1cbjwvc3R5bGU+XG5cbjxoM1xuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIGlkPVwie2xhYmVsSWR9XCJcbiAgY2xhc3M9XCJzaGVwaGVyZC10aXRsZVwiXG4+XG48L2gzPlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IFNoZXBoZXJkQ2FuY2VsSWNvbiBmcm9tICcuL3NoZXBoZXJkLWNhbmNlbC1pY29uLnN2ZWx0ZSc7XG4gIGltcG9ydCBTaGVwaGVyZFRpdGxlIGZyb20gJy4vc2hlcGhlcmQtdGl0bGUuc3ZlbHRlJztcblxuICBleHBvcnQgbGV0IGxhYmVsSWQsIHN0ZXA7XG4gIGxldCB0aXRsZSwgY2FuY2VsSWNvbjtcblxuICAkOiB7XG4gICAgICB0aXRsZSA9IHN0ZXAub3B0aW9ucy50aXRsZTtcbiAgICAgIGNhbmNlbEljb24gPSBzdGVwLm9wdGlvbnMuY2FuY2VsSWNvbjtcbiAgfVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1oZWFkZXIge1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogNXB4O1xuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA1cHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuICAgIGxpbmUtaGVpZ2h0OiAyZW07XG4gICAgcGFkZGluZzogMC43NXJlbSAwLjc1cmVtIDA7XG4gIH1cblxuICAuc2hlcGhlcmQtaGFzLXRpdGxlIC5zaGVwaGVyZC1jb250ZW50IC5zaGVwaGVyZC1oZWFkZXIge1xuICAgIGJhY2tncm91bmQ6ICNlNmU2ZTY7XG4gICAgcGFkZGluZzogMWVtO1xuICB9XG48L3N0eWxlPlxuXG48aGVhZGVyIGNsYXNzPVwic2hlcGhlcmQtaGVhZGVyXCI+XG4gICAgeyNpZiB0aXRsZX1cbiAgICAgIDxTaGVwaGVyZFRpdGxlXG4gICAgICAgIHtsYWJlbElkfVxuICAgICAgICB7dGl0bGV9XG4gICAgICAvPlxuICAgIHsvaWZ9XG5cbiAgICB7I2lmIGNhbmNlbEljb24gJiYgY2FuY2VsSWNvbi5lbmFibGVkfVxuICAgICAgPFNoZXBoZXJkQ2FuY2VsSWNvblxuICAgICAgICB7Y2FuY2VsSWNvbn1cbiAgICAgICAge3N0ZXB9XG4gICAgICAvPlxuICAgIHsvaWZ9XG48L2hlYWRlcj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGFmdGVyVXBkYXRlIH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IHsgaXNIVE1MRWxlbWVudCwgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxzL3R5cGUtY2hlY2snO1xuXG4gIGV4cG9ydCBsZXQgZGVzY3JpcHRpb25JZCwgZWxlbWVudCwgc3RlcDtcblxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgbGV0IHsgdGV4dCB9ID0gc3RlcC5vcHRpb25zO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24odGV4dCkpIHtcbiAgICAgIHRleHQgPSB0ZXh0LmNhbGwoc3RlcCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQodGV4dCkpIHtcbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gdGV4dDtcbiAgICB9XG4gIH0pO1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC10ZXh0IHtcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgICBmb250LXNpemU6IDFyZW07XG4gICAgbGluZS1oZWlnaHQ6IDEuM2VtO1xuICAgIHBhZGRpbmc6IDAuNzVlbTtcbiAgfVxuXG4gIC5zaGVwaGVyZC10ZXh0IHAge1xuICAgIG1hcmdpbi10b3A6IDA7XG4gIH1cblxuICAuc2hlcGhlcmQtdGV4dCBwOmxhc3QtY2hpbGQge1xuICAgIG1hcmdpbi1ib3R0b206IDA7XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXZcbiAgYmluZDp0aGlzPXtlbGVtZW50fVxuICBjbGFzcz1cInNoZXBoZXJkLXRleHRcIlxuICBpZD1cIntkZXNjcmlwdGlvbklkfVwiXG4+XG48L2Rpdj5cblxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IFNoZXBoZXJkRm9vdGVyIGZyb20gJy4vc2hlcGhlcmQtZm9vdGVyLnN2ZWx0ZSc7XG4gIGltcG9ydCBTaGVwaGVyZEhlYWRlciBmcm9tICcuL3NoZXBoZXJkLWhlYWRlci5zdmVsdGUnO1xuICBpbXBvcnQgU2hlcGhlcmRUZXh0IGZyb20gJy4vc2hlcGhlcmQtdGV4dC5zdmVsdGUnO1xuICBpbXBvcnQgeyBpc1VuZGVmaW5lZCB9IGZyb20gJy4uL3V0aWxzL3R5cGUtY2hlY2suanMnO1xuXG4gIGV4cG9ydCBsZXQgZGVzY3JpcHRpb25JZCwgbGFiZWxJZCwgc3RlcDtcbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtY29udGVudCB7XG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xuICAgIG91dGxpbmU6IG5vbmU7XG4gICAgcGFkZGluZzogMDtcbiAgfVxuPC9zdHlsZT5cblxuPGRpdlxuICBjbGFzcz1cInNoZXBoZXJkLWNvbnRlbnRcIlxuPlxuICB7I2lmICFpc1VuZGVmaW5lZChzdGVwLm9wdGlvbnMudGl0bGUpIHx8IChzdGVwLm9wdGlvbnMuY2FuY2VsSWNvbiAmJiBzdGVwLm9wdGlvbnMuY2FuY2VsSWNvbi5lbmFibGVkKX1cbiAgICA8U2hlcGhlcmRIZWFkZXJcbiAgICAgIHtsYWJlbElkfVxuICAgICAge3N0ZXB9XG4gICAgLz5cbiAgey9pZn1cblxuICB7I2lmICFpc1VuZGVmaW5lZChzdGVwLm9wdGlvbnMudGV4dCl9XG4gICAgPFNoZXBoZXJkVGV4dFxuICAgICAge2Rlc2NyaXB0aW9uSWR9XG4gICAgICB7c3RlcH1cbiAgICAvPlxuICB7L2lmfVxuXG4gIHsjaWYgQXJyYXkuaXNBcnJheShzdGVwLm9wdGlvbnMuYnV0dG9ucykgJiYgc3RlcC5vcHRpb25zLmJ1dHRvbnMubGVuZ3RofVxuICAgIDxTaGVwaGVyZEZvb3RlclxuICAgICAge3N0ZXB9XG4gICAgLz5cbiAgey9pZn1cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgb25Nb3VudCwgYWZ0ZXJVcGRhdGUgfSBmcm9tICdzdmVsdGUnO1xuICBpbXBvcnQgU2hlcGhlcmRDb250ZW50IGZyb20gJy4vc2hlcGhlcmQtY29udGVudC5zdmVsdGUnO1xuICBpbXBvcnQgeyBpc1VuZGVmaW5lZCwgaXNTdHJpbmcgfSBmcm9tICcuLi91dGlscy90eXBlLWNoZWNrLmpzJztcblxuICBjb25zdCBLRVlfVEFCID0gOTtcbiAgY29uc3QgS0VZX0VTQyA9IDI3O1xuICBjb25zdCBMRUZUX0FSUk9XID0gMzc7XG4gIGNvbnN0IFJJR0hUX0FSUk9XID0gMzk7XG5cbiAgZXhwb3J0IGxldCBjbGFzc1ByZWZpeCwgZWxlbWVudCwgZGVzY3JpcHRpb25JZCwgZmlyc3RGb2N1c2FibGVFbGVtZW50LFxuICAgIGZvY3VzYWJsZUVsZW1lbnRzLCBsYWJlbElkLCBsYXN0Rm9jdXNhYmxlRWxlbWVudCwgc3RlcCwgZGF0YVN0ZXBJZDtcblxuICBsZXQgaGFzQ2FuY2VsSWNvbiwgaGFzVGl0bGUsIGNsYXNzZXM7XG5cbiAgJDoge1xuICAgIGhhc0NhbmNlbEljb24gPSBzdGVwLm9wdGlvbnMgJiYgc3RlcC5vcHRpb25zLmNhbmNlbEljb24gJiYgc3RlcC5vcHRpb25zLmNhbmNlbEljb24uZW5hYmxlZDtcbiAgICBoYXNUaXRsZSA9IHN0ZXAub3B0aW9ucyAmJiBzdGVwLm9wdGlvbnMudGl0bGU7XG4gIH1cblxuICBleHBvcnQgY29uc3QgZ2V0RWxlbWVudCA9ICgpID0+IGVsZW1lbnQ7XG5cbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgLy8gR2V0IGFsbCBlbGVtZW50cyB0aGF0IGFyZSBmb2N1c2FibGVcbiAgICBkYXRhU3RlcElkID0geyBbYGRhdGEtJHtjbGFzc1ByZWZpeH1zaGVwaGVyZC1zdGVwLWlkYF06IHN0ZXAuaWQgfTtcbiAgICBmb2N1c2FibGVFbGVtZW50cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLCBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksIFt0YWJpbmRleD1cIjBcIl0nKTtcbiAgICBmaXJzdEZvY3VzYWJsZUVsZW1lbnQgPSBmb2N1c2FibGVFbGVtZW50c1swXTtcbiAgICBsYXN0Rm9jdXNhYmxlRWxlbWVudCA9IGZvY3VzYWJsZUVsZW1lbnRzW2ZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCAtIDFdO1xuICB9KTtcblxuICBhZnRlclVwZGF0ZSgoKSA9PiB7XG4gICAgaWYoY2xhc3NlcyAhPT0gc3RlcC5vcHRpb25zLmNsYXNzZXMpIHtcbiAgICAgIHVwZGF0ZUR5bmFtaWNDbGFzc2VzKCk7XG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiB1cGRhdGVEeW5hbWljQ2xhc3NlcygpIHtcbiAgICAgIHJlbW92ZUNsYXNzZXMoY2xhc3Nlcyk7XG4gICAgICBjbGFzc2VzID0gc3RlcC5vcHRpb25zLmNsYXNzZXM7XG4gICAgICBhZGRDbGFzc2VzKGNsYXNzZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3NlcyhjbGFzc2VzKSB7XG4gICAgaWYgKGlzU3RyaW5nKGNsYXNzZXMpKSB7XG4gICAgICBjb25zdCBvbGRDbGFzc2VzID0gZ2V0Q2xhc3Nlc0FycmF5KGNsYXNzZXMpO1xuICAgICAgaWYgKG9sZENsYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSguLi5vbGRDbGFzc2VzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRDbGFzc2VzKGNsYXNzZXMpIHtcbiAgICBpZihpc1N0cmluZyhjbGFzc2VzKSkge1xuICAgICAgY29uc3QgbmV3Q2xhc3NlcyA9IGdldENsYXNzZXNBcnJheShjbGFzc2VzKTtcbiAgICAgIGlmIChuZXdDbGFzc2VzLmxlbmd0aCkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoLi4ubmV3Q2xhc3Nlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3Nlc0FycmF5KGNsYXNzZXMpIHtcbiAgICAgcmV0dXJuIGNsYXNzZXMuc3BsaXQoJyAnKS5maWx0ZXIoY2xhc3NOYW1lID0+ICEhY2xhc3NOYW1lLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAga2V5ZG93biBldmVudHMgdG8gYWxsb3cgY2xvc2luZyB0aGUgbW9kYWwgd2l0aCBFU0NcbiAgICpcbiAgICogQm9ycm93ZWQgZnJvbSB0aGlzIGdyZWF0IHBvc3QhIGh0dHBzOi8vYml0c29mY28uZGUvYWNjZXNzaWJsZS1tb2RhbC1kaWFsb2cvXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGUpID0+IHtcbiAgICBjb25zdCB7IHRvdXIgfSA9IHN0ZXA7XG4gICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgIGNhc2UgS0VZX1RBQjpcbiAgICAgICAgaWYgKGZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBCYWNrd2FyZCB0YWJcbiAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZmlyc3RGb2N1c2FibGVFbGVtZW50IHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaGVwaGVyZC1lbGVtZW50JykpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGxhc3RGb2N1c2FibGVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBsYXN0Rm9jdXNhYmxlRWxlbWVudCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZmlyc3RGb2N1c2FibGVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLRVlfRVNDOlxuICAgICAgICBpZiAodG91ci5vcHRpb25zLmV4aXRPbkVzYykge1xuICAgICAgICAgIHN0ZXAuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExFRlRfQVJST1c6XG4gICAgICAgIGlmICh0b3VyLm9wdGlvbnMua2V5Ym9hcmROYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgdG91ci5iYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJJR0hUX0FSUk9XOlxuICAgICAgICBpZiAodG91ci5vcHRpb25zLmtleWJvYXJkTmF2aWdhdGlvbikge1xuICAgICAgICAgIHRvdXIubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1lbGVtZW50IHtcbiAgICBiYWNrZ3JvdW5kOiAjZmZmO1xuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcbiAgICBib3gtc2hhZG93OiAwIDFweCA0cHggcmdiYSgwLCAwLCAwLCAwLjIpO1xuICAgIG1heC13aWR0aDogNDAwcHg7XG4gICAgb3BhY2l0eTogMDtcbiAgICBvdXRsaW5lOiBub25lO1xuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4zcywgdmlzaWJpbGl0eSAwLjNzO1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICB3aWR0aDogMTAwJTtcbiAgICB6LWluZGV4OiA5OTk5O1xuICB9XG5cbiAgLnNoZXBoZXJkLWVuYWJsZWQuc2hlcGhlcmQtZWxlbWVudCB7XG4gICAgb3BhY2l0eTogMTtcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnRbZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbl06bm90KC5zaGVwaGVyZC1jZW50ZXJlZCkge1xuICAgIG9wYWNpdHk6IDA7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnQsIC5zaGVwaGVyZC1lbGVtZW50ICosXG4gIC5zaGVwaGVyZC1lbGVtZW50ICo6YWZ0ZXIsXG4gIC5zaGVwaGVyZC1lbGVtZW50ICo6YmVmb3JlIHtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICB9XG5cbiAgLnNoZXBoZXJkLWFycm93LFxuICAuc2hlcGhlcmQtYXJyb3c6OmJlZm9yZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIHdpZHRoOiAxNnB4O1xuICAgIGhlaWdodDogMTZweDtcbiAgICB6LWluZGV4OiAtMTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1hcnJvdzpiZWZvcmUge1xuICAgIGNvbnRlbnQ6ICcnO1xuICAgIHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTtcbiAgICBiYWNrZ3JvdW5kOiAjZmZmICA7XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudFtkYXRhLXBvcHBlci1wbGFjZW1lbnRePSd0b3AnXSA+IC5zaGVwaGVyZC1hcnJvdyB7XG4gICAgYm90dG9tOiAtOHB4O1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnRbZGF0YS1wb3BwZXItcGxhY2VtZW50Xj0nYm90dG9tJ10gPiAuc2hlcGhlcmQtYXJyb3cge1xuICAgIHRvcDogLThweDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50W2RhdGEtcG9wcGVyLXBsYWNlbWVudF49J2xlZnQnXSA+IC5zaGVwaGVyZC1hcnJvdyB7XG4gICAgcmlnaHQ6IC04cHg7XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudFtkYXRhLXBvcHBlci1wbGFjZW1lbnRePSdyaWdodCddID4gLnNoZXBoZXJkLWFycm93IHtcbiAgICBsZWZ0OiAtOHB4O1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnQuc2hlcGhlcmQtY2VudGVyZWQgPiAuc2hlcGhlcmQtYXJyb3cge1xuICAgIG9wYWNpdHk6IDA7XG4gIH1cblxuXG4gIC8qKlxuICAqIEFycm93IG9uIHRvcCBvZiB0b29sdGlwIGNlbnRlcmVkIGhvcml6b250YWxseSwgd2l0aCB0aXRsZSBjb2xvclxuICAqL1xuICAuc2hlcGhlcmQtZWxlbWVudC5zaGVwaGVyZC1oYXMtdGl0bGVbZGF0YS1wb3BwZXItcGxhY2VtZW50Xj0nYm90dG9tJ10gPiAuc2hlcGhlcmQtYXJyb3c6OmJlZm9yZSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2U2ZTZlNjtcbiAgfVxuXG4gIC5zaGVwaGVyZC10YXJnZXQtY2xpY2stZGlzYWJsZWQuc2hlcGhlcmQtZW5hYmxlZC5zaGVwaGVyZC10YXJnZXQsXG4gIC5zaGVwaGVyZC10YXJnZXQtY2xpY2stZGlzYWJsZWQuc2hlcGhlcmQtZW5hYmxlZC5zaGVwaGVyZC10YXJnZXQgKiB7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXZcbiAgYXJpYS1kZXNjcmliZWRieT17IWlzVW5kZWZpbmVkKHN0ZXAub3B0aW9ucy50ZXh0KSA/IGRlc2NyaXB0aW9uSWQgOiBudWxsfVxuICBhcmlhLWxhYmVsbGVkYnk9e3N0ZXAub3B0aW9ucy50aXRsZSA/IGxhYmVsSWQgOiBudWxsfVxuICBiaW5kOnRoaXM9e2VsZW1lbnR9XG4gIGNsYXNzOnNoZXBoZXJkLWhhcy1jYW5jZWwtaWNvbj1cIntoYXNDYW5jZWxJY29ufVwiXG4gIGNsYXNzOnNoZXBoZXJkLWhhcy10aXRsZT1cIntoYXNUaXRsZX1cIlxuICBjbGFzczpzaGVwaGVyZC1lbGVtZW50PVwie3RydWV9XCJcbiAgey4uLmRhdGFTdGVwSWR9XG4gIG9uOmtleWRvd249e2hhbmRsZUtleURvd259XG4gIHJvbGU9XCJkaWFsb2dcIlxuICB0YWJpbmRleD1cIjBcIlxuPlxuICAgIHsjaWYgc3RlcC5vcHRpb25zLmFycm93ICYmIHN0ZXAub3B0aW9ucy5hdHRhY2hUbyAmJiBzdGVwLm9wdGlvbnMuYXR0YWNoVG8uZWxlbWVudCAmJiBzdGVwLm9wdGlvbnMuYXR0YWNoVG8ub259XG4gICAgICA8ZGl2IGNsYXNzPVwic2hlcGhlcmQtYXJyb3dcIiBkYXRhLXBvcHBlci1hcnJvdz48L2Rpdj5cbiAgICB7L2lmfVxuICA8U2hlcGhlcmRDb250ZW50XG4gICAge2Rlc2NyaXB0aW9uSWR9XG4gICAge2xhYmVsSWR9XG4gICAge3N0ZXB9XG4gIC8+XG48L2Rpdj5cbiIsIi8qIHNtb290aHNjcm9sbCB2MC40LjQgLSAyMDE5IC0gRHVzdGFuIEthc3RlbiwgSmVyZW1pYXMgTWVuaWNoZWxsaSAtIE1JVCBMaWNlbnNlICovXG4oZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gcG9seWZpbGxcbiAgZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gICAgLy8gYWxpYXNlc1xuICAgIHZhciB3ID0gd2luZG93O1xuICAgIHZhciBkID0gZG9jdW1lbnQ7XG5cbiAgICAvLyByZXR1cm4gaWYgc2Nyb2xsIGJlaGF2aW9yIGlzIHN1cHBvcnRlZCBhbmQgcG9seWZpbGwgaXMgbm90IGZvcmNlZFxuICAgIGlmIChcbiAgICAgICdzY3JvbGxCZWhhdmlvcicgaW4gZC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiZcbiAgICAgIHcuX19mb3JjZVNtb290aFNjcm9sbFBvbHlmaWxsX18gIT09IHRydWVcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBnbG9iYWxzXG4gICAgdmFyIEVsZW1lbnQgPSB3LkhUTUxFbGVtZW50IHx8IHcuRWxlbWVudDtcbiAgICB2YXIgU0NST0xMX1RJTUUgPSA0Njg7XG5cbiAgICAvLyBvYmplY3QgZ2F0aGVyaW5nIG9yaWdpbmFsIHNjcm9sbCBtZXRob2RzXG4gICAgdmFyIG9yaWdpbmFsID0ge1xuICAgICAgc2Nyb2xsOiB3LnNjcm9sbCB8fCB3LnNjcm9sbFRvLFxuICAgICAgc2Nyb2xsQnk6IHcuc2Nyb2xsQnksXG4gICAgICBlbGVtZW50U2Nyb2xsOiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgfHwgc2Nyb2xsRWxlbWVudCxcbiAgICAgIHNjcm9sbEludG9WaWV3OiBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlld1xuICAgIH07XG5cbiAgICAvLyBkZWZpbmUgdGltaW5nIG1ldGhvZFxuICAgIHZhciBub3cgPVxuICAgICAgdy5wZXJmb3JtYW5jZSAmJiB3LnBlcmZvcm1hbmNlLm5vd1xuICAgICAgICA/IHcucGVyZm9ybWFuY2Uubm93LmJpbmQody5wZXJmb3JtYW5jZSlcbiAgICAgICAgOiBEYXRlLm5vdztcblxuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBpZiBhIHRoZSBjdXJyZW50IGJyb3dzZXIgaXMgbWFkZSBieSBNaWNyb3NvZnRcbiAgICAgKiBAbWV0aG9kIGlzTWljcm9zb2Z0QnJvd3NlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyQWdlbnRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01pY3Jvc29mdEJyb3dzZXIodXNlckFnZW50KSB7XG4gICAgICB2YXIgdXNlckFnZW50UGF0dGVybnMgPSBbJ01TSUUgJywgJ1RyaWRlbnQvJywgJ0VkZ2UvJ107XG5cbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVzZXJBZ2VudFBhdHRlcm5zLmpvaW4oJ3wnKSkudGVzdCh1c2VyQWdlbnQpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogSUUgaGFzIHJvdW5kaW5nIGJ1ZyByb3VuZGluZyBkb3duIGNsaWVudEhlaWdodCBhbmQgY2xpZW50V2lkdGggYW5kXG4gICAgICogcm91bmRpbmcgdXAgc2Nyb2xsSGVpZ2h0IGFuZCBzY3JvbGxXaWR0aCBjYXVzaW5nIGZhbHNlIHBvc2l0aXZlc1xuICAgICAqIG9uIGhhc1Njcm9sbGFibGVTcGFjZVxuICAgICAqL1xuICAgIHZhciBST1VORElOR19UT0xFUkFOQ0UgPSBpc01pY3Jvc29mdEJyb3dzZXIody5uYXZpZ2F0b3IudXNlckFnZW50KSA/IDEgOiAwO1xuXG4gICAgLyoqXG4gICAgICogY2hhbmdlcyBzY3JvbGwgcG9zaXRpb24gaW5zaWRlIGFuIGVsZW1lbnRcbiAgICAgKiBAbWV0aG9kIHNjcm9sbEVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzY3JvbGxFbGVtZW50KHgsIHkpIHtcbiAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHg7XG4gICAgICB0aGlzLnNjcm9sbFRvcCA9IHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyByZXN1bHQgb2YgYXBwbHlpbmcgZWFzZSBtYXRoIGZ1bmN0aW9uIHRvIGEgbnVtYmVyXG4gICAgICogQG1ldGhvZCBlYXNlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGtcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVhc2Uoaykge1xuICAgICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgaWYgYSBzbW9vdGggYmVoYXZpb3Igc2hvdWxkIGJlIGFwcGxpZWRcbiAgICAgKiBAbWV0aG9kIHNob3VsZEJhaWxPdXRcbiAgICAgKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IGZpcnN0QXJnXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hvdWxkQmFpbE91dChmaXJzdEFyZykge1xuICAgICAgaWYgKFxuICAgICAgICBmaXJzdEFyZyA9PT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2YgZmlyc3RBcmcgIT09ICdvYmplY3QnIHx8XG4gICAgICAgIGZpcnN0QXJnLmJlaGF2aW9yID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgZmlyc3RBcmcuYmVoYXZpb3IgPT09ICdhdXRvJyB8fFxuICAgICAgICBmaXJzdEFyZy5iZWhhdmlvciA9PT0gJ2luc3RhbnQnXG4gICAgICApIHtcbiAgICAgICAgLy8gZmlyc3QgYXJndW1lbnQgaXMgbm90IGFuIG9iamVjdC9udWxsXG4gICAgICAgIC8vIG9yIGJlaGF2aW9yIGlzIGF1dG8sIGluc3RhbnQgb3IgdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGZpcnN0QXJnID09PSAnb2JqZWN0JyAmJiBmaXJzdEFyZy5iZWhhdmlvciA9PT0gJ3Ntb290aCcpIHtcbiAgICAgICAgLy8gZmlyc3QgYXJndW1lbnQgaXMgYW4gb2JqZWN0IGFuZCBiZWhhdmlvciBpcyBzbW9vdGhcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyB0aHJvdyBlcnJvciB3aGVuIGJlaGF2aW9yIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdiZWhhdmlvciBtZW1iZXIgb2YgU2Nyb2xsT3B0aW9ucyAnICtcbiAgICAgICAgICBmaXJzdEFyZy5iZWhhdmlvciArXG4gICAgICAgICAgJyBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgZW51bWVyYXRpb24gU2Nyb2xsQmVoYXZpb3IuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgaWYgYW4gZWxlbWVudCBoYXMgc2Nyb2xsYWJsZSBzcGFjZSBpbiB0aGUgcHJvdmlkZWQgYXhpc1xuICAgICAqIEBtZXRob2QgaGFzU2Nyb2xsYWJsZVNwYWNlXG4gICAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBheGlzXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzU2Nyb2xsYWJsZVNwYWNlKGVsLCBheGlzKSB7XG4gICAgICBpZiAoYXhpcyA9PT0gJ1knKSB7XG4gICAgICAgIHJldHVybiBlbC5jbGllbnRIZWlnaHQgKyBST1VORElOR19UT0xFUkFOQ0UgPCBlbC5zY3JvbGxIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChheGlzID09PSAnWCcpIHtcbiAgICAgICAgcmV0dXJuIGVsLmNsaWVudFdpZHRoICsgUk9VTkRJTkdfVE9MRVJBTkNFIDwgZWwuc2Nyb2xsV2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGFuIGVsZW1lbnQgaGFzIGEgc2Nyb2xsYWJsZSBvdmVyZmxvdyBwcm9wZXJ0eSBpbiB0aGUgYXhpc1xuICAgICAqIEBtZXRob2QgY2FuT3ZlcmZsb3dcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF4aXNcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYW5PdmVyZmxvdyhlbCwgYXhpcykge1xuICAgICAgdmFyIG92ZXJmbG93VmFsdWUgPSB3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpWydvdmVyZmxvdycgKyBheGlzXTtcblxuICAgICAgcmV0dXJuIG92ZXJmbG93VmFsdWUgPT09ICdhdXRvJyB8fCBvdmVyZmxvd1ZhbHVlID09PSAnc2Nyb2xsJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgaWYgYW4gZWxlbWVudCBjYW4gYmUgc2Nyb2xsZWQgaW4gZWl0aGVyIGF4aXNcbiAgICAgKiBAbWV0aG9kIGlzU2Nyb2xsYWJsZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXhpc1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU2Nyb2xsYWJsZShlbCkge1xuICAgICAgdmFyIGlzU2Nyb2xsYWJsZVkgPSBoYXNTY3JvbGxhYmxlU3BhY2UoZWwsICdZJykgJiYgY2FuT3ZlcmZsb3coZWwsICdZJyk7XG4gICAgICB2YXIgaXNTY3JvbGxhYmxlWCA9IGhhc1Njcm9sbGFibGVTcGFjZShlbCwgJ1gnKSAmJiBjYW5PdmVyZmxvdyhlbCwgJ1gnKTtcblxuICAgICAgcmV0dXJuIGlzU2Nyb2xsYWJsZVkgfHwgaXNTY3JvbGxhYmxlWDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBmaW5kcyBzY3JvbGxhYmxlIHBhcmVudCBvZiBhbiBlbGVtZW50XG4gICAgICogQG1ldGhvZCBmaW5kU2Nyb2xsYWJsZVBhcmVudFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcmV0dXJucyB7Tm9kZX0gZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kU2Nyb2xsYWJsZVBhcmVudChlbCkge1xuICAgICAgd2hpbGUgKGVsICE9PSBkLmJvZHkgJiYgaXNTY3JvbGxhYmxlKGVsKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWwgPSBlbC5wYXJlbnROb2RlIHx8IGVsLmhvc3Q7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWxmIGludm9rZWQgZnVuY3Rpb24gdGhhdCwgZ2l2ZW4gYSBjb250ZXh0LCBzdGVwcyB0aHJvdWdoIHNjcm9sbGluZ1xuICAgICAqIEBtZXRob2Qgc3RlcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGVwKGNvbnRleHQpIHtcbiAgICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB2YXIgY3VycmVudFg7XG4gICAgICB2YXIgY3VycmVudFk7XG4gICAgICB2YXIgZWxhcHNlZCA9ICh0aW1lIC0gY29udGV4dC5zdGFydFRpbWUpIC8gU0NST0xMX1RJTUU7XG5cbiAgICAgIC8vIGF2b2lkIGVsYXBzZWQgdGltZXMgaGlnaGVyIHRoYW4gb25lXG4gICAgICBlbGFwc2VkID0gZWxhcHNlZCA+IDEgPyAxIDogZWxhcHNlZDtcblxuICAgICAgLy8gYXBwbHkgZWFzaW5nIHRvIGVsYXBzZWQgdGltZVxuICAgICAgdmFsdWUgPSBlYXNlKGVsYXBzZWQpO1xuXG4gICAgICBjdXJyZW50WCA9IGNvbnRleHQuc3RhcnRYICsgKGNvbnRleHQueCAtIGNvbnRleHQuc3RhcnRYKSAqIHZhbHVlO1xuICAgICAgY3VycmVudFkgPSBjb250ZXh0LnN0YXJ0WSArIChjb250ZXh0LnkgLSBjb250ZXh0LnN0YXJ0WSkgKiB2YWx1ZTtcblxuICAgICAgY29udGV4dC5tZXRob2QuY2FsbChjb250ZXh0LnNjcm9sbGFibGUsIGN1cnJlbnRYLCBjdXJyZW50WSk7XG5cbiAgICAgIC8vIHNjcm9sbCBtb3JlIGlmIHdlIGhhdmUgbm90IHJlYWNoZWQgb3VyIGRlc3RpbmF0aW9uXG4gICAgICBpZiAoY3VycmVudFggIT09IGNvbnRleHQueCB8fCBjdXJyZW50WSAhPT0gY29udGV4dC55KSB7XG4gICAgICAgIHcucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXAuYmluZCh3LCBjb250ZXh0KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2Nyb2xscyB3aW5kb3cgb3IgZWxlbWVudCB3aXRoIGEgc21vb3RoIGJlaGF2aW9yXG4gICAgICogQG1ldGhvZCBzbW9vdGhTY3JvbGxcbiAgICAgKiBAcGFyYW0ge09iamVjdHxOb2RlfSBlbFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNtb290aFNjcm9sbChlbCwgeCwgeSkge1xuICAgICAgdmFyIHNjcm9sbGFibGU7XG4gICAgICB2YXIgc3RhcnRYO1xuICAgICAgdmFyIHN0YXJ0WTtcbiAgICAgIHZhciBtZXRob2Q7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gbm93KCk7XG5cbiAgICAgIC8vIGRlZmluZSBzY3JvbGwgY29udGV4dFxuICAgICAgaWYgKGVsID09PSBkLmJvZHkpIHtcbiAgICAgICAgc2Nyb2xsYWJsZSA9IHc7XG4gICAgICAgIHN0YXJ0WCA9IHcuc2Nyb2xsWCB8fCB3LnBhZ2VYT2Zmc2V0O1xuICAgICAgICBzdGFydFkgPSB3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldDtcbiAgICAgICAgbWV0aG9kID0gb3JpZ2luYWwuc2Nyb2xsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Nyb2xsYWJsZSA9IGVsO1xuICAgICAgICBzdGFydFggPSBlbC5zY3JvbGxMZWZ0O1xuICAgICAgICBzdGFydFkgPSBlbC5zY3JvbGxUb3A7XG4gICAgICAgIG1ldGhvZCA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHNjcm9sbCBsb29waW5nIG92ZXIgYSBmcmFtZVxuICAgICAgc3RlcCh7XG4gICAgICAgIHNjcm9sbGFibGU6IHNjcm9sbGFibGUsXG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgc3RhcnRYOiBzdGFydFgsXG4gICAgICAgIHN0YXJ0WTogc3RhcnRZLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBPUklHSU5BTCBNRVRIT0RTIE9WRVJSSURFU1xuICAgIC8vIHcuc2Nyb2xsIGFuZCB3LnNjcm9sbFRvXG4gICAgdy5zY3JvbGwgPSB3LnNjcm9sbFRvID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBhY3Rpb24gd2hlbiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZFxuICAgICAgaWYgKGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYXZvaWQgc21vb3RoIGJlaGF2aW9yIGlmIG5vdCByZXF1aXJlZFxuICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSA9PT0gdHJ1ZSkge1xuICAgICAgICBvcmlnaW5hbC5zY3JvbGwuY2FsbChcbiAgICAgICAgICB3LFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdLmxlZnRcbiAgICAgICAgICAgIDogdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgPyBhcmd1bWVudHNbMF1cbiAgICAgICAgICAgICAgOiB3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldCxcbiAgICAgICAgICAvLyB1c2UgdG9wIHByb3AsIHNlY29uZCBhcmd1bWVudCBpZiBwcmVzZW50IG9yIGZhbGxiYWNrIHRvIHNjcm9sbFlcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdLnRvcFxuICAgICAgICAgICAgOiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICA/IGFyZ3VtZW50c1sxXVxuICAgICAgICAgICAgICA6IHcuc2Nyb2xsWSB8fCB3LnBhZ2VZT2Zmc2V0XG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgdyxcbiAgICAgICAgZC5ib2R5LFxuICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS5sZWZ0XG4gICAgICAgICAgOiB3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldCxcbiAgICAgICAgYXJndW1lbnRzWzBdLnRvcCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS50b3BcbiAgICAgICAgICA6IHcuc2Nyb2xsWSB8fCB3LnBhZ2VZT2Zmc2V0XG4gICAgICApO1xuICAgIH07XG5cbiAgICAvLyB3LnNjcm9sbEJ5XG4gICAgdy5zY3JvbGxCeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgYWN0aW9uIHdoZW4gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWRcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgb3JpZ2luYWwuc2Nyb2xsQnkuY2FsbChcbiAgICAgICAgICB3LFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdLmxlZnRcbiAgICAgICAgICAgIDogdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ29iamVjdCcgPyBhcmd1bWVudHNbMF0gOiAwLFxuICAgICAgICAgIGFyZ3VtZW50c1swXS50b3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBhcmd1bWVudHNbMF0udG9wXG4gICAgICAgICAgICA6IGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTEVUIFRIRSBTTU9PVEhORVNTIEJFR0lOIVxuICAgICAgc21vb3RoU2Nyb2xsLmNhbGwoXG4gICAgICAgIHcsXG4gICAgICAgIGQuYm9keSxcbiAgICAgICAgfn5hcmd1bWVudHNbMF0ubGVmdCArICh3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldCksXG4gICAgICAgIH5+YXJndW1lbnRzWzBdLnRvcCArICh3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldClcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbCBhbmQgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsVG9cbiAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgPSBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxUbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgYWN0aW9uIHdoZW4gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWRcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkgPT09IHRydWUpIHtcbiAgICAgICAgLy8gaWYgb25lIG51bWJlciBpcyBwYXNzZWQsIHRocm93IGVycm9yIHRvIG1hdGNoIEZpcmVmb3ggaW1wbGVtZW50YXRpb25cbiAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInICYmIGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdWYWx1ZSBjb3VsZCBub3QgYmUgY29udmVydGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvcmlnaW5hbC5lbGVtZW50U2Nyb2xsLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICAvLyB1c2UgbGVmdCBwcm9wLCBmaXJzdCBudW1iZXIgYXJndW1lbnQgb3IgZmFsbGJhY2sgdG8gc2Nyb2xsTGVmdFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0ubGVmdFxuICAgICAgICAgICAgOiB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnb2JqZWN0JyA/IH5+YXJndW1lbnRzWzBdIDogdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICAgIC8vIHVzZSB0b3AgcHJvcCwgc2Vjb25kIGFyZ3VtZW50IG9yIGZhbGxiYWNrIHRvIHNjcm9sbFRvcFxuICAgICAgICAgIGFyZ3VtZW50c1swXS50b3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS50b3BcbiAgICAgICAgICAgIDogYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyB+fmFyZ3VtZW50c1sxXSA6IHRoaXMuc2Nyb2xsVG9wXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVmdCA9IGFyZ3VtZW50c1swXS5sZWZ0O1xuICAgICAgdmFyIHRvcCA9IGFyZ3VtZW50c1swXS50b3A7XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICB0aGlzLFxuICAgICAgICB0aGlzLFxuICAgICAgICB0eXBlb2YgbGVmdCA9PT0gJ3VuZGVmaW5lZCcgPyB0aGlzLnNjcm9sbExlZnQgOiB+fmxlZnQsXG4gICAgICAgIHR5cGVvZiB0b3AgPT09ICd1bmRlZmluZWQnID8gdGhpcy5zY3JvbGxUb3AgOiB+fnRvcFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsQnlcbiAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxCeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgYWN0aW9uIHdoZW4gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWRcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkgPT09IHRydWUpIHtcbiAgICAgICAgb3JpZ2luYWwuZWxlbWVudFNjcm9sbC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgYXJndW1lbnRzWzBdLmxlZnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS5sZWZ0ICsgdGhpcy5zY3JvbGxMZWZ0XG4gICAgICAgICAgICA6IH5+YXJndW1lbnRzWzBdICsgdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICAgIGFyZ3VtZW50c1swXS50b3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB+fmFyZ3VtZW50c1swXS50b3AgKyB0aGlzLnNjcm9sbFRvcFxuICAgICAgICAgICAgOiB+fmFyZ3VtZW50c1sxXSArIHRoaXMuc2Nyb2xsVG9wXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNjcm9sbCh7XG4gICAgICAgIGxlZnQ6IH5+YXJndW1lbnRzWzBdLmxlZnQgKyB0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgIHRvcDogfn5hcmd1bWVudHNbMF0udG9wICsgdGhpcy5zY3JvbGxUb3AsXG4gICAgICAgIGJlaGF2aW9yOiBhcmd1bWVudHNbMF0uYmVoYXZpb3JcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlld1xuICAgIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEludG9WaWV3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pID09PSB0cnVlKSB7XG4gICAgICAgIG9yaWdpbmFsLnNjcm9sbEludG9WaWV3LmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMF1cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHZhciBzY3JvbGxhYmxlUGFyZW50ID0gZmluZFNjcm9sbGFibGVQYXJlbnQodGhpcyk7XG4gICAgICB2YXIgcGFyZW50UmVjdHMgPSBzY3JvbGxhYmxlUGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGNsaWVudFJlY3RzID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgaWYgKHNjcm9sbGFibGVQYXJlbnQgIT09IGQuYm9keSkge1xuICAgICAgICAvLyByZXZlYWwgZWxlbWVudCBpbnNpZGUgcGFyZW50XG4gICAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudCxcbiAgICAgICAgICBzY3JvbGxhYmxlUGFyZW50LnNjcm9sbExlZnQgKyBjbGllbnRSZWN0cy5sZWZ0IC0gcGFyZW50UmVjdHMubGVmdCxcbiAgICAgICAgICBzY3JvbGxhYmxlUGFyZW50LnNjcm9sbFRvcCArIGNsaWVudFJlY3RzLnRvcCAtIHBhcmVudFJlY3RzLnRvcFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHJldmVhbCBwYXJlbnQgaW4gdmlld3BvcnQgdW5sZXNzIGlzIGZpeGVkXG4gICAgICAgIGlmICh3LmdldENvbXB1dGVkU3R5bGUoc2Nyb2xsYWJsZVBhcmVudCkucG9zaXRpb24gIT09ICdmaXhlZCcpIHtcbiAgICAgICAgICB3LnNjcm9sbEJ5KHtcbiAgICAgICAgICAgIGxlZnQ6IHBhcmVudFJlY3RzLmxlZnQsXG4gICAgICAgICAgICB0b3A6IHBhcmVudFJlY3RzLnRvcCxcbiAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXZlYWwgZWxlbWVudCBpbiB2aWV3cG9ydFxuICAgICAgICB3LnNjcm9sbEJ5KHtcbiAgICAgICAgICBsZWZ0OiBjbGllbnRSZWN0cy5sZWZ0LFxuICAgICAgICAgIHRvcDogY2xpZW50UmVjdHMudG9wLFxuICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGNvbW1vbmpzXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7IHBvbHlmaWxsOiBwb2x5ZmlsbCB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGdsb2JhbFxuICAgIHBvbHlmaWxsKCk7XG4gIH1cblxufSgpKTtcbiIsImltcG9ydCBtZXJnZSBmcm9tICdkZWVwbWVyZ2UnO1xuaW1wb3J0IHsgRXZlbnRlZCB9IGZyb20gJy4vZXZlbnRlZC5qcyc7XG5pbXBvcnQgYXV0b0JpbmQgZnJvbSAnLi91dGlscy9hdXRvLWJpbmQuanMnO1xuaW1wb3J0IHtcbiAgaXNFbGVtZW50LFxuICBpc0hUTUxFbGVtZW50LFxuICBpc0Z1bmN0aW9uLFxuICBpc1VuZGVmaW5lZFxufSBmcm9tICcuL3V0aWxzL3R5cGUtY2hlY2suanMnO1xuaW1wb3J0IHsgYmluZEFkdmFuY2UgfSBmcm9tICcuL3V0aWxzL2JpbmQuanMnO1xuaW1wb3J0IHtcbiAgc2V0dXBUb29sdGlwLFxuICBwYXJzZUF0dGFjaFRvLFxuICBub3JtYWxpemVQcmVmaXgsXG4gIHV1aWRcbn0gZnJvbSAnLi91dGlscy9nZW5lcmFsLmpzJztcbmltcG9ydCBTaGVwaGVyZEVsZW1lbnQgZnJvbSAnLi9jb21wb25lbnRzL3NoZXBoZXJkLWVsZW1lbnQuc3ZlbHRlJztcblxuLy8gUG9seWZpbGxzXG5pbXBvcnQgc21vb3Roc2Nyb2xsIGZyb20gJ3Ntb290aHNjcm9sbC1wb2x5ZmlsbCc7XG5zbW9vdGhzY3JvbGwucG9seWZpbGwoKTtcblxuLyoqXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBzdGVwcyB0byBiZSBhZGRlZCB0byBhIHRvdXIuXG4gKiBAZXh0ZW5kcyB7RXZlbnRlZH1cbiAqL1xuZXhwb3J0IGNsYXNzIFN0ZXAgZXh0ZW5kcyBFdmVudGVkIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN0ZXBcbiAgICogQHBhcmFtIHtUb3VyfSB0b3VyIFRoZSB0b3VyIGZvciB0aGUgc3RlcFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIHN0ZXBcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmFycm93IFdoZXRoZXIgdG8gZGlzcGxheSB0aGUgYXJyb3cgZm9yIHRoZSB0b29sdGlwIG9yIG5vdC4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5hdHRhY2hUbyBUaGUgZWxlbWVudCB0aGUgc3RlcCBzaG91bGQgYmUgYXR0YWNoZWQgdG8gb24gdGhlIHBhZ2UuXG4gICAqIEFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgYGVsZW1lbnRgIGFuZCBgb25gLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBzdGVwID0gbmV3IFN0ZXAodG91ciwge1xuICAgKiAgIGF0dGFjaFRvOiB7IGVsZW1lbnQ6ICcuc29tZSAuc2VsZWN0b3ItcGF0aCcsIG9uOiAnbGVmdCcgfSxcbiAgICogICAuLi5tb3JlT3B0aW9uc1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIElmIHlvdSBkb27igJl0IHNwZWNpZnkgYW4gYGF0dGFjaFRvYCB0aGUgZWxlbWVudCB3aWxsIGFwcGVhciBpbiB0aGUgbWlkZGxlIG9mIHRoZSBzY3JlZW4uIFRoZSBzYW1lIHdpbGwgaGFwcGVuIGlmIHlvdXIgYGF0dGFjaFRvLmVsZW1lbnRgIGNhbGxiYWNrIHJldHVybnMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3IgYSBzZWxlY3RvciB0aGF0IGRvZXMgbm90IGV4aXN0IGluIHRoZSBET00uXG4gICAqIElmIHlvdSBvbWl0IHRoZSBgb25gIHBvcnRpb24gb2YgYGF0dGFjaFRvYCwgdGhlIGVsZW1lbnQgd2lsbCBzdGlsbCBiZSBoaWdobGlnaHRlZCwgYnV0IHRoZSB0b29sdGlwIHdpbGwgYXBwZWFyXG4gICAqIGluIHRoZSBtaWRkbGUgb2YgdGhlIHNjcmVlbiwgd2l0aG91dCBhbiBhcnJvdyBwb2ludGluZyB0byB0aGUgdGFyZ2V0LlxuICAgKiBJZiB0aGUgZWxlbWVudCB0byBoaWdobGlnaHQgZG9lcyBub3QgeWV0IGV4aXN0IHdoaWxlIGluc3RhbnRpYXRpbmcgdG91ciBzdGVwcywgeW91IG1heSB1c2UgbGF6eSBldmFsdWF0aW9uIGJ5IHN1cHBseWluZyBhIGZ1bmN0aW9uIHRvIGBhdHRhY2hUby5lbGVtZW50YC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGluIHRoZSBgYmVmb3JlLXNob3dgIHBoYXNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MRWxlbWVudHxmdW5jdGlvbn0gb3B0aW9ucy5hdHRhY2hUby5lbGVtZW50IEFuIGVsZW1lbnQgc2VsZWN0b3Igc3RyaW5nLCBET00gZWxlbWVudCwgb3IgYSBmdW5jdGlvbiAocmV0dXJuaW5nIGEgc2VsZWN0b3IsIGEgRE9NIGVsZW1lbnQsIGBudWxsYCBvciBgdW5kZWZpbmVkYCkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmF0dGFjaFRvLm9uIFRoZSBvcHRpb25hbCBkaXJlY3Rpb24gdG8gcGxhY2UgdGhlIFBvcHBlciB0b29sdGlwIHJlbGF0aXZlIHRvIHRoZSBlbGVtZW50LlxuICAgKiAgIC0gUG9zc2libGUgc3RyaW5nIHZhbHVlczogJ2F1dG8nLCAnYXV0by1zdGFydCcsICdhdXRvLWVuZCcsICd0b3AnLCAndG9wLXN0YXJ0JywgJ3RvcC1lbmQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdib3R0b20tZW5kJywgJ3JpZ2h0JywgJ3JpZ2h0LXN0YXJ0JywgJ3JpZ2h0LWVuZCcsICdsZWZ0JywgJ2xlZnQtc3RhcnQnLCAnbGVmdC1lbmQnXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmFkdmFuY2VPbiBBbiBhY3Rpb24gb24gdGhlIHBhZ2Ugd2hpY2ggc2hvdWxkIGFkdmFuY2Ugc2hlcGhlcmQgdG8gdGhlIG5leHQgc3RlcC5cbiAgICogSXQgc2hvdWxkIGJlIGFuIG9iamVjdCB3aXRoIGEgc3RyaW5nIGBzZWxlY3RvcmAgYW5kIGFuIGBldmVudGAgbmFtZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBzdGVwID0gbmV3IFN0ZXAodG91ciwge1xuICAgKiAgIGFkdmFuY2VPbjogeyBzZWxlY3RvcjogJy5zb21lIC5zZWxlY3Rvci1wYXRoJywgZXZlbnQ6ICdjbGljaycgfSxcbiAgICogICAuLi5tb3JlT3B0aW9uc1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqIGBldmVudGAgZG9lc27igJl0IGhhdmUgdG8gYmUgYW4gZXZlbnQgaW5zaWRlIHRoZSB0b3VyLCBpdCBjYW4gYmUgYW55IGV2ZW50IGZpcmVkIG9uIGFueSBlbGVtZW50IG9uIHRoZSBwYWdlLlxuICAgKiBZb3UgY2FuIGFsc28gYWx3YXlzIG1hbnVhbGx5IGFkdmFuY2UgdGhlIFRvdXIgYnkgY2FsbGluZyBgbXlUb3VyLm5leHQoKWAuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuYmVmb3JlU2hvd1Byb21pc2UgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBwcm9taXNlLlxuICAgKiBXaGVuIHRoZSBwcm9taXNlIHJlc29sdmVzLCB0aGUgcmVzdCBvZiB0aGUgYHNob3dgIGNvZGUgZm9yIHRoZSBzdGVwIHdpbGwgZXhlY3V0ZS5cbiAgICogQHBhcmFtIHtPYmplY3RbXX0gb3B0aW9ucy5idXR0b25zIEFuIGFycmF5IG9mIGJ1dHRvbnMgdG8gYWRkIHRvIHRoZSBzdGVwLiBUaGVzZSB3aWxsIGJlIHJlbmRlcmVkIGluIGFcbiAgICogZm9vdGVyIGJlbG93IHRoZSBtYWluIGJvZHkgdGV4dC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5idXR0b25zLmJ1dHRvbi5hY3Rpb24gQSBmdW5jdGlvbiBleGVjdXRlZCB3aGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZCBvbi5cbiAgICogSXQgaXMgYXV0b21hdGljYWxseSBib3VuZCB0byB0aGUgYHRvdXJgIHRoZSBzdGVwIGlzIGFzc29jaWF0ZWQgd2l0aCwgc28gdGhpbmdzIGxpa2UgYHRoaXMubmV4dGAgd2lsbFxuICAgKiB3b3JrIGluc2lkZSB0aGUgYWN0aW9uLlxuICAgKiBZb3UgY2FuIHVzZSBhY3Rpb24gdG8gc2tpcCBzdGVwcyBvciBuYXZpZ2F0ZSB0byBzcGVjaWZpYyBzdGVwcywgd2l0aCBzb21ldGhpbmcgbGlrZTpcbiAgICogYGBganNcbiAgICogYWN0aW9uKCkge1xuICAgKiAgIHJldHVybiB0aGlzLnNob3coJ3NvbWVfc3RlcF9uYW1lJyk7XG4gICAqIH1cbiAgICogYGBgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmJ1dHRvbnMuYnV0dG9uLmNsYXNzZXMgRXh0cmEgY2xhc3NlcyB0byBhcHBseSB0byB0aGUgYDxhPmBcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmJ1dHRvbnMuYnV0dG9uLmRpc2FibGVkIFNob3VsZCB0aGUgYnV0dG9uIGJlIGRpc2FibGVkP1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5idXR0b25zLmJ1dHRvbi5sYWJlbCBUaGUgYXJpYS1sYWJlbCB0ZXh0IG9mIHRoZSBidXR0b25cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmJ1dHRvbnMuYnV0dG9uLnNlY29uZGFyeSBJZiB0cnVlLCBhIHNoZXBoZXJkLWJ1dHRvbi1zZWNvbmRhcnkgY2xhc3MgaXMgYXBwbGllZCB0byB0aGUgYnV0dG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmJ1dHRvbnMuYnV0dG9uLnRleHQgVGhlIEhUTUwgdGV4dCBvZiB0aGUgYnV0dG9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5jYW5DbGlja1RhcmdldCBBIGJvb2xlYW4sIHRoYXQgd2hlbiBzZXQgdG8gZmFsc2UsIHdpbGwgc2V0IGBwb2ludGVyLWV2ZW50czogbm9uZWAgb24gdGhlIHRhcmdldFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5jYW5jZWxJY29uIE9wdGlvbnMgZm9yIHRoZSBjYW5jZWwgaWNvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY2FuY2VsSWNvbi5lbmFibGVkIFNob3VsZCBhIGNhbmNlbCDigJzinJXigJ0gYmUgc2hvd24gaW4gdGhlIGhlYWRlciBvZiB0aGUgc3RlcD9cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2FuY2VsSWNvbi5sYWJlbCBUaGUgbGFiZWwgdG8gYWRkIGZvciBgYXJpYS1sYWJlbGBcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2xhc3NlcyBBIHN0cmluZyBvZiBleHRyYSBjbGFzc2VzIHRvIGFkZCB0byB0aGUgc3RlcCdzIGNvbnRlbnQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuaGlnaGxpZ2h0Q2xhc3MgQW4gZXh0cmEgY2xhc3MgdG8gYXBwbHkgdG8gdGhlIGBhdHRhY2hUb2AgZWxlbWVudCB3aGVuIGl0IGlzXG4gICAqIGhpZ2hsaWdodGVkICh0aGF0IGlzLCB3aGVuIGl0cyBzdGVwIGlzIGFjdGl2ZSkuIFlvdSBjYW4gdGhlbiB0YXJnZXQgdGhhdCBzZWxlY3RvciBpbiB5b3VyIENTUy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuaWQgVGhlIHN0cmluZyB0byB1c2UgYXMgdGhlIGBpZGAgZm9yIHRoZSBzdGVwLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5tb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyBBbiBhbW91bnQgb2YgcGFkZGluZyB0byBhZGQgYXJvdW5kIHRoZSBtb2RhbCBvdmVybGF5IG9wZW5pbmdcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubW9kYWxPdmVybGF5T3BlbmluZ1JhZGl1cyBBbiBhbW91bnQgb2YgYm9yZGVyIHJhZGl1cyB0byBhZGQgYXJvdW5kIHRoZSBtb2RhbCBvdmVybGF5IG9wZW5pbmdcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMucG9wcGVyT3B0aW9ucyBFeHRyYSBvcHRpb25zIHRvIHBhc3MgdG8gUG9wcGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IG9wdGlvbnMuc2Nyb2xsVG8gU2hvdWxkIHRoZSBlbGVtZW50IGJlIHNjcm9sbGVkIHRvIHdoZW4gdGhpcyBzdGVwIGlzIHNob3duPyBJZiB0cnVlLCB1c2VzIHRoZSBkZWZhdWx0IGBzY3JvbGxJbnRvVmlld2AsXG4gICAqIGlmIGFuIG9iamVjdCwgcGFzc2VzIHRoYXQgb2JqZWN0IGFzIHRoZSBwYXJhbXMgdG8gYHNjcm9sbEludG9WaWV3YCBpLmUuIGB7YmVoYXZpb3I6ICdzbW9vdGgnLCBibG9jazogJ2NlbnRlcid9YFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLnNjcm9sbFRvSGFuZGxlciBBIGZ1bmN0aW9uIHRoYXQgbGV0cyB5b3Ugb3ZlcnJpZGUgdGhlIGRlZmF1bHQgc2Nyb2xsVG8gYmVoYXZpb3IgYW5kXG4gICAqIGRlZmluZSBhIGN1c3RvbSBhY3Rpb24gdG8gZG8gdGhlIHNjcm9sbGluZywgYW5kIHBvc3NpYmx5IG90aGVyIGxvZ2ljLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLnNob3dPbiBBIGZ1bmN0aW9uIHRoYXQsIHdoZW4gaXQgcmV0dXJucyBgdHJ1ZWAsIHdpbGwgc2hvdyB0aGUgc3RlcC5cbiAgICogSWYgaXQgcmV0dXJucyBmYWxzZSwgdGhlIHN0ZXAgd2lsbCBiZSBza2lwcGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50ZXh0IFRoZSB0ZXh0IGluIHRoZSBib2R5IG9mIHRoZSBzdGVwLiBJdCBjYW4gYmUgb25lIG9mIHRocmVlIHR5cGVzOlxuICAgKiBgYGBcbiAgICogLSBIVE1MIHN0cmluZ1xuICAgKiAtIGBIVE1MRWxlbWVudGAgb2JqZWN0XG4gICAqIC0gYEZ1bmN0aW9uYCB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBzdGVwIGlzIGJ1aWx0LiBJdCBtdXN0IHJldHVybiBvbmUgdGhlIHR3byBvcHRpb25zIGFib3ZlLlxuICAgKiBgYGBcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGl0bGUgVGhlIHN0ZXAncyB0aXRsZS4gSXQgYmVjb21lcyBhbiBgaDNgIGF0IHRoZSB0b3Agb2YgdGhlIHN0ZXAuIEl0IGNhbiBiZSBvbmUgb2YgdHdvIHR5cGVzOlxuICAgKiBgYGBcbiAgICogLSBIVE1MIHN0cmluZ1xuICAgKiAtIGBGdW5jdGlvbmAgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgc3RlcCBpcyBidWlsdC4gSXQgbXVzdCByZXR1cm4gSFRNTCBzdHJpbmcuXG4gICAqIGBgYFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy53aGVuIFlvdSBjYW4gZGVmaW5lIGBzaG93YCwgYGhpZGVgLCBldGMgZXZlbnRzIGluc2lkZSBgd2hlbmAuIEZvciBleGFtcGxlOlxuICAgKiBgYGBqc1xuICAgKiB3aGVuOiB7XG4gICAqICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAqICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAqICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKiBAcmV0dXJuIHtTdGVwfSBUaGUgbmV3bHkgY3JlYXRlZCBTdGVwIGluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0b3VyLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0b3VyLCBvcHRpb25zKTtcbiAgICB0aGlzLnRvdXIgPSB0b3VyO1xuICAgIHRoaXMuY2xhc3NQcmVmaXggPSB0aGlzLnRvdXIub3B0aW9uc1xuICAgICAgPyBub3JtYWxpemVQcmVmaXgodGhpcy50b3VyLm9wdGlvbnMuY2xhc3NQcmVmaXgpXG4gICAgICA6ICcnO1xuICAgIHRoaXMuc3R5bGVzID0gdG91ci5zdHlsZXM7XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlZCBhdHRhY2hUbyBvcHRpb25zLiBEdWUgdG8gbGF6eSBldmFsdWF0aW9uLCB3ZSBvbmx5IHJlc29sdmUgdGhlIG9wdGlvbnMgZHVyaW5nIGBiZWZvcmUtc2hvd2AgcGhhc2UuXG4gICAgICogRG8gbm90IHVzZSB0aGlzIGRpcmVjdGx5LCB1c2UgdGhlIF9nZXRSZXNvbHZlZEF0dGFjaFRvT3B0aW9ucyBtZXRob2QgaW5zdGVhZC5cbiAgICAgKiBAdHlwZSB7bnVsbHx7fXx7ZWxlbWVudCwgdG99fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcmVzb2x2ZWRBdHRhY2hUbyA9IG51bGw7XG5cbiAgICBhdXRvQmluZCh0aGlzKTtcblxuICAgIHRoaXMuX3NldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWwgdGhlIHRvdXJcbiAgICogVHJpZ2dlcnMgdGhlIGBjYW5jZWxgIGV2ZW50XG4gICAqL1xuICBjYW5jZWwoKSB7XG4gICAgdGhpcy50b3VyLmNhbmNlbCgpO1xuICAgIHRoaXMudHJpZ2dlcignY2FuY2VsJyk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGxldGUgdGhlIHRvdXJcbiAgICogVHJpZ2dlcnMgdGhlIGBjb21wbGV0ZWAgZXZlbnRcbiAgICovXG4gIGNvbXBsZXRlKCkge1xuICAgIHRoaXMudG91ci5jb21wbGV0ZSgpO1xuICAgIHRoaXMudHJpZ2dlcignY29tcGxldGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIHN0ZXAsIGRlbGV0ZSB0aGUgc3RlcCdzIGVsZW1lbnQsIGFuZCBkZXN0cm95IHRoZSBQb3BwZXIgaW5zdGFuY2UgZm9yIHRoZSBzdGVwLlxuICAgKiBUcmlnZ2VycyBgZGVzdHJveWAgZXZlbnRcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMudG9vbHRpcCkge1xuICAgICAgdGhpcy50b29sdGlwLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMudG9vbHRpcCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQodGhpcy5lbCkgJiYgdGhpcy5lbC5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbCk7XG4gICAgICB0aGlzLmVsID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVTdGVwVGFyZ2V0T25IaWRlKCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2Rlc3Ryb3knKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0b3VyIGZvciB0aGUgc3RlcFxuICAgKiBAcmV0dXJuIHtUb3VyfSBUaGUgdG91ciBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0VG91cigpIHtcbiAgICByZXR1cm4gdGhpcy50b3VyO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIHN0ZXBcbiAgICovXG4gIGhpZGUoKSB7XG4gICAgdGhpcy50b3VyLm1vZGFsLmhpZGUoKTtcblxuICAgIHRoaXMudHJpZ2dlcignYmVmb3JlLWhpZGUnKTtcblxuICAgIGlmICh0aGlzLmVsKSB7XG4gICAgICB0aGlzLmVsLmhpZGRlbiA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlU3RlcFRhcmdldE9uSGlkZSgpO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdoaWRlJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgYXR0YWNoVG8gb3B0aW9ucy5cbiAgICogQHJldHVybnMge3t9fHtlbGVtZW50LCBvbn19XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzb2x2ZUF0dGFjaFRvT3B0aW9ucygpIHtcbiAgICB0aGlzLl9yZXNvbHZlZEF0dGFjaFRvID0gcGFyc2VBdHRhY2hUbyh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZWRBdHRhY2hUbztcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNlbGVjdG9yIGZvciByZXNvbHZlZCBhdHRhY2hUbyBvcHRpb25zLlxuICAgKiBAcmV0dXJucyB7e318e2VsZW1lbnQsIG9ufX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRSZXNvbHZlZEF0dGFjaFRvT3B0aW9ucygpIHtcbiAgICBpZiAodGhpcy5fcmVzb2x2ZWRBdHRhY2hUbyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVBdHRhY2hUb09wdGlvbnMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZWRBdHRhY2hUbztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgc3RlcCBpcyBvcGVuIGFuZCB2aXNpYmxlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0ZXAgaXMgb3BlbiBhbmQgdmlzaWJsZVxuICAgKi9cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMuZWwgJiYgIXRoaXMuZWwuaGlkZGVuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcyBgX3Nob3dgIGFuZCBlbnN1cmVzIGBiZWZvcmVTaG93UHJvbWlzZWAgcmVzb2x2ZXMgYmVmb3JlIGNhbGxpbmcgc2hvd1xuICAgKiBAcmV0dXJuIHsqfFByb21pc2V9XG4gICAqL1xuICBzaG93KCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5iZWZvcmVTaG93UHJvbWlzZSkpIHtcbiAgICAgIGNvbnN0IGJlZm9yZVNob3dQcm9taXNlID0gdGhpcy5vcHRpb25zLmJlZm9yZVNob3dQcm9taXNlKCk7XG4gICAgICBpZiAoIWlzVW5kZWZpbmVkKGJlZm9yZVNob3dQcm9taXNlKSkge1xuICAgICAgICByZXR1cm4gYmVmb3JlU2hvd1Byb21pc2UudGhlbigoKSA9PiB0aGlzLl9zaG93KCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9zaG93KCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgb3B0aW9ucyBvZiB0aGUgc3RlcC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBzdGVwXG4gICAqL1xuICB1cGRhdGVTdGVwT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHRoaXMuc2hlcGhlcmRFbGVtZW50Q29tcG9uZW50KSB7XG4gICAgICB0aGlzLnNoZXBoZXJkRWxlbWVudENvbXBvbmVudC4kc2V0KHsgc3RlcDogdGhpcyB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZWxlbWVudCBmb3IgdGhlIHN0ZXBcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR8bnVsbHx1bmRlZmluZWR9IFRoZSBlbGVtZW50IGluc3RhbmNlLiB1bmRlZmluZWQgaWYgaXQgaGFzIG5ldmVyIGJlZW4gc2hvd24sIG51bGwgaWYgaXQgaGFzIGJlZW4gZGVzdHJveWVkXG4gICAqL1xuICBnZXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRhcmdldCBmb3IgdGhlIHN0ZXBcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR8bnVsbHx1bmRlZmluZWR9IFRoZSBlbGVtZW50IGluc3RhbmNlLiB1bmRlZmluZWQgaWYgaXQgaGFzIG5ldmVyIGJlZW4gc2hvd24sIG51bGwgaWYgcXVlcnkgc3RyaW5nIGhhcyBub3QgYmVlbiBmb3VuZFxuICAgKi9cbiAgZ2V0VGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLnRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFNoZXBoZXJkIGVsZW1lbnQgZm9yIHN0ZXAgYmFzZWQgb24gb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBUaGUgRE9NIGVsZW1lbnQgZm9yIHRoZSBzdGVwIHRvb2x0aXBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGVUb29sdGlwQ29udGVudCgpIHtcbiAgICBjb25zdCBkZXNjcmlwdGlvbklkID0gYCR7dGhpcy5pZH0tZGVzY3JpcHRpb25gO1xuICAgIGNvbnN0IGxhYmVsSWQgPSBgJHt0aGlzLmlkfS1sYWJlbGA7XG5cbiAgICB0aGlzLnNoZXBoZXJkRWxlbWVudENvbXBvbmVudCA9IG5ldyBTaGVwaGVyZEVsZW1lbnQoe1xuICAgICAgdGFyZ2V0OiB0aGlzLnRvdXIub3B0aW9ucy5zdGVwc0NvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5LFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY2xhc3NQcmVmaXg6IHRoaXMuY2xhc3NQcmVmaXgsXG4gICAgICAgIGRlc2NyaXB0aW9uSWQsXG4gICAgICAgIGxhYmVsSWQsXG4gICAgICAgIHN0ZXA6IHRoaXMsXG4gICAgICAgIHN0eWxlczogdGhpcy5zdHlsZXNcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLnNoZXBoZXJkRWxlbWVudENvbXBvbmVudC5nZXRFbGVtZW50KCk7XG4gIH1cblxuICAvKipcbiAgICogSWYgYSBjdXN0b20gc2Nyb2xsVG9IYW5kbGVyIGlzIGRlZmluZWQsIGNhbGwgdGhhdCwgb3RoZXJ3aXNlIGRvIHRoZSBnZW5lcmljXG4gICAqIHNjcm9sbEludG9WaWV3IGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IHNjcm9sbFRvT3B0aW9ucyBJZiB0cnVlLCB1c2VzIHRoZSBkZWZhdWx0IGBzY3JvbGxJbnRvVmlld2AsXG4gICAqIGlmIGFuIG9iamVjdCwgcGFzc2VzIHRoYXQgb2JqZWN0IGFzIHRoZSBwYXJhbXMgdG8gYHNjcm9sbEludG9WaWV3YCBpLmUuIGB7IGJlaGF2aW9yOiAnc21vb3RoJywgYmxvY2s6ICdjZW50ZXInIH1gXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2Nyb2xsVG8oc2Nyb2xsVG9PcHRpb25zKSB7XG4gICAgY29uc3QgeyBlbGVtZW50IH0gPSB0aGlzLl9nZXRSZXNvbHZlZEF0dGFjaFRvT3B0aW9ucygpO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24odGhpcy5vcHRpb25zLnNjcm9sbFRvSGFuZGxlcikpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5zY3JvbGxUb0hhbmRsZXIoZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGlzRWxlbWVudChlbGVtZW50KSAmJlxuICAgICAgdHlwZW9mIGVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcgPT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIGVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcoc2Nyb2xsVG9PcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogX2dldENsYXNzT3B0aW9ucyBnZXRzIGFsbCBwb3NzaWJsZSBjbGFzc2VzIGZvciB0aGUgc3RlcFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RlcE9wdGlvbnMgVGhlIHN0ZXAgc3BlY2lmaWMgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7U3RyaW5nfSB1bmlxdWUgc3RyaW5nIGZyb20gYXJyYXkgb2YgY2xhc3Nlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldENsYXNzT3B0aW9ucyhzdGVwT3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmF1bHRTdGVwT3B0aW9ucyA9XG4gICAgICB0aGlzLnRvdXIgJiYgdGhpcy50b3VyLm9wdGlvbnMgJiYgdGhpcy50b3VyLm9wdGlvbnMuZGVmYXVsdFN0ZXBPcHRpb25zO1xuICAgIGNvbnN0IHN0ZXBDbGFzc2VzID0gc3RlcE9wdGlvbnMuY2xhc3NlcyA/IHN0ZXBPcHRpb25zLmNsYXNzZXMgOiAnJztcbiAgICBjb25zdCBkZWZhdWx0U3RlcE9wdGlvbnNDbGFzc2VzID1cbiAgICAgIGRlZmF1bHRTdGVwT3B0aW9ucyAmJiBkZWZhdWx0U3RlcE9wdGlvbnMuY2xhc3Nlc1xuICAgICAgICA/IGRlZmF1bHRTdGVwT3B0aW9ucy5jbGFzc2VzXG4gICAgICAgIDogJyc7XG4gICAgY29uc3QgYWxsQ2xhc3NlcyA9IFtcbiAgICAgIC4uLnN0ZXBDbGFzc2VzLnNwbGl0KCcgJyksXG4gICAgICAuLi5kZWZhdWx0U3RlcE9wdGlvbnNDbGFzc2VzLnNwbGl0KCcgJylcbiAgICBdO1xuICAgIGNvbnN0IHVuaXFDbGFzc2VzID0gbmV3IFNldChhbGxDbGFzc2VzKTtcblxuICAgIHJldHVybiBBcnJheS5mcm9tKHVuaXFDbGFzc2VzKS5qb2luKCcgJykudHJpbSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9wdGlvbnMgZm9yIHRoZSBzdGVwLCBtYXBzIGB3aGVuYCB0byBldmVudHMsIHNldHMgdXAgYnV0dG9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIHN0ZXBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRPcHRpb25zKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCB0b3VyT3B0aW9ucyA9XG4gICAgICB0aGlzLnRvdXIgJiYgdGhpcy50b3VyLm9wdGlvbnMgJiYgdGhpcy50b3VyLm9wdGlvbnMuZGVmYXVsdFN0ZXBPcHRpb25zO1xuXG4gICAgdG91ck9wdGlvbnMgPSBtZXJnZSh7fSwgdG91ck9wdGlvbnMgfHwge30pO1xuXG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHtcbiAgICAgICAgYXJyb3c6IHRydWVcbiAgICAgIH0sXG4gICAgICB0b3VyT3B0aW9ucyxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuXG4gICAgY29uc3QgeyB3aGVuIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICB0aGlzLm9wdGlvbnMuY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIHRoaXMuaWQgPSB0aGlzLm9wdGlvbnMuaWQgfHwgYHN0ZXAtJHt1dWlkKCl9YDtcblxuICAgIGlmICh3aGVuKSB7XG4gICAgICBPYmplY3Qua2V5cyh3aGVuKS5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgICAgICB0aGlzLm9uKGV2ZW50LCB3aGVuW2V2ZW50XSwgdGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBlbGVtZW50IGFuZCBzZXQgdXAgdGhlIFBvcHBlciBpbnN0YW5jZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldHVwRWxlbWVudHMoKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLmVsKSkge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5lbCA9IHRoaXMuX2NyZWF0ZVRvb2x0aXBDb250ZW50KCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmFkdmFuY2VPbikge1xuICAgICAgYmluZEFkdmFuY2UodGhpcyk7XG4gICAgfVxuICAgIHNldHVwVG9vbHRpcCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBgYmVmb3JlLXNob3dgLCBnZW5lcmF0ZXMgdGhlIHRvb2x0aXAgRE9NIGNvbnRlbnQsXG4gICAqIHNldHMgdXAgYSBQb3BwZXIgaW5zdGFuY2UgZm9yIHRoZSB0b29sdGlwLCB0aGVuIHRyaWdnZXJzIGBzaG93YC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zaG93KCkge1xuICAgIHRoaXMudHJpZ2dlcignYmVmb3JlLXNob3cnKTtcblxuICAgIC8vIEZvcmNlIHJlc29sdmUgdG8gbWFrZSBzdXJlIHRoZSBvcHRpb25zIGFyZSB1cGRhdGVkIG9uIHN1YnNlcXVlbnQgc2hvd3MuXG4gICAgdGhpcy5fcmVzb2x2ZUF0dGFjaFRvT3B0aW9ucygpO1xuICAgIHRoaXMuX3NldHVwRWxlbWVudHMoKTtcblxuICAgIGlmICghdGhpcy50b3VyLm1vZGFsKSB7XG4gICAgICB0aGlzLnRvdXIuX3NldHVwTW9kYWwoKTtcbiAgICB9XG5cbiAgICB0aGlzLnRvdXIubW9kYWwuc2V0dXBGb3JTdGVwKHRoaXMpO1xuICAgIHRoaXMuX3N0eWxlVGFyZ2V0RWxlbWVudEZvclN0ZXAodGhpcyk7XG4gICAgdGhpcy5lbC5oaWRkZW4gPSBmYWxzZTtcblxuICAgIC8vIHN0YXJ0IHNjcm9sbGluZyB0byB0YXJnZXQgYmVmb3JlIHNob3dpbmcgdGhlIHN0ZXBcbiAgICBpZiAodGhpcy5vcHRpb25zLnNjcm9sbFRvKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsVG8odGhpcy5vcHRpb25zLnNjcm9sbFRvKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuZWwuaGlkZGVuID0gZmFsc2U7XG5cbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQuZ2V0RWxlbWVudCgpO1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0IHx8IGRvY3VtZW50LmJvZHk7XG4gICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoYCR7dGhpcy5jbGFzc1ByZWZpeH1zaGVwaGVyZC1lbmFibGVkYCk7XG4gICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoYCR7dGhpcy5jbGFzc1ByZWZpeH1zaGVwaGVyZC10YXJnZXRgKTtcbiAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ3NoZXBoZXJkLWVuYWJsZWQnKTtcblxuICAgIHRoaXMudHJpZ2dlcignc2hvdycpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vZHVsYXRlcyB0aGUgc3R5bGVzIG9mIHRoZSBwYXNzZWQgc3RlcCdzIHRhcmdldCBlbGVtZW50LCBiYXNlZCBvbiB0aGUgc3RlcCdzIG9wdGlvbnMgYW5kXG4gICAqIHRoZSB0b3VyJ3MgYG1vZGFsYCBvcHRpb24sIHRvIHZpc3VhbGx5IGVtcGhhc2l6ZSB0aGUgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0gc3RlcCBUaGUgc3RlcCBvYmplY3QgdGhhdCBhdHRhY2hlcyB0byB0aGUgZWxlbWVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3N0eWxlVGFyZ2V0RWxlbWVudEZvclN0ZXAoc3RlcCkge1xuICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBzdGVwLnRhcmdldDtcblxuICAgIGlmICghdGFyZ2V0RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzdGVwLm9wdGlvbnMuaGlnaGxpZ2h0Q2xhc3MpIHtcbiAgICAgIHRhcmdldEVsZW1lbnQuY2xhc3NMaXN0LmFkZChzdGVwLm9wdGlvbnMuaGlnaGxpZ2h0Q2xhc3MpO1xuICAgIH1cblxuICAgIHRhcmdldEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnc2hlcGhlcmQtdGFyZ2V0LWNsaWNrLWRpc2FibGVkJyk7XG5cbiAgICBpZiAoc3RlcC5vcHRpb25zLmNhbkNsaWNrVGFyZ2V0ID09PSBmYWxzZSkge1xuICAgICAgdGFyZ2V0RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzaGVwaGVyZC10YXJnZXQtY2xpY2stZGlzYWJsZWQnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBhIHN0ZXAgaXMgaGlkZGVuLCByZW1vdmUgdGhlIGhpZ2hsaWdodENsYXNzIGFuZCAnc2hlcGhlcmQtZW5hYmxlZCdcbiAgICogYW5kICdzaGVwaGVyZC10YXJnZXQnIGNsYXNzZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVTdGVwVGFyZ2V0T25IaWRlKCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0IHx8IGRvY3VtZW50LmJvZHk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmhpZ2hsaWdodENsYXNzKSB7XG4gICAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0Q2xhc3MpO1xuICAgIH1cblxuICAgIHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgJ3NoZXBoZXJkLXRhcmdldC1jbGljay1kaXNhYmxlZCcsXG4gICAgICBgJHt0aGlzLmNsYXNzUHJlZml4fXNoZXBoZXJkLWVuYWJsZWRgLFxuICAgICAgYCR7dGhpcy5jbGFzc1ByZWZpeH1zaGVwaGVyZC10YXJnZXRgXG4gICAgKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDbGVhbnVwIHRoZSBzdGVwcyBhbmQgc2V0IHBvaW50ZXJFdmVudHMgYmFjayB0byAnYXV0bydcbiAqIEBwYXJhbSB0b3VyIFRoZSB0b3VyIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYW51cFN0ZXBzKHRvdXIpIHtcbiAgaWYgKHRvdXIpIHtcbiAgICBjb25zdCB7IHN0ZXBzIH0gPSB0b3VyO1xuXG4gICAgc3RlcHMuZm9yRWFjaCgoc3RlcCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBzdGVwLm9wdGlvbnMgJiZcbiAgICAgICAgc3RlcC5vcHRpb25zLmNhbkNsaWNrVGFyZ2V0ID09PSBmYWxzZSAmJlxuICAgICAgICBzdGVwLm9wdGlvbnMuYXR0YWNoVG9cbiAgICAgICkge1xuICAgICAgICBpZiAoc3RlcC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgIHN0ZXAudGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ3NoZXBoZXJkLXRhcmdldC1jbGljay1kaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKlxuICogR2VuZXJhdGVzIHRoZSBzdmcgcGF0aCBkYXRhIGZvciBhIHJvdW5kZWQgcmVjdGFuZ2xlIG92ZXJsYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBkaW1lbnNpb24gLSBEaW1lbnNpb25zIG9mIHJlY3RhbmdsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoLlxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIE9mZnNldCBmcm9tIHRvcCBsZWZ0IGNvcm5lciBpbiB4IGF4aXMuIGRlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIE9mZnNldCBmcm9tIHRvcCBsZWZ0IGNvcm5lciBpbiB5IGF4aXMuIGRlZmF1bHQgMC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcj0wXSAtIENvcm5lciBSYWRpdXMuIEtlZXAgdGhpcyBzbWFsbGVyIHRoYW4gIGhhbGYgb2Ygd2lkdGggb3IgaGVpZ2h0LlxuICogQHJldHVybnMge3N0cmluZ30gLSBSb3VuZGVkIHJlY3RhbmdsZSBvdmVybGF5IHBhdGggZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VPdmVybGF5UGF0aCh7IHdpZHRoLCBoZWlnaHQsIHggPSAwLCB5ID0gMCwgciA9IDAgfSkge1xuICBjb25zdCB7IGlubmVyV2lkdGg6IHcsIGlubmVySGVpZ2h0OiBoIH0gPSB3aW5kb3c7XG5cbiAgcmV0dXJuIGBNJHt3fSwke2h9XFxcbkgwXFxcblYwXFxcbkgke3d9XFxcblYke2h9XFxcblpcXFxuTSR7eCArIHJ9LCR7eX1cXFxuYSR7cn0sJHtyfSwwLDAsMC0ke3J9LCR7cn1cXFxuViR7aGVpZ2h0ICsgeSAtIHJ9XFxcbmEke3J9LCR7cn0sMCwwLDAsJHtyfSwke3J9XFxcbkgke3dpZHRoICsgeCAtIHJ9XFxcbmEke3J9LCR7cn0sMCwwLDAsJHtyfS0ke3J9XFxcblYke3kgKyByfVxcXG5hJHtyfSwke3J9LDAsMCwwLSR7cn0tJHtyfVxcXG5aYDtcbn1cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IHV1aWQgfSBmcm9tICcuLi91dGlscy9nZW5lcmFsLmpzJztcbiAgaW1wb3J0IHsgbWFrZU92ZXJsYXlQYXRoIH0gZnJvbSAnLi4vdXRpbHMvb3ZlcmxheS1wYXRoLmpzJztcblxuICBleHBvcnQgbGV0IGVsZW1lbnQsIG9wZW5pbmdQcm9wZXJ0aWVzO1xuICBjb25zdCBndWlkID0gdXVpZCgpO1xuICBsZXQgbW9kYWxJc1Zpc2libGUgPSBmYWxzZTtcbiAgbGV0IHJhZklkID0gdW5kZWZpbmVkO1xuICBsZXQgcGF0aERlZmluaXRpb247XG5cbiAgJDogcGF0aERlZmluaXRpb24gPSBtYWtlT3ZlcmxheVBhdGgob3BlbmluZ1Byb3BlcnRpZXMpO1xuXG4gIGNsb3NlTW9kYWxPcGVuaW5nKCk7XG5cbiAgZXhwb3J0IGNvbnN0IGdldEVsZW1lbnQgPSAoKSA9PiBlbGVtZW50O1xuXG4gIGV4cG9ydCBmdW5jdGlvbiBjbG9zZU1vZGFsT3BlbmluZygpIHtcbiAgICBvcGVuaW5nUHJvcGVydGllcyA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICByOiAwXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBtb2RhbCBvdmVybGF5XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gaGlkZSgpIHtcbiAgICBtb2RhbElzVmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgLy8gRW5zdXJlIHdlIGNsZWFudXAgYWxsIGV2ZW50IGxpc3RlbmVycyB3aGVuIHdlIGhpZGUgdGhlIG1vZGFsXG4gICAgX2NsZWFudXBTdGVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VzIHRoZSBib3VuZHMgb2YgdGhlIGVsZW1lbnQgd2Ugd2FudCB0aGUgb3BlbmluZyBvdmVydG9wIG9mIHRvIHNldCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgb3BlbmluZyBhbmQgcG9zaXRpb24gaXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nIEFuIGFtb3VudCBvZiBwYWRkaW5nIHRvIGFkZCBhcm91bmQgdGhlIG1vZGFsIG92ZXJsYXkgb3BlbmluZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gbW9kYWxPdmVybGF5T3BlbmluZ1JhZGl1cyBBbiBhbW91bnQgb2YgYm9yZGVyIHJhZGl1cyB0byBhZGQgYXJvdW5kIHRoZSBtb2RhbCBvdmVybGF5IG9wZW5pbmdcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gc2Nyb2xsUGFyZW50IFRoZSBzY3JvbGxhYmxlIHBhcmVudCBvZiB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0RWxlbWVudCBUaGUgZWxlbWVudCB0aGUgb3BlbmluZyB3aWxsIGV4cG9zZVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHBvc2l0aW9uTW9kYWwoXG4gICAgbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcgPSAwLFxuICAgIG1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXMgPSAwLFxuICAgIHNjcm9sbFBhcmVudCxcbiAgICB0YXJnZXRFbGVtZW50XG4gICkge1xuICAgIGlmICh0YXJnZXRFbGVtZW50KSB7XG4gICAgICBjb25zdCB7IHksIGhlaWdodCB9ID0gX2dldFZpc2libGVIZWlnaHQodGFyZ2V0RWxlbWVudCwgc2Nyb2xsUGFyZW50KTtcbiAgICAgIGNvbnN0IHsgeCwgd2lkdGgsIGxlZnQgfSA9IHRhcmdldEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyBub3QgY29uc2lzdGVudC4gU29tZSBicm93c2VycyB1c2UgeCBhbmQgeSwgd2hpbGUgb3RoZXJzIHVzZSBsZWZ0IGFuZCB0b3BcbiAgICAgIG9wZW5pbmdQcm9wZXJ0aWVzID0ge1xuICAgICAgICB3aWR0aDogd2lkdGggKyBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyAqIDIsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcgKiAyLFxuICAgICAgICB4OiAoeCB8fCBsZWZ0KSAtIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nLFxuICAgICAgICB5OiB5IC0gbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcsXG4gICAgICAgIHI6IG1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXNcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb3NlTW9kYWxPcGVuaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElmIG1vZGFsIGlzIGVuYWJsZWQsIHNldHVwIHRoZSBzdmcgbWFzayBvcGVuaW5nIGFuZCBtb2RhbCBvdmVybGF5IGZvciB0aGUgc3RlcFxuICAgKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBzZXR1cEZvclN0ZXAoc3RlcCkge1xuICAgIC8vIEVuc3VyZSB3ZSBtb3ZlIGxpc3RlbmVycyBmcm9tIHRoZSBwcmV2aW91cyBzdGVwLCBiZWZvcmUgd2Ugc2V0dXAgbmV3IG9uZXNcbiAgICBfY2xlYW51cFN0ZXBFdmVudExpc3RlbmVycygpO1xuXG4gICAgaWYgKHN0ZXAudG91ci5vcHRpb25zLnVzZU1vZGFsT3ZlcmxheSkge1xuICAgICAgX3N0eWxlRm9yU3RlcChzdGVwKTtcbiAgICAgIHNob3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93IHRoZSBtb2RhbCBvdmVybGF5XG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gc2hvdygpIHtcbiAgICBtb2RhbElzVmlzaWJsZSA9IHRydWU7XG4gIH1cblxuICBjb25zdCBfcHJldmVudE1vZGFsQm9keVRvdWNoID0gKGUpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgY29uc3QgX3ByZXZlbnRNb2RhbE92ZXJsYXlUb3VjaCA9IChlKSA9PiB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkIHRvdWNobW92ZSBldmVudCBsaXN0ZW5lclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2FkZFN0ZXBFdmVudExpc3RlbmVycygpIHtcbiAgICAvLyBQcmV2ZW50cyB3aW5kb3cgZnJvbSBtb3Zpbmcgb24gdG91Y2guXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF9wcmV2ZW50TW9kYWxCb2R5VG91Y2gsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbG9vcCBhbmQgcmVtb3ZlIHRvdWNobW92ZSBldmVudCBsaXN0ZW5lcnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9jbGVhbnVwU3RlcEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmIChyYWZJZCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xuICAgICAgcmFmSWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIF9wcmV2ZW50TW9kYWxCb2R5VG91Y2gsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3R5bGUgdGhlIG1vZGFsIGZvciB0aGUgc3RlcFxuICAgKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgdG8gc3R5bGUgdGhlIG9wZW5pbmcgZm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfc3R5bGVGb3JTdGVwKHN0ZXApIHtcbiAgICBjb25zdCB7XG4gICAgICBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyxcbiAgICAgIG1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXNcbiAgICB9ID0gc3RlcC5vcHRpb25zO1xuXG4gICAgY29uc3Qgc2Nyb2xsUGFyZW50ID0gX2dldFNjcm9sbFBhcmVudChzdGVwLnRhcmdldCk7XG5cbiAgICAvLyBTZXR1cCByZWN1cnNpdmUgZnVuY3Rpb24gdG8gY2FsbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdG8gdXBkYXRlIHRoZSBtb2RhbCBvcGVuaW5nIHBvc2l0aW9uXG4gICAgY29uc3QgcmFmTG9vcCA9ICgpID0+IHtcbiAgICAgIHJhZklkID0gdW5kZWZpbmVkO1xuICAgICAgcG9zaXRpb25Nb2RhbChcbiAgICAgICAgbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcsXG4gICAgICAgIG1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXMsXG4gICAgICAgIHNjcm9sbFBhcmVudCxcbiAgICAgICAgc3RlcC50YXJnZXRcbiAgICAgICk7XG4gICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZMb29wKTtcbiAgICB9O1xuXG4gICAgcmFmTG9vcCgpO1xuXG4gICAgX2FkZFN0ZXBFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIGNsb3Nlc3Qgc2Nyb2xsYWJsZSBwYXJlbnQgZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSB0YXJnZXQgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGlzSHRtbEVsZW1lbnQgPSBlbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgY29uc3Qgb3ZlcmZsb3dZID1cbiAgICAgIGlzSHRtbEVsZW1lbnQgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkub3ZlcmZsb3dZO1xuICAgIGNvbnN0IGlzU2Nyb2xsYWJsZSA9IG92ZXJmbG93WSAhPT0gJ2hpZGRlbicgJiYgb3ZlcmZsb3dZICE9PSAndmlzaWJsZSc7XG5cbiAgICBpZiAoaXNTY3JvbGxhYmxlICYmIGVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID49IGVsZW1lbnQuY2xpZW50SGVpZ2h0KSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gX2dldFNjcm9sbFBhcmVudChlbGVtZW50LnBhcmVudEVsZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdmlzaWJsZSBoZWlnaHQgb2YgdGhlIHRhcmdldCBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBzY3JvbGxQYXJlbnQuXG4gICAqIElmIHRoZXJlIGlzIG5vIHNjcm9sbCBwYXJlbnQsIHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIHRhcmdldCBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtzY3JvbGxQYXJlbnRdIFRoZSBzY3JvbGxhYmxlIHBhcmVudCBlbGVtZW50XG4gICAqIEByZXR1cm5zIHt7eTogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfZ2V0VmlzaWJsZUhlaWdodChlbGVtZW50LCBzY3JvbGxQYXJlbnQpIHtcbiAgICBjb25zdCBlbGVtZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHRvcCA9IGVsZW1lbnRSZWN0LnkgfHwgZWxlbWVudFJlY3QudG9wO1xuICAgIGxldCBib3R0b20gPSBlbGVtZW50UmVjdC5ib3R0b20gfHwgdG9wICsgZWxlbWVudFJlY3QuaGVpZ2h0O1xuXG4gICAgaWYgKHNjcm9sbFBhcmVudCkge1xuICAgICAgY29uc3Qgc2Nyb2xsUmVjdCA9IHNjcm9sbFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IHNjcm9sbFJlY3QueSB8fCBzY3JvbGxSZWN0LnRvcDtcbiAgICAgIGNvbnN0IHNjcm9sbEJvdHRvbSA9IHNjcm9sbFJlY3QuYm90dG9tIHx8IHNjcm9sbFRvcCArIHNjcm9sbFJlY3QuaGVpZ2h0O1xuXG4gICAgICB0b3AgPSBNYXRoLm1heCh0b3AsIHNjcm9sbFRvcCk7XG4gICAgICBib3R0b20gPSBNYXRoLm1pbihib3R0b20sIHNjcm9sbEJvdHRvbSk7XG4gICAgfVxuXG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgoYm90dG9tIC0gdG9wLCAwKTsgLy8gRGVmYXVsdCB0byAwIGlmIGhlaWdodCBpcyBuZWdhdGl2ZVxuXG4gICAgcmV0dXJuIHsgeTogdG9wLCBoZWlnaHQgfTtcbiAgfVxuPC9zY3JpcHQ+XG5cbjxzdmdcbiAgYmluZDp0aGlzPXtlbGVtZW50fVxuICBjbGFzcz17YCR7XG4gICAgbW9kYWxJc1Zpc2libGUgPyAnc2hlcGhlcmQtbW9kYWwtaXMtdmlzaWJsZScgOiAnJ1xuICB9IHNoZXBoZXJkLW1vZGFsLW92ZXJsYXktY29udGFpbmVyYH1cbiAgb246dG91Y2htb3ZlPXtfcHJldmVudE1vZGFsT3ZlcmxheVRvdWNofVxuPlxuICA8cGF0aCBkPXtwYXRoRGVmaW5pdGlvbn0gLz5cbjwvc3ZnPlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtbW9kYWwtb3ZlcmxheS1jb250YWluZXIge1xuICAgIGhlaWdodDogMDtcbiAgICBsZWZ0OiAwO1xuICAgIG9wYWNpdHk6IDA7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiAwO1xuICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2Utb3V0LCBoZWlnaHQgMG1zIDAuM3MsIG9wYWNpdHkgMC4zcyAwbXM7XG4gICAgd2lkdGg6IDEwMHZ3O1xuICAgIHotaW5kZXg6IDk5OTc7XG4gIH1cblxuICAuc2hlcGhlcmQtbW9kYWwtb3ZlcmxheS1jb250YWluZXIuc2hlcGhlcmQtbW9kYWwtaXMtdmlzaWJsZSB7XG4gICAgaGVpZ2h0OiAxMDB2aDtcbiAgICBvcGFjaXR5OiAwLjU7XG4gICAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZS1vdXQsIGhlaWdodCAwcyAwcywgb3BhY2l0eSAwLjNzIDBzO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWigwKTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1tb2RhbC1vdmVybGF5LWNvbnRhaW5lci5zaGVwaGVyZC1tb2RhbC1pcy12aXNpYmxlIHBhdGgge1xuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XG4gIH1cbjwvc3R5bGU+XG4iLCJpbXBvcnQgeyBFdmVudGVkIH0gZnJvbSAnLi9ldmVudGVkLmpzJztcbmltcG9ydCB7IFN0ZXAgfSBmcm9tICcuL3N0ZXAuanMnO1xuaW1wb3J0IGF1dG9CaW5kIGZyb20gJy4vdXRpbHMvYXV0by1iaW5kLmpzJztcbmltcG9ydCB7XG4gIGlzSFRNTEVsZW1lbnQsXG4gIGlzRnVuY3Rpb24sXG4gIGlzU3RyaW5nLFxuICBpc1VuZGVmaW5lZFxufSBmcm9tICcuL3V0aWxzL3R5cGUtY2hlY2suanMnO1xuaW1wb3J0IHsgY2xlYW51cFN0ZXBzIH0gZnJvbSAnLi91dGlscy9jbGVhbnVwLmpzJztcbmltcG9ydCB7IG5vcm1hbGl6ZVByZWZpeCwgdXVpZCB9IGZyb20gJy4vdXRpbHMvZ2VuZXJhbC5qcyc7XG5pbXBvcnQgU2hlcGhlcmRNb2RhbCBmcm9tICcuL2NvbXBvbmVudHMvc2hlcGhlcmQtbW9kYWwuc3ZlbHRlJztcblxuY29uc3QgU2hlcGhlcmQgPSBuZXcgRXZlbnRlZCgpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyB0aGUgc2l0ZSB0b3VyXG4gKiBAZXh0ZW5kcyB7RXZlbnRlZH1cbiAqL1xuZXhwb3J0IGNsYXNzIFRvdXIgZXh0ZW5kcyBFdmVudGVkIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgdG91clxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY29uZmlybUNhbmNlbCBJZiB0cnVlLCB3aWxsIGlzc3VlIGEgYHdpbmRvdy5jb25maXJtYCBiZWZvcmUgY2FuY2VsbGluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jb25maXJtQ2FuY2VsTWVzc2FnZSBUaGUgbWVzc2FnZSB0byBkaXNwbGF5IGluIHRoZSBjb25maXJtIGRpYWxvZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jbGFzc1ByZWZpeCBUaGUgcHJlZml4IHRvIGFkZCB0byB0aGUgYHNoZXBoZXJkLWVuYWJsZWRgIGFuZCBgc2hlcGhlcmQtdGFyZ2V0YCBjbGFzcyBuYW1lcyBhcyB3ZWxsIGFzIHRoZSBgZGF0YS1zaGVwaGVyZC1zdGVwLWlkYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZGVmYXVsdFN0ZXBPcHRpb25zIERlZmF1bHQgb3B0aW9ucyBmb3IgU3RlcHMgKHtAbGluayBTdGVwI2NvbnN0cnVjdG9yfSksIGNyZWF0ZWQgdGhyb3VnaCBgYWRkU3RlcGBcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmV4aXRPbkVzYyBFeGl0aW5nIHRoZSB0b3VyIHdpdGggdGhlIGVzY2FwZSBrZXkgd2lsbCBiZSBlbmFibGVkIHVubGVzcyB0aGlzIGlzIGV4cGxpY2l0bHlcbiAgICogc2V0IHRvIGZhbHNlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMua2V5Ym9hcmROYXZpZ2F0aW9uIE5hdmlnYXRpbmcgdGhlIHRvdXIgdmlhIGxlZnQgYW5kIHJpZ2h0IGFycm93IGtleXMgd2lsbCBiZSBlbmFibGVkXG4gICAqIHVubGVzcyB0aGlzIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGZhbHNlLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvcHRpb25zLnN0ZXBzQ29udGFpbmVyIEFuIG9wdGlvbmFsIGNvbnRhaW5lciBlbGVtZW50IGZvciB0aGUgc3RlcHMuXG4gICAqIElmIG5vdCBzZXQsIHRoZSBzdGVwcyB3aWxsIGJlIGFwcGVuZGVkIHRvIGBkb2N1bWVudC5ib2R5YC5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb3B0aW9ucy5tb2RhbENvbnRhaW5lciBBbiBvcHRpb25hbCBjb250YWluZXIgZWxlbWVudCBmb3IgdGhlIG1vZGFsLlxuICAgKiBJZiBub3Qgc2V0LCB0aGUgbW9kYWwgd2lsbCBiZSBhcHBlbmRlZCB0byBgZG9jdW1lbnQuYm9keWAuXG4gICAqIEBwYXJhbSB7b2JqZWN0W10gfCBTdGVwW119IG9wdGlvbnMuc3RlcHMgQW4gYXJyYXkgb2Ygc3RlcCBvcHRpb25zIG9iamVjdHMgb3IgU3RlcCBpbnN0YW5jZXMgdG8gaW5pdGlhbGl6ZSB0aGUgdG91ciB3aXRoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRvdXJOYW1lIEFuIG9wdGlvbmFsIFwibmFtZVwiIGZvciB0aGUgdG91ci4gVGhpcyB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSB0aGUgdG91cidzXG4gICAqIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBgaWRgIHByb3BlcnR5IC0tIHdoaWNoIGlzIGFsc28gc2V0IG9uIHRoZSBgYm9keWAgZWxlbWVudCBhcyB0aGUgYGRhdGEtc2hlcGhlcmQtYWN0aXZlLXRvdXJgIGF0dHJpYnV0ZVxuICAgKiB3aGVuZXZlciB0aGUgdG91ciBiZWNvbWVzIGFjdGl2ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLnVzZU1vZGFsT3ZlcmxheSBXaGV0aGVyIG9yIG5vdCBzdGVwcyBzaG91bGQgYmUgcGxhY2VkIGFib3ZlIGEgZGFya2VuZWRcbiAgICogbW9kYWwgb3ZlcmxheS4gSWYgdHJ1ZSwgdGhlIG92ZXJsYXkgd2lsbCBjcmVhdGUgYW4gb3BlbmluZyBhcm91bmQgdGhlIHRhcmdldCBlbGVtZW50IHNvIHRoYXQgaXRcbiAgICogY2FuIHJlbWFpbiBpbnRlcmFjdGl2ZVxuICAgKiBAcmV0dXJucyB7VG91cn1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgYXV0b0JpbmQodGhpcyk7XG5cbiAgICBjb25zdCBkZWZhdWx0VG91ck9wdGlvbnMgPSB7XG4gICAgICBleGl0T25Fc2M6IHRydWUsXG4gICAgICBrZXlib2FyZE5hdmlnYXRpb246IHRydWVcbiAgICB9O1xuXG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFRvdXJPcHRpb25zLCBvcHRpb25zKTtcbiAgICB0aGlzLmNsYXNzUHJlZml4ID0gbm9ybWFsaXplUHJlZml4KHRoaXMub3B0aW9ucy5jbGFzc1ByZWZpeCk7XG4gICAgdGhpcy5zdGVwcyA9IFtdO1xuICAgIHRoaXMuYWRkU3RlcHModGhpcy5vcHRpb25zLnN0ZXBzKTtcblxuICAgIC8vIFBhc3MgdGhlc2UgZXZlbnRzIG9udG8gdGhlIGdsb2JhbCBTaGVwaGVyZCBvYmplY3RcbiAgICBjb25zdCBldmVudHMgPSBbXG4gICAgICAnYWN0aXZlJyxcbiAgICAgICdjYW5jZWwnLFxuICAgICAgJ2NvbXBsZXRlJyxcbiAgICAgICdpbmFjdGl2ZScsXG4gICAgICAnc2hvdycsXG4gICAgICAnc3RhcnQnXG4gICAgXTtcbiAgICBldmVudHMubWFwKChldmVudCkgPT4ge1xuICAgICAgKChlKSA9PiB7XG4gICAgICAgIHRoaXMub24oZSwgKG9wdHMpID0+IHtcbiAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgICBvcHRzLnRvdXIgPSB0aGlzO1xuICAgICAgICAgIFNoZXBoZXJkLnRyaWdnZXIoZSwgb3B0cyk7XG4gICAgICAgIH0pO1xuICAgICAgfSkoZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fc2V0VG91cklEKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IHN0ZXAgdG8gdGhlIHRvdXJcbiAgICogQHBhcmFtIHtPYmplY3R8U3RlcH0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyBzdGVwIG9wdGlvbnMgb3IgYSBTdGVwIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgb3B0aW9uYWwgaW5kZXggdG8gaW5zZXJ0IHRoZSBzdGVwIGF0LiBJZiB1bmRlZmluZWQsIHRoZSBzdGVwXG4gICAqIGlzIGFkZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgKiBAcmV0dXJuIHtTdGVwfSBUaGUgbmV3bHkgYWRkZWQgc3RlcFxuICAgKi9cbiAgYWRkU3RlcChvcHRpb25zLCBpbmRleCkge1xuICAgIGxldCBzdGVwID0gb3B0aW9ucztcblxuICAgIGlmICghKHN0ZXAgaW5zdGFuY2VvZiBTdGVwKSkge1xuICAgICAgc3RlcCA9IG5ldyBTdGVwKHRoaXMsIHN0ZXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGVwLnRvdXIgPSB0aGlzO1xuICAgIH1cblxuICAgIGlmICghaXNVbmRlZmluZWQoaW5kZXgpKSB7XG4gICAgICB0aGlzLnN0ZXBzLnNwbGljZShpbmRleCwgMCwgc3RlcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RlcHMucHVzaChzdGVwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RlcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbXVsdGlwbGUgc3RlcHMgdG8gdGhlIHRvdXJcbiAgICogQHBhcmFtIHtBcnJheTxvYmplY3Q+IHwgQXJyYXk8U3RlcD59IHN0ZXBzIFRoZSBzdGVwcyB0byBhZGQgdG8gdGhlIHRvdXJcbiAgICovXG4gIGFkZFN0ZXBzKHN0ZXBzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3RlcHMpKSB7XG4gICAgICBzdGVwcy5mb3JFYWNoKChzdGVwKSA9PiB7XG4gICAgICAgIHRoaXMuYWRkU3RlcChzdGVwKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdvIHRvIHRoZSBwcmV2aW91cyBzdGVwIGluIHRoZSB0b3VyXG4gICAqL1xuICBiYWNrKCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zdGVwcy5pbmRleE9mKHRoaXMuY3VycmVudFN0ZXApO1xuICAgIHRoaXMuc2hvdyhpbmRleCAtIDEsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBfZG9uZSgpIHRyaWdnZXJpbmcgdGhlICdjYW5jZWwnIGV2ZW50XG4gICAqIElmIGBjb25maXJtQ2FuY2VsYCBpcyB0cnVlLCB3aWxsIHNob3cgYSB3aW5kb3cuY29uZmlybSBiZWZvcmUgY2FuY2VsbGluZ1xuICAgKi9cbiAgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29uZmlybUNhbmNlbCkge1xuICAgICAgY29uc3QgY2FuY2VsTWVzc2FnZSA9XG4gICAgICAgIHRoaXMub3B0aW9ucy5jb25maXJtQ2FuY2VsTWVzc2FnZSB8fFxuICAgICAgICAnQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIHN0b3AgdGhlIHRvdXI/JztcbiAgICAgIGNvbnN0IHN0b3BUb3VyID0gd2luZG93LmNvbmZpcm0oY2FuY2VsTWVzc2FnZSk7XG4gICAgICBpZiAoc3RvcFRvdXIpIHtcbiAgICAgICAgdGhpcy5fZG9uZSgnY2FuY2VsJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RvbmUoJ2NhbmNlbCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBfZG9uZSgpIHRyaWdnZXJpbmcgdGhlIGBjb21wbGV0ZWAgZXZlbnRcbiAgICovXG4gIGNvbXBsZXRlKCkge1xuICAgIHRoaXMuX2RvbmUoJ2NvbXBsZXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc3RlcCBmcm9tIGEgZ2l2ZW4gaWRcbiAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBpZCBUaGUgaWQgb2YgdGhlIHN0ZXAgdG8gcmV0cmlldmVcbiAgICogQHJldHVybiB7U3RlcH0gVGhlIHN0ZXAgY29ycmVzcG9uZGluZyB0byB0aGUgYGlkYFxuICAgKi9cbiAgZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiB0aGlzLnN0ZXBzLmZpbmQoKHN0ZXApID0+IHtcbiAgICAgIHJldHVybiBzdGVwLmlkID09PSBpZDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0ZXBcbiAgICogQHJldHVybnMge1N0ZXB8bnVsbH1cbiAgICovXG4gIGdldEN1cnJlbnRTdGVwKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTdGVwO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZGUgdGhlIGN1cnJlbnQgc3RlcFxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICBjb25zdCBjdXJyZW50U3RlcCA9IHRoaXMuZ2V0Q3VycmVudFN0ZXAoKTtcblxuICAgIGlmIChjdXJyZW50U3RlcCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRTdGVwLmhpZGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHRvdXIgaXMgYWN0aXZlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gU2hlcGhlcmQuYWN0aXZlVG91ciA9PT0gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHbyB0byB0aGUgbmV4dCBzdGVwIGluIHRoZSB0b3VyXG4gICAqIElmIHdlIGFyZSBhdCB0aGUgZW5kLCBjYWxsIGBjb21wbGV0ZWBcbiAgICovXG4gIG5leHQoKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnN0ZXBzLmluZGV4T2YodGhpcy5jdXJyZW50U3RlcCk7XG5cbiAgICBpZiAoaW5kZXggPT09IHRoaXMuc3RlcHMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3coaW5kZXggKyAxLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgc3RlcCBmcm9tIHRoZSB0b3VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBpZCBmb3IgdGhlIHN0ZXAgdG8gcmVtb3ZlXG4gICAqL1xuICByZW1vdmVTdGVwKG5hbWUpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5nZXRDdXJyZW50U3RlcCgpO1xuXG4gICAgLy8gRmluZCB0aGUgc3RlcCwgZGVzdHJveSBpdCBhbmQgcmVtb3ZlIGl0IGZyb20gdGhpcy5zdGVwc1xuICAgIHRoaXMuc3RlcHMuc29tZSgoc3RlcCwgaSkgPT4ge1xuICAgICAgaWYgKHN0ZXAuaWQgPT09IG5hbWUpIHtcbiAgICAgICAgaWYgKHN0ZXAuaXNPcGVuKCkpIHtcbiAgICAgICAgICBzdGVwLmhpZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ZXAuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnN0ZXBzLnNwbGljZShpLCAxKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuaWQgPT09IG5hbWUpIHtcbiAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgc3RlcHMgbGVmdCwgc2hvdyB0aGUgZmlyc3Qgb25lLCBvdGhlcndpc2UganVzdCBjYW5jZWwgdGhlIHRvdXJcbiAgICAgIHRoaXMuc3RlcHMubGVuZ3RoID8gdGhpcy5zaG93KDApIDogdGhpcy5jYW5jZWwoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2hvdyBhIHNwZWNpZmljIHN0ZXAgaW4gdGhlIHRvdXJcbiAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBrZXkgVGhlIGtleSB0byBsb29rIHVwIHRoZSBzdGVwIGJ5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yd2FyZCBUcnVlIGlmIHdlIGFyZSBnb2luZyBmb3J3YXJkLCBmYWxzZSBpZiBiYWNrd2FyZFxuICAgKi9cbiAgc2hvdyhrZXkgPSAwLCBmb3J3YXJkID0gdHJ1ZSkge1xuICAgIGNvbnN0IHN0ZXAgPSBpc1N0cmluZyhrZXkpID8gdGhpcy5nZXRCeUlkKGtleSkgOiB0aGlzLnN0ZXBzW2tleV07XG5cbiAgICBpZiAoc3RlcCkge1xuICAgICAgdGhpcy5fdXBkYXRlU3RhdGVCZWZvcmVTaG93KCk7XG5cbiAgICAgIGNvbnN0IHNob3VsZFNraXBTdGVwID1cbiAgICAgICAgaXNGdW5jdGlvbihzdGVwLm9wdGlvbnMuc2hvd09uKSAmJiAhc3RlcC5vcHRpb25zLnNob3dPbigpO1xuXG4gICAgICAvLyBJZiBgc2hvd09uYCByZXR1cm5zIGZhbHNlLCB3ZSB3YW50IHRvIHNraXAgdGhlIHN0ZXAsIG90aGVyd2lzZSwgc2hvdyB0aGUgc3RlcCBsaWtlIG5vcm1hbFxuICAgICAgaWYgKHNob3VsZFNraXBTdGVwKSB7XG4gICAgICAgIHRoaXMuX3NraXBTdGVwKHN0ZXAsIGZvcndhcmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdzaG93Jywge1xuICAgICAgICAgIHN0ZXAsXG4gICAgICAgICAgcHJldmlvdXM6IHRoaXMuY3VycmVudFN0ZXBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50U3RlcCA9IHN0ZXA7XG4gICAgICAgIHN0ZXAuc2hvdygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCB0aGUgdG91clxuICAgKi9cbiAgc3RhcnQoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdzdGFydCcpO1xuXG4gICAgLy8gU2F2ZSB0aGUgZm9jdXNlZCBlbGVtZW50IGJlZm9yZSB0aGUgdG91ciBvcGVuc1xuICAgIHRoaXMuZm9jdXNlZEVsQmVmb3JlT3BlbiA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICB0aGlzLmN1cnJlbnRTdGVwID0gbnVsbDtcblxuICAgIHRoaXMuX3NldHVwTW9kYWwoKTtcblxuICAgIHRoaXMuX3NldHVwQWN0aXZlVG91cigpO1xuICAgIHRoaXMubmV4dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuZXZlciB0aGUgdG91ciBpcyBjYW5jZWxsZWQgb3IgY29tcGxldGVkLCBiYXNpY2FsbHkgYW55dGltZSB3ZSBleGl0IHRoZSB0b3VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgZXZlbnQgbmFtZSB0byB0cmlnZ2VyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZG9uZShldmVudCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zdGVwcy5pbmRleE9mKHRoaXMuY3VycmVudFN0ZXApO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuc3RlcHMpKSB7XG4gICAgICB0aGlzLnN0ZXBzLmZvckVhY2goKHN0ZXApID0+IHN0ZXAuZGVzdHJveSgpKTtcbiAgICB9XG5cbiAgICBjbGVhbnVwU3RlcHModGhpcyk7XG5cbiAgICB0aGlzLnRyaWdnZXIoZXZlbnQsIHsgaW5kZXggfSk7XG5cbiAgICBTaGVwaGVyZC5hY3RpdmVUb3VyID0gbnVsbDtcbiAgICB0aGlzLnRyaWdnZXIoJ2luYWN0aXZlJywgeyB0b3VyOiB0aGlzIH0pO1xuXG4gICAgaWYgKHRoaXMubW9kYWwpIHtcbiAgICAgIHRoaXMubW9kYWwuaGlkZSgpO1xuICAgIH1cblxuICAgIGlmIChldmVudCA9PT0gJ2NhbmNlbCcgfHwgZXZlbnQgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIGlmICh0aGlzLm1vZGFsKSB7XG4gICAgICAgIGNvbnN0IG1vZGFsQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAnLnNoZXBoZXJkLW1vZGFsLW92ZXJsYXktY29udGFpbmVyJ1xuICAgICAgICApO1xuXG4gICAgICAgIGlmIChtb2RhbENvbnRhaW5lcikge1xuICAgICAgICAgIG1vZGFsQ29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9jdXMgdGhlIGVsZW1lbnQgdGhhdCB3YXMgZm9jdXNlZCBiZWZvcmUgdGhlIHRvdXIgc3RhcnRlZFxuICAgIGlmIChpc0hUTUxFbGVtZW50KHRoaXMuZm9jdXNlZEVsQmVmb3JlT3BlbikpIHtcbiAgICAgIHRoaXMuZm9jdXNlZEVsQmVmb3JlT3Blbi5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIHRoaXMgdG91ciBcImFjdGl2ZVwiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBBY3RpdmVUb3VyKCkge1xuICAgIHRoaXMudHJpZ2dlcignYWN0aXZlJywgeyB0b3VyOiB0aGlzIH0pO1xuXG4gICAgU2hlcGhlcmQuYWN0aXZlVG91ciA9IHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogX3NldHVwTW9kYWwgY3JlYXRlIHRoZSBtb2RhbCBjb250YWluZXIgYW5kIGluc3RhbmNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0dXBNb2RhbCgpIHtcbiAgICB0aGlzLm1vZGFsID0gbmV3IFNoZXBoZXJkTW9kYWwoe1xuICAgICAgdGFyZ2V0OiB0aGlzLm9wdGlvbnMubW9kYWxDb250YWluZXIgfHwgZG9jdW1lbnQuYm9keSxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNsYXNzUHJlZml4OiB0aGlzLmNsYXNzUHJlZml4LFxuICAgICAgICBzdHlsZXM6IHRoaXMuc3R5bGVzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYHNob3dPbmAgZXZhbHVhdGVzIHRvIGZhbHNlLCB0byBza2lwIHRoZSBzdGVwIG9yIGNvbXBsZXRlIHRoZSB0b3VyIGlmIGl0J3MgdGhlIGxhc3Qgc3RlcFxuICAgKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgdG8gc2tpcFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcndhcmQgVHJ1ZSBpZiB3ZSBhcmUgZ29pbmcgZm9yd2FyZCwgZmFsc2UgaWYgYmFja3dhcmRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9za2lwU3RlcChzdGVwLCBmb3J3YXJkKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnN0ZXBzLmluZGV4T2Yoc3RlcCk7XG5cbiAgICBpZiAoaW5kZXggPT09IHRoaXMuc3RlcHMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuZXh0SW5kZXggPSBmb3J3YXJkID8gaW5kZXggKyAxIDogaW5kZXggLSAxO1xuICAgICAgdGhpcy5zaG93KG5leHRJbmRleCwgZm9yd2FyZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJlZm9yZSBzaG93aW5nLCBoaWRlIHRoZSBjdXJyZW50IHN0ZXAgYW5kIGlmIHRoZSB0b3VyIGlzIG5vdFxuICAgKiBhbHJlYWR5IGFjdGl2ZSwgY2FsbCBgdGhpcy5fc2V0dXBBY3RpdmVUb3VyYC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVTdGF0ZUJlZm9yZVNob3coKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudFN0ZXApIHtcbiAgICAgIHRoaXMuY3VycmVudFN0ZXAuaGlkZSgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICB0aGlzLl9zZXR1cEFjdGl2ZVRvdXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzLmlkIHRvIGAke3RvdXJOYW1lfS0tJHt1dWlkfWBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRUb3VySUQoKSB7XG4gICAgY29uc3QgdG91ck5hbWUgPSB0aGlzLm9wdGlvbnMudG91ck5hbWUgfHwgJ3RvdXInO1xuXG4gICAgdGhpcy5pZCA9IGAke3RvdXJOYW1lfS0tJHt1dWlkKCl9YDtcbiAgfVxufVxuXG5leHBvcnQgeyBTaGVwaGVyZCB9O1xuIiwiaW1wb3J0IHsgU3RlcCB9IGZyb20gJy4vc3RlcC5qcyc7XG5pbXBvcnQgeyBTaGVwaGVyZCwgVG91ciB9IGZyb20gJy4vdG91ci5qcyc7XG5cbk9iamVjdC5hc3NpZ24oU2hlcGhlcmQsIHsgVG91ciwgU3RlcCB9KTtcblxuZXhwb3J0IGRlZmF1bHQgU2hlcGhlcmQ7XG4iXSwibmFtZXMiOlsiaXNNZXJnZWFibGVPYmplY3QiLCJ2YWx1ZSIsImlzTm9uTnVsbE9iamVjdCIsImlzU3BlY2lhbCIsIl90eXBlb2YiLCJzdHJpbmdWYWx1ZSIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImlzUmVhY3RFbGVtZW50IiwiY2FuVXNlU3ltYm9sIiwiU3ltYm9sIiwiZm9yIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiJCR0eXBlb2YiLCJlbXB0eVRhcmdldCIsInZhbCIsIkFycmF5IiwiaXNBcnJheSIsImNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkIiwib3B0aW9ucyIsImNsb25lIiwiZGVlcG1lcmdlIiwiZGVmYXVsdEFycmF5TWVyZ2UiLCJ0YXJnZXQiLCJzb3VyY2UiLCJjb25jYXQiLCJtYXAiLCJlbGVtZW50IiwiZ2V0TWVyZ2VGdW5jdGlvbiIsImtleSIsImN1c3RvbU1lcmdlIiwiZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsInN5bWJvbCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiZ2V0S2V5cyIsImtleXMiLCJwcm9wZXJ0eUlzT25PYmplY3QiLCJvYmplY3QiLCJwcm9wZXJ0eSIsIl8iLCJwcm9wZXJ0eUlzVW5zYWZlIiwiaGFzT3duUHJvcGVydHkiLCJtZXJnZU9iamVjdCIsImRlc3RpbmF0aW9uIiwiZm9yRWFjaCIsImFycmF5TWVyZ2UiLCJzb3VyY2VJc0FycmF5IiwidGFyZ2V0SXNBcnJheSIsInNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2giLCJhbGwiLCJkZWVwbWVyZ2VBbGwiLCJhcnJheSIsIkVycm9yIiwicmVkdWNlIiwicHJldiIsIm5leHQiLCJkZWVwbWVyZ2VfMSIsImlzRWxlbWVudCIsImlzRWxlbWVudCQxIiwiRWxlbWVudCIsImlzSFRNTEVsZW1lbnQiLCJpc0hUTUxFbGVtZW50JDEiLCJIVE1MRWxlbWVudCIsImlzRnVuY3Rpb24iLCJpc1N0cmluZyIsImlzVW5kZWZpbmVkIiwidW5kZWZpbmVkIiwiRXZlbnRlZCIsIl9jbGFzc0NhbGxDaGVjayIsIl9jcmVhdGVDbGFzcyIsIm9uIiwiZXZlbnQiLCJoYW5kbGVyIiwiY3R4Iiwib25jZSIsImJpbmRpbmdzIiwicHVzaCIsIm9mZiIsImJpbmRpbmciLCJpbmRleCIsIl90aGlzIiwic3BsaWNlIiwidHJpZ2dlciIsImFyZ3MiLCJjb250ZXh0IiwiX3RoaXMyIiwiYXBwbHkiLCJhdXRvQmluZCIsInNlbGYiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiY29uc3RydWN0b3IiLCJpIiwibGVuZ3RoIiwiYmluZCIsIl9zZXR1cEFkdmFuY2VPbkhhbmRsZXIiLCJzZWxlY3RvciIsInN0ZXAiLCJpc09wZW4iLCJ0YXJnZXRJc0VsIiwiZWwiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0SXNTZWxlY3RvciIsIm1hdGNoZXMiLCJ0b3VyIiwiYmluZEFkdmFuY2UiLCJhZHZhbmNlT24iLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJlIiwiY29uc29sZSIsImVycm9yIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJib2R5IiwidG9wIiwiYm90dG9tIiwicmlnaHQiLCJsZWZ0IiwiYXV0byIsImJhc2VQbGFjZW1lbnRzIiwic3RhcnQiLCJlbmQiLCJjbGlwcGluZ1BhcmVudHMiLCJ2aWV3cG9ydCIsInBvcHBlciIsInJlZmVyZW5jZSIsInZhcmlhdGlvblBsYWNlbWVudHMiLCJhY2MiLCJwbGFjZW1lbnQiLCJwbGFjZW1lbnRzIiwiYmVmb3JlUmVhZCIsInJlYWQiLCJhZnRlclJlYWQiLCJiZWZvcmVNYWluIiwibWFpbiIsImFmdGVyTWFpbiIsImJlZm9yZVdyaXRlIiwid3JpdGUiLCJhZnRlcldyaXRlIiwibW9kaWZpZXJQaGFzZXMiLCJnZXROb2RlTmFtZSIsIm5vZGVOYW1lIiwidG9Mb3dlckNhc2UiLCJnZXRXaW5kb3ciLCJub2RlIiwid2luZG93Iiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiT3duRWxlbWVudCIsImlzU2hhZG93Um9vdCIsIlNoYWRvd1Jvb3QiLCJhcHBseVN0eWxlcyIsIl9yZWYiLCJzdGF0ZSIsImVsZW1lbnRzIiwibmFtZSIsInN0eWxlIiwic3R5bGVzIiwiYXR0cmlidXRlcyIsImFzc2lnbiIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsImVmZmVjdCIsImVmZmVjdCQyIiwiX3JlZjIiLCJpbml0aWFsU3R5bGVzIiwicG9zaXRpb24iLCJzdHJhdGVneSIsIm1hcmdpbiIsImFycm93Iiwic3R5bGVQcm9wZXJ0aWVzIiwiYXR0cmlidXRlIiwiZW5hYmxlZCIsInBoYXNlIiwiZm4iLCJyZXF1aXJlcyIsImdldEJhc2VQbGFjZW1lbnQiLCJzcGxpdCIsIm1heCIsIk1hdGgiLCJtaW4iLCJyb3VuZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImluY2x1ZGVTY2FsZSIsInJlY3QiLCJzY2FsZVgiLCJzY2FsZVkiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsIndpZHRoIiwiaGVpZ2h0IiwieCIsInkiLCJnZXRMYXlvdXRSZWN0IiwiY2xpZW50UmVjdCIsImFicyIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJjb250YWlucyIsInBhcmVudCIsImNoaWxkIiwicm9vdE5vZGUiLCJnZXRSb290Tm9kZSIsImlzU2FtZU5vZGUiLCJwYXJlbnROb2RlIiwiaG9zdCIsImdldENvbXB1dGVkU3R5bGUiLCJpc1RhYmxlRWxlbWVudCIsImluZGV4T2YiLCJnZXREb2N1bWVudEVsZW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRQYXJlbnROb2RlIiwiYXNzaWduZWRTbG90IiwiZ2V0VHJ1ZU9mZnNldFBhcmVudCIsIm9mZnNldFBhcmVudCIsImdldENvbnRhaW5pbmdCbG9jayIsImlzRmlyZWZveCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlzSUUiLCJlbGVtZW50Q3NzIiwiY3VycmVudE5vZGUiLCJjc3MiLCJ0cmFuc2Zvcm0iLCJwZXJzcGVjdGl2ZSIsImNvbnRhaW4iLCJ3aWxsQ2hhbmdlIiwiZ2V0T2Zmc2V0UGFyZW50IiwiZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50Iiwid2l0aGluIiwibWF0aE1heCIsIm1hdGhNaW4iLCJ3aXRoaW5NYXhDbGFtcCIsInYiLCJnZXRGcmVzaFNpZGVPYmplY3QiLCJtZXJnZVBhZGRpbmdPYmplY3QiLCJwYWRkaW5nT2JqZWN0IiwiZXhwYW5kVG9IYXNoTWFwIiwiaGFzaE1hcCIsInRvUGFkZGluZ09iamVjdCIsInBhZGRpbmciLCJyZWN0cyIsIl9zdGF0ZSRtb2RpZmllcnNEYXRhJCIsImFycm93RWxlbWVudCIsInBvcHBlck9mZnNldHMiLCJtb2RpZmllcnNEYXRhIiwiYmFzZVBsYWNlbWVudCIsImF4aXMiLCJpc1ZlcnRpY2FsIiwibGVuIiwiYXJyb3dSZWN0IiwibWluUHJvcCIsIm1heFByb3AiLCJlbmREaWZmIiwic3RhcnREaWZmIiwiYXJyb3dPZmZzZXRQYXJlbnQiLCJjbGllbnRTaXplIiwiY2xpZW50SGVpZ2h0IiwiY2xpZW50V2lkdGgiLCJjZW50ZXJUb1JlZmVyZW5jZSIsImNlbnRlciIsIm9mZnNldCIsImF4aXNQcm9wIiwiY2VudGVyT2Zmc2V0IiwiZWZmZWN0JDEiLCJfb3B0aW9ucyRlbGVtZW50IiwicmVxdWlyZXNJZkV4aXN0cyIsImdldFZhcmlhdGlvbiIsInVuc2V0U2lkZXMiLCJyb3VuZE9mZnNldHNCeURQUiIsIndpbiIsImRwciIsImRldmljZVBpeGVsUmF0aW8iLCJtYXBUb1N0eWxlcyIsIl9PYmplY3QkYXNzaWduMiIsInBvcHBlclJlY3QiLCJ2YXJpYXRpb24iLCJvZmZzZXRzIiwiZ3B1QWNjZWxlcmF0aW9uIiwiYWRhcHRpdmUiLCJyb3VuZE9mZnNldHMiLCJpc0ZpeGVkIiwiX29mZnNldHMkeCIsIl9vZmZzZXRzJHkiLCJfcmVmMyIsImhhc1giLCJoYXNZIiwic2lkZVgiLCJzaWRlWSIsImhlaWdodFByb3AiLCJ3aWR0aFByb3AiLCJvZmZzZXRZIiwidmlzdWFsVmlld3BvcnQiLCJvZmZzZXRYIiwiY29tbW9uU3R5bGVzIiwiX3JlZjQiLCJfT2JqZWN0JGFzc2lnbiIsImNvbXB1dGVTdHlsZXMiLCJfcmVmNSIsIl9vcHRpb25zJGdwdUFjY2VsZXJhdCIsIl9vcHRpb25zJGFkYXB0aXZlIiwiX29wdGlvbnMkcm91bmRPZmZzZXRzIiwiZGF0YSIsInBhc3NpdmUiLCJpbnN0YW5jZSIsIl9vcHRpb25zJHNjcm9sbCIsInNjcm9sbCIsIl9vcHRpb25zJHJlc2l6ZSIsInJlc2l6ZSIsInNjcm9sbFBhcmVudHMiLCJzY3JvbGxQYXJlbnQiLCJ1cGRhdGUiLCJoYXNoIiwiZ2V0T3Bwb3NpdGVQbGFjZW1lbnQiLCJyZXBsYWNlIiwibWF0Y2hlZCIsImdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IiwiZ2V0V2luZG93U2Nyb2xsIiwic2Nyb2xsTGVmdCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsVG9wIiwicGFnZVlPZmZzZXQiLCJnZXRXaW5kb3dTY3JvbGxCYXJYIiwiZ2V0Vmlld3BvcnRSZWN0IiwiaHRtbCIsInRlc3QiLCJnZXREb2N1bWVudFJlY3QiLCJfZWxlbWVudCRvd25lckRvY3VtZW4iLCJ3aW5TY3JvbGwiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsImRpcmVjdGlvbiIsImlzU2Nyb2xsUGFyZW50IiwiX2dldENvbXB1dGVkU3R5bGUiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImdldFNjcm9sbFBhcmVudCIsImxpc3RTY3JvbGxQYXJlbnRzIiwibGlzdCIsImlzQm9keSIsInVwZGF0ZWRMaXN0IiwicmVjdFRvQ2xpZW50UmVjdCIsImdldElubmVyQm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50VG9wIiwiY2xpZW50TGVmdCIsImdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlIiwiY2xpcHBpbmdQYXJlbnQiLCJnZXRDbGlwcGluZ1BhcmVudHMiLCJjYW5Fc2NhcGVDbGlwcGluZyIsImNsaXBwZXJFbGVtZW50IiwiZ2V0Q2xpcHBpbmdSZWN0IiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJtYWluQ2xpcHBpbmdQYXJlbnRzIiwiZmlyc3RDbGlwcGluZ1BhcmVudCIsImNsaXBwaW5nUmVjdCIsImFjY1JlY3QiLCJjb21wdXRlT2Zmc2V0cyIsImNvbW1vblgiLCJjb21tb25ZIiwibWFpbkF4aXMiLCJkZXRlY3RPdmVyZmxvdyIsIl9vcHRpb25zIiwiX29wdGlvbnMkcGxhY2VtZW50IiwiX29wdGlvbnMkYm91bmRhcnkiLCJfb3B0aW9ucyRyb290Qm91bmRhcnkiLCJfb3B0aW9ucyRlbGVtZW50Q29udGUiLCJlbGVtZW50Q29udGV4dCIsIl9vcHRpb25zJGFsdEJvdW5kYXJ5IiwiYWx0Qm91bmRhcnkiLCJfb3B0aW9ucyRwYWRkaW5nIiwiYWx0Q29udGV4dCIsImNsaXBwaW5nQ2xpZW50UmVjdCIsImNvbnRleHRFbGVtZW50IiwicmVmZXJlbmNlQ2xpZW50UmVjdCIsInBvcHBlckNsaWVudFJlY3QiLCJlbGVtZW50Q2xpZW50UmVjdCIsIm92ZXJmbG93T2Zmc2V0cyIsIm9mZnNldERhdGEiLCJtdWx0aXBseSIsImNvbXB1dGVBdXRvUGxhY2VtZW50IiwiZmxpcFZhcmlhdGlvbnMiLCJfb3B0aW9ucyRhbGxvd2VkQXV0b1AiLCJhbGxvd2VkQXV0b1BsYWNlbWVudHMiLCJhbGxQbGFjZW1lbnRzIiwiYWxsb3dlZFBsYWNlbWVudHMiLCJvdmVyZmxvd3MiLCJzb3J0IiwiYSIsImIiLCJnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyIsIm9wcG9zaXRlUGxhY2VtZW50IiwiZmxpcCIsIl9za2lwIiwiX29wdGlvbnMkbWFpbkF4aXMiLCJjaGVja01haW5BeGlzIiwiX29wdGlvbnMkYWx0QXhpcyIsImFsdEF4aXMiLCJjaGVja0FsdEF4aXMiLCJzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMiLCJmYWxsYmFja1BsYWNlbWVudHMiLCJfb3B0aW9ucyRmbGlwVmFyaWF0aW8iLCJwcmVmZXJyZWRQbGFjZW1lbnQiLCJpc0Jhc2VQbGFjZW1lbnQiLCJyZWZlcmVuY2VSZWN0IiwiY2hlY2tzTWFwIiwiTWFwIiwibWFrZUZhbGxiYWNrQ2hlY2tzIiwiZmlyc3RGaXR0aW5nUGxhY2VtZW50IiwiX2Jhc2VQbGFjZW1lbnQiLCJpc1N0YXJ0VmFyaWF0aW9uIiwibWFpblZhcmlhdGlvblNpZGUiLCJhbHRWYXJpYXRpb25TaWRlIiwiY2hlY2tzIiwiZXZlcnkiLCJjaGVjayIsInNldCIsIm51bWJlck9mQ2hlY2tzIiwiX2xvb3AiLCJfaSIsImZpdHRpbmdQbGFjZW1lbnQiLCJmaW5kIiwiZ2V0Iiwic2xpY2UiLCJfcmV0IiwicmVzZXQiLCJnZXRTaWRlT2Zmc2V0cyIsInByZXZlbnRlZE9mZnNldHMiLCJpc0FueVNpZGVGdWxseUNsaXBwZWQiLCJzb21lIiwic2lkZSIsImhpZGUiLCJwcmV2ZW50T3ZlcmZsb3ciLCJyZWZlcmVuY2VPdmVyZmxvdyIsInBvcHBlckFsdE92ZXJmbG93IiwicmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzIiwicG9wcGVyRXNjYXBlT2Zmc2V0cyIsImlzUmVmZXJlbmNlSGlkZGVuIiwiaGFzUG9wcGVyRXNjYXBlZCIsImRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZIiwiaW52ZXJ0RGlzdGFuY2UiLCJza2lkZGluZyIsImRpc3RhbmNlIiwiX29wdGlvbnMkb2Zmc2V0IiwiX2RhdGEkc3RhdGUkcGxhY2VtZW50IiwiZ2V0QWx0QXhpcyIsIl9vcHRpb25zJHRldGhlciIsInRldGhlciIsIl9vcHRpb25zJHRldGhlck9mZnNldCIsInRldGhlck9mZnNldCIsInRldGhlck9mZnNldFZhbHVlIiwibm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlIiwib2Zmc2V0TW9kaWZpZXJTdGF0ZSIsIl9vZmZzZXRNb2RpZmllclN0YXRlJCIsIm1haW5TaWRlIiwiYWx0U2lkZSIsImFkZGl0aXZlIiwibWluTGVuIiwibWF4TGVuIiwiYXJyb3dQYWRkaW5nT2JqZWN0IiwiYXJyb3dQYWRkaW5nTWluIiwiYXJyb3dQYWRkaW5nTWF4IiwiYXJyb3dMZW4iLCJtaW5PZmZzZXQiLCJtYXhPZmZzZXQiLCJjbGllbnRPZmZzZXQiLCJvZmZzZXRNb2RpZmllclZhbHVlIiwidGV0aGVyTWluIiwidGV0aGVyTWF4IiwicHJldmVudGVkT2Zmc2V0IiwiX29mZnNldE1vZGlmaWVyU3RhdGUkMiIsIl9tYWluU2lkZSIsIl9hbHRTaWRlIiwiX29mZnNldCIsIl9sZW4iLCJfbWluIiwiX21heCIsImlzT3JpZ2luU2lkZSIsIl9vZmZzZXRNb2RpZmllclZhbHVlIiwiX3RldGhlck1pbiIsIl90ZXRoZXJNYXgiLCJfcHJldmVudGVkT2Zmc2V0IiwiZ2V0SFRNTEVsZW1lbnRTY3JvbGwiLCJnZXROb2RlU2Nyb2xsIiwiaXNFbGVtZW50U2NhbGVkIiwiZ2V0Q29tcG9zaXRlUmVjdCIsImVsZW1lbnRPclZpcnR1YWxFbGVtZW50IiwiaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQiLCJvZmZzZXRQYXJlbnRJc1NjYWxlZCIsIm9yZGVyIiwibW9kaWZpZXJzIiwidmlzaXRlZCIsIlNldCIsInJlc3VsdCIsIm1vZGlmaWVyIiwiYWRkIiwiZGVwIiwiaGFzIiwiZGVwTW9kaWZpZXIiLCJvcmRlck1vZGlmaWVycyIsIm9yZGVyZWRNb2RpZmllcnMiLCJkZWJvdW5jZSIsInBlbmRpbmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJtZXJnZUJ5TmFtZSIsIm1lcmdlZCIsImN1cnJlbnQiLCJleGlzdGluZyIsIkRFRkFVTFRfT1BUSU9OUyIsImFyZVZhbGlkRWxlbWVudHMiLCJhcmd1bWVudHMiLCJfa2V5IiwicG9wcGVyR2VuZXJhdG9yIiwiZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zIiwiX2dlbmVyYXRvck9wdGlvbnMkZGVmIiwiZGVmYXVsdE1vZGlmaWVycyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZjIiLCJkZWZhdWx0T3B0aW9ucyIsImNyZWF0ZVBvcHBlciIsImVmZmVjdENsZWFudXBGbnMiLCJpc0Rlc3Ryb3llZCIsInNldE9wdGlvbnMiLCJzZXRPcHRpb25zQWN0aW9uIiwiY2xlYW51cE1vZGlmaWVyRWZmZWN0cyIsIm0iLCJydW5Nb2RpZmllckVmZmVjdHMiLCJmb3JjZVVwZGF0ZSIsIl9zdGF0ZSRlbGVtZW50cyIsIl9zdGF0ZSRvcmRlcmVkTW9kaWZpZSIsIl9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIiLCJkZXN0cm95Iiwib25GaXJzdFVwZGF0ZSIsIl9yZWYzJG9wdGlvbnMiLCJjbGVhbnVwRm4iLCJub29wRm4iLCJldmVudExpc3RlbmVycyIsIl9nZXRDZW50ZXJlZFN0eWxlUG9wcGVyTW9kaWZpZXIiLCJnZW5lcmF0ZUZvY3VzQWZ0ZXJSZW5kZXJNb2RpZmllciIsInNldFRpbWVvdXQiLCJmb2N1c09wdGlvbnMiLCJwcmV2ZW50U2Nyb2xsIiwiZm9jdXMiLCJtYWtlQ2VudGVyZWRQb3BwZXIiLCJjZW50ZXJlZFN0eWxlUG9wcGVyTW9kaWZpZXIiLCJwb3BwZXJPcHRpb25zIiwiZnJvbSIsIm5vcm1hbGl6ZVByZWZpeCIsInByZWZpeCIsImNoYXJBdCIsInBhcnNlQXR0YWNoVG8iLCJhdHRhY2hUbyIsInJldHVybk9wdHMiLCJzaG91bGRDZW50ZXJTdGVwIiwicmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMiLCJzZXR1cFRvb2x0aXAiLCJ0b29sdGlwIiwiYXR0YWNoVG9PcHRpb25zIiwiX2dldFJlc29sdmVkQXR0YWNoVG9PcHRpb25zIiwiZ2V0UG9wcGVyT3B0aW9ucyIsImNvbnRlbnQiLCJzaGVwaGVyZEVsZW1lbnRDb21wb25lbnQiLCJnZXRFbGVtZW50IiwiY2xhc3NMaXN0IiwidXVpZCIsImQiLCJEYXRlIiwibm93IiwiYyIsInIiLCJyYW5kb20iLCJmbG9vciIsImRlZmF1bHRTdGVwT3B0aW9ucyIsIl9tZXJnZU1vZGlmaWVycyIsInN0ZXBPcHRpb25zIiwibWVyZ2VkUG9wcGVyT3B0aW9ucyIsIm5hbWVzIiwibW9kIiwiZmlsdGVyZWRNb2RpZmllcnMiLCJpbmNsdWRlcyIsIm5vb3AiLCJ0YXIiLCJzcmMiLCJrIiwicnVuIiwiYmxhbmtfb2JqZWN0IiwiY3JlYXRlIiwicnVuX2FsbCIsImZucyIsImlzX2Z1bmN0aW9uIiwidGhpbmciLCJzYWZlX25vdF9lcXVhbCIsImlzX2VtcHR5Iiwib2JqIiwiYXBwZW5kIiwiYXBwZW5kQ2hpbGQiLCJpbnNlcnQiLCJhbmNob3IiLCJpbnNlcnRCZWZvcmUiLCJkZXRhY2giLCJyZW1vdmVDaGlsZCIsImRlc3Ryb3lfZWFjaCIsIml0ZXJhdGlvbnMiLCJkZXRhY2hpbmciLCJjcmVhdGVFbGVtZW50Iiwic3ZnX2VsZW1lbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJ0ZXh0IiwiY3JlYXRlVGV4dE5vZGUiLCJzcGFjZSIsImVtcHR5IiwibGlzdGVuIiwiYXR0ciIsImdldEF0dHJpYnV0ZSIsInNldF9hdHRyaWJ1dGVzIiwiZGVzY3JpcHRvcnMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiX19wcm90b19fIiwiY3NzVGV4dCIsImNoaWxkcmVuIiwiY2hpbGROb2RlcyIsInRvZ2dsZV9jbGFzcyIsInRvZ2dsZSIsImN1cnJlbnRfY29tcG9uZW50Iiwic2V0X2N1cnJlbnRfY29tcG9uZW50IiwiY29tcG9uZW50IiwiZ2V0X2N1cnJlbnRfY29tcG9uZW50Iiwib25Nb3VudCIsIiQkIiwib25fbW91bnQiLCJhZnRlclVwZGF0ZSIsImFmdGVyX3VwZGF0ZSIsImRpcnR5X2NvbXBvbmVudHMiLCJiaW5kaW5nX2NhbGxiYWNrcyIsInJlbmRlcl9jYWxsYmFja3MiLCJmbHVzaF9jYWxsYmFja3MiLCJyZXNvbHZlZF9wcm9taXNlIiwidXBkYXRlX3NjaGVkdWxlZCIsInNjaGVkdWxlX3VwZGF0ZSIsImZsdXNoIiwiYWRkX3JlbmRlcl9jYWxsYmFjayIsInNlZW5fY2FsbGJhY2tzIiwiZmx1c2hpZHgiLCJzYXZlZF9jb21wb25lbnQiLCJwb3AiLCJjYWxsYmFjayIsImNsZWFyIiwiZnJhZ21lbnQiLCJiZWZvcmVfdXBkYXRlIiwiZGlydHkiLCJwIiwib3V0cm9pbmciLCJvdXRyb3MiLCJncm91cF9vdXRyb3MiLCJjaGVja19vdXRyb3MiLCJ0cmFuc2l0aW9uX2luIiwiYmxvY2siLCJsb2NhbCIsImRlbGV0ZSIsInRyYW5zaXRpb25fb3V0IiwibyIsImdldF9zcHJlYWRfdXBkYXRlIiwibGV2ZWxzIiwidXBkYXRlcyIsInRvX251bGxfb3V0IiwiYWNjb3VudGVkX2ZvciIsIiQkc2NvcGUiLCJuIiwiY3JlYXRlX2NvbXBvbmVudCIsIm1vdW50X2NvbXBvbmVudCIsImN1c3RvbUVsZW1lbnQiLCJvbl9kZXN0cm95IiwibmV3X29uX2Rlc3Ryb3kiLCJkZXN0cm95X2NvbXBvbmVudCIsIm1ha2VfZGlydHkiLCJmaWxsIiwiaW5pdCIsImNyZWF0ZV9mcmFnbWVudCIsIm5vdF9lcXVhbCIsInByb3BzIiwiYXBwZW5kX3N0eWxlcyIsInBhcmVudF9jb21wb25lbnQiLCJib3VuZCIsIm9uX2Rpc2Nvbm5lY3QiLCJjYWxsYmFja3MiLCJza2lwX2JvdW5kIiwicm9vdCIsInJlYWR5IiwicmV0IiwiaHlkcmF0ZSIsIm5vZGVzIiwibCIsImludHJvIiwiU3ZlbHRlQ29tcG9uZW50IiwiJGRlc3Ryb3kiLCIkb24iLCJ0eXBlIiwiJHNldCIsIiQkcHJvcHMiLCIkJHNldCIsImFjdGlvbiIsImNsYXNzZXMiLCJkaXNhYmxlZCIsImxhYmVsIiwic2Vjb25kYXJ5Iiwib3B0aW9uIiwiJCRpbnZhbGlkYXRlIiwiY29uZmlnIiwiZ2V0Q29uZmlnT3B0aW9uIiwiY3JlYXRlX2lmX2Jsb2NrIiwiJCIsImJ1dHRvbnMiLCJoYW5kbGVDYW5jZWxDbGljayIsInByZXZlbnREZWZhdWx0IiwiY2FuY2VsIiwibGFiZWxJZCIsInRpdGxlIiwiaW5uZXJIVE1MIiwiY3JlYXRlX2lmX2Jsb2NrXzEiLCJjYW5jZWxJY29uIiwiZGVzY3JpcHRpb25JZCIsImNsYXNzTmFtZSIsImZpcnN0Rm9jdXNhYmxlRWxlbWVudCIsImZvY3VzYWJsZUVsZW1lbnRzIiwibGFzdEZvY3VzYWJsZUVsZW1lbnQiLCJkYXRhU3RlcElkIiwiaGFzQ2FuY2VsSWNvbiIsImhhc1RpdGxlIiwiY2xhc3NQcmVmaXgiLCJpZCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJ1cGRhdGVEeW5hbWljQ2xhc3NlcyIsInJlbW92ZUNsYXNzZXMiLCJhZGRDbGFzc2VzIiwib2xkQ2xhc3NlcyIsImdldENsYXNzZXNBcnJheSIsInJlbW92ZSIsIm5ld0NsYXNzZXMiLCJoYW5kbGVLZXlEb3duIiwia2V5Q29kZSIsIktFWV9UQUIiLCJzaGlmdEtleSIsImFjdGl2ZUVsZW1lbnQiLCJLRVlfRVNDIiwiZXhpdE9uRXNjIiwiTEVGVF9BUlJPVyIsImtleWJvYXJkTmF2aWdhdGlvbiIsImJhY2siLCJSSUdIVF9BUlJPVyIsInBvbHlmaWxsIiwidyIsIl9fZm9yY2VTbW9vdGhTY3JvbGxQb2x5ZmlsbF9fIiwiU0NST0xMX1RJTUUiLCJvcmlnaW5hbCIsInNjcm9sbFRvIiwic2Nyb2xsQnkiLCJlbGVtZW50U2Nyb2xsIiwic2Nyb2xsRWxlbWVudCIsInNjcm9sbEludG9WaWV3IiwicGVyZm9ybWFuY2UiLCJpc01pY3Jvc29mdEJyb3dzZXIiLCJ1c2VyQWdlbnRQYXR0ZXJucyIsIlJlZ0V4cCIsImpvaW4iLCJST1VORElOR19UT0xFUkFOQ0UiLCJlYXNlIiwiY29zIiwiUEkiLCJzaG91bGRCYWlsT3V0IiwiZmlyc3RBcmciLCJiZWhhdmlvciIsIlR5cGVFcnJvciIsImhhc1Njcm9sbGFibGVTcGFjZSIsImNhbk92ZXJmbG93Iiwib3ZlcmZsb3dWYWx1ZSIsImlzU2Nyb2xsYWJsZSIsImlzU2Nyb2xsYWJsZVkiLCJpc1Njcm9sbGFibGVYIiwiZmluZFNjcm9sbGFibGVQYXJlbnQiLCJ0aW1lIiwiY3VycmVudFgiLCJjdXJyZW50WSIsImVsYXBzZWQiLCJzdGFydFRpbWUiLCJzdGFydFgiLCJzdGFydFkiLCJtZXRob2QiLCJzY3JvbGxhYmxlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic21vb3RoU2Nyb2xsIiwic2Nyb2xsWCIsInNjcm9sbFkiLCJTeW50YXhFcnJvciIsInNjcm9sbGFibGVQYXJlbnQiLCJwYXJlbnRSZWN0cyIsImNsaWVudFJlY3RzIiwibW9kdWxlIiwic21vb3Roc2Nyb2xsIiwiU3RlcCIsIl9pbmhlcml0cyIsIl90aGlzMTEiLCJfcmVzb2x2ZWRBdHRhY2hUbyIsIl9zZXRPcHRpb25zIiwiY29tcGxldGUiLCJfdXBkYXRlU3RlcFRhcmdldE9uSGlkZSIsImdldFRvdXIiLCJtb2RhbCIsImhpZGRlbiIsIl9yZXNvbHZlQXR0YWNoVG9PcHRpb25zIiwiQm9vbGVhbiIsInNob3ciLCJiZWZvcmVTaG93UHJvbWlzZSIsIl90aGlzMTIiLCJfc2hvdyIsInVwZGF0ZVN0ZXBPcHRpb25zIiwiZ2V0VGFyZ2V0IiwiX2NyZWF0ZVRvb2x0aXBDb250ZW50IiwiU2hlcGhlcmRFbGVtZW50Iiwic3RlcHNDb250YWluZXIiLCJfc2Nyb2xsVG8iLCJzY3JvbGxUb09wdGlvbnMiLCJzY3JvbGxUb0hhbmRsZXIiLCJfZ2V0Q2xhc3NPcHRpb25zIiwic3RlcENsYXNzZXMiLCJkZWZhdWx0U3RlcE9wdGlvbnNDbGFzc2VzIiwiYWxsQ2xhc3NlcyIsInVuaXFDbGFzc2VzIiwidHJpbSIsInRvdXJPcHRpb25zIiwibWVyZ2UiLCJ3aGVuIiwiX3RoaXMxMyIsIl9zZXR1cEVsZW1lbnRzIiwiX3NldHVwTW9kYWwiLCJzZXR1cEZvclN0ZXAiLCJfc3R5bGVUYXJnZXRFbGVtZW50Rm9yU3RlcCIsIl90aGlzMTQiLCJ0YXJnZXRFbGVtZW50IiwiaGlnaGxpZ2h0Q2xhc3MiLCJjYW5DbGlja1RhcmdldCIsImNsZWFudXBTdGVwcyIsInN0ZXBzIiwibWFrZU92ZXJsYXlQYXRoIiwiX3JlZiR4IiwiX3JlZiR5IiwiX3JlZiRyIiwiaW5uZXJXaWR0aCIsImgiLCJpbm5lckhlaWdodCIsImlzSHRtbEVsZW1lbnQiLCJfZ2V0U2Nyb2xsUGFyZW50IiwicGFyZW50RWxlbWVudCIsIl9nZXRWaXNpYmxlSGVpZ2h0IiwiZWxlbWVudFJlY3QiLCJzY3JvbGxSZWN0Iiwic2Nyb2xsQm90dG9tIiwib3BlbmluZ1Byb3BlcnRpZXMiLCJwYXRoRGVmaW5pdGlvbiIsImNsb3NlTW9kYWxPcGVuaW5nIiwiX2NsZWFudXBTdGVwRXZlbnRMaXN0ZW5lcnMiLCJwb3NpdGlvbk1vZGFsIiwibW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmciLCJtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzIiwidXNlTW9kYWxPdmVybGF5IiwiX3N0eWxlRm9yU3RlcCIsIl9wcmV2ZW50TW9kYWxCb2R5VG91Y2giLCJfcHJldmVudE1vZGFsT3ZlcmxheVRvdWNoIiwic3RvcFByb3BhZ2F0aW9uIiwiX2FkZFN0ZXBFdmVudExpc3RlbmVycyIsInJhZklkIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyYWZMb29wIiwiU2hlcGhlcmQiLCJUb3VyIiwiX3RoaXMxNiIsImRlZmF1bHRUb3VyT3B0aW9ucyIsImFkZFN0ZXBzIiwiZXZlbnRzIiwib3B0cyIsIl9zZXRUb3VySUQiLCJhZGRTdGVwIiwiX3RoaXMxNyIsImN1cnJlbnRTdGVwIiwiY29uZmlybUNhbmNlbCIsImNhbmNlbE1lc3NhZ2UiLCJjb25maXJtQ2FuY2VsTWVzc2FnZSIsInN0b3BUb3VyIiwiY29uZmlybSIsIl9kb25lIiwiZ2V0QnlJZCIsImdldEN1cnJlbnRTdGVwIiwiaXNBY3RpdmUiLCJhY3RpdmVUb3VyIiwicmVtb3ZlU3RlcCIsIl90aGlzMTgiLCJmb3J3YXJkIiwiX3VwZGF0ZVN0YXRlQmVmb3JlU2hvdyIsInNob3VsZFNraXBTdGVwIiwic2hvd09uIiwiX3NraXBTdGVwIiwicHJldmlvdXMiLCJmb2N1c2VkRWxCZWZvcmVPcGVuIiwiX3NldHVwQWN0aXZlVG91ciIsIm1vZGFsQ29udGFpbmVyIiwiU2hlcGhlcmRNb2RhbCIsIm5leHRJbmRleCIsInRvdXJOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/shepherd.js/dist/js/shepherd.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./libs/shepherd/shepherd.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});